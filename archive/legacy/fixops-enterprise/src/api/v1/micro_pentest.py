"""Micro penetration test API endpoints for PentAGI integration.

This module provides enterprise micro penetration testing capabilities with:
- MITRE ATT&CK-aligned threat modeling
- Compliance framework validation (SOC2, PCI-DSS, HIPAA, GDPR, etc.)
- Multi-tenant support with audit logging
- Attack path generation and risk scoring
"""

from __future__ import annotations

import asyncio
import os
from typing import Any, Dict, List, MutableMapping, Optional

import httpx
import structlog
from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field
from src.api.dependencies import authenticate, authenticated_payload
from src.services.micro_pentest_engine import (
    AttackSurface,
    AttackVector,
    ComplianceFramework,
    MicroScanConfig,
    MicroScanStatus,
    RiskLevel,
    ScanMode,
    ThreatCategory,
    ThreatModel,
    micro_pentest_engine,
)

logger = structlog.get_logger(__name__)

router = APIRouter(tags=["micro-pentest"])


# Pydantic models for API requests/responses
class AttackSurfaceRequest(BaseModel):
    """Request model for attack surface definition."""

    name: str = Field(..., description="Name of the attack surface")
    target_url: str = Field(..., description="Target URL to test")
    target_type: str = Field(
        default="api",
        description="Type: api, web_app, mobile_app, infrastructure, cloud",
    )
    endpoints: List[str] = Field(default_factory=list, description="List of endpoints")
    authentication_required: bool = Field(default=False)
    authentication_type: Optional[str] = Field(default=None)
    headers: Dict[str, str] = Field(default_factory=dict)
    technologies: List[str] = Field(default_factory=list)
    environment: str = Field(default="development")


class ThreatModelRequest(BaseModel):
    """Request model for threat model definition."""

    name: str = Field(..., description="Name of the threat model")
    description: str = Field(default="", description="Description")
    categories: List[str] = Field(
        default_factory=list, description="MITRE ATT&CK categories"
    )
    attack_vectors: List[str] = Field(
        default_factory=list, description="Attack vectors to test"
    )
    compliance_frameworks: List[str] = Field(
        default_factory=list, description="Compliance frameworks to validate"
    )
    priority: int = Field(default=5, ge=1, le=10)


class EnterpriseScanRequest(BaseModel):
    """Request model for enterprise micro pentest scan."""

    name: str = Field(..., description="Scan name")
    attack_surface: AttackSurfaceRequest
    threat_model: ThreatModelRequest
    scan_mode: str = Field(
        default="active", description="passive, active, aggressive, stealth"
    )
    timeout_seconds: int = Field(default=300, ge=30, le=3600)
    stop_on_critical: bool = Field(default=True)
    include_proof_of_concept: bool = Field(default=True)
    tenant_id: str = Field(default="default")
    organization_id: str = Field(default="default")
    tags: List[str] = Field(default_factory=list)


class ScanResultResponse(BaseModel):
    """Response model for scan results."""

    scan_id: str
    status: str
    findings_count: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    compliance_status: Dict[str, bool]
    attack_paths_count: int
    execution_time_seconds: float
    summary: Dict[str, Any]


def _get_pentagi_client() -> httpx.AsyncClient:
    """Get PentAGI API client."""
    # Note: get_settings() available for future configuration needs
    # Get PentAGI URL from environment or use default
    pentagi_url = os.environ.get("PENTAGI_BASE_URL", "http://pentagi:8443")
    return httpx.AsyncClient(
        base_url=pentagi_url,
        timeout=300.0,  # 5 minutes for pen tests
    )


@router.post("/run", response_model=dict)
async def run_micro_pentest(
    payload: Dict[str, Any] = Depends(authenticated_payload),
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Run micro penetration tests for selected CVEs using PentAGI."""

    cve_ids = payload.get("cve_ids", [])
    target_urls = payload.get("target_urls", [])
    context = payload.get("context", {})

    if not cve_ids:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="At least one CVE ID is required",
        )

    if not target_urls:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="At least one target URL is required",
        )

    logger.info(
        "micro_pentest.start",
        cve_count=len(cve_ids),
        target_count=len(target_urls),
        cve_ids=cve_ids[:5],  # Log first 5 CVEs
    )

    # Prepare PentAGI flow request
    # Based on PentAGI's CreateFlow model structure
    pentagi_payload = {
        "input": f"Perform micro penetration tests for CVEs: {', '.join(cve_ids)}. "
        f"Target URLs: {', '.join(target_urls)}. "
        f"Focus on verifying exploitability and impact assessment. "
        f"Test each CVE individually and provide detailed findings.",
        "provider": "openai",  # Default provider, can be configured via env
        "functions": {
            "disabled": [],
            "functions": [],
        },
    }

    # Add context if provided
    if context:
        pentagi_payload["context"] = context

    try:
        async with _get_pentagi_client() as client:
            # Create PentAGI flow using REST API
            # PentAGI expects: POST /api/v1/flows with CreateFlow model
            response = await client.post(
                "/api/v1/flows",
                json=pentagi_payload,
                headers={
                    "Content-Type": "application/json",
                },
            )

            if response.status_code != status.HTTP_201_CREATED:
                logger.error(
                    "micro_pentest.pentagi_error",
                    status_code=response.status_code,
                    response_text=response.text,
                )
                raise HTTPException(
                    status_code=status.HTTP_502_BAD_GATEWAY,
                    detail="PentAGI API error: upstream service returned an error",
                )

            # PentAGI returns: { "data": { "id": ..., ... } } or { "id": ..., ... }
            flow_data = response.json()
            flow_obj = flow_data.get("data", flow_data)
            flow_id = flow_obj.get("id") or flow_obj.get("flow_id")

            logger.info("micro_pentest.flow_created", flow_id=flow_id)

            return {
                "status": "started",
                "flow_id": flow_id,
                "cve_ids": cve_ids,
                "target_urls": target_urls,
                "message": f"Micro penetration test started for {len(cve_ids)} CVEs",
            }

    except httpx.TimeoutException:
        logger.error("micro_pentest.timeout")
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="PentAGI request timeout",
        )
    except httpx.RequestError as e:
        logger.error("micro_pentest.request_error", exc_info=e)
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail="Failed to connect to PentAGI",
        )


@router.get("/status/{flow_id}", response_model=dict)
async def get_pentest_status(
    flow_id: int,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Get status of a micro penetration test flow."""

    try:
        async with _get_pentagi_client() as client:
            response = await client.get(
                f"/api/v1/flows/{flow_id}",
            )

            if response.status_code != status.HTTP_200_OK:
                raise HTTPException(
                    status_code=response.status_code,
                    detail=f"Failed to get flow status: {response.text}",
                )

            flow_data = response.json()
            return {
                "flow_id": flow_id,
                "status": flow_data.get("status", "unknown"),
                "progress": flow_data.get("progress", 0),
                "tasks": flow_data.get("tasks", []),
            }

    except httpx.RequestError as e:
        logger.error("micro_pentest.status_error", flow_id=flow_id, exc_info=e)
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail="Failed to connect to PentAGI",
        )


@router.post("/batch", response_model=dict)
async def run_batch_micro_pentests(
    payload: Dict[str, Any] = Depends(authenticated_payload),
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Run multiple micro penetration tests in parallel."""

    test_configs = payload.get("test_configs", [])

    if not test_configs:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="At least one test configuration is required",
        )

    logger.info("micro_pentest.batch_start", count=len(test_configs))

    # Run tests in parallel
    tasks = []
    for config in test_configs:
        task_payload = {
            "cve_ids": config.get("cve_ids", []),
            "target_urls": config.get("target_urls", []),
            "context": config.get("context", {}),
        }
        tasks.append(run_micro_pentest(task_payload, None))

    results = await asyncio.gather(*tasks, return_exceptions=True)

    successful = [r for r in results if not isinstance(r, Exception)]
    failed = [r for r in results if isinstance(r, Exception)]

    return {
        "status": "completed",
        "total": len(test_configs),
        "successful": len(successful),
        "failed": len(failed),
        "results": [
            {
                "status": "success",
                "flow_id": r.get("flow_id"),
                "cve_ids": r.get("cve_ids", []),
            }
            if not isinstance(r, Exception)
            else {"status": "error", "error": str(r)}
            for r in results
        ],
    }


# ============================================================================
# Enterprise Micro Pentest Engine Endpoints
# ============================================================================


@router.post("/enterprise/scan", response_model=dict)
async def run_enterprise_scan(
    request: EnterpriseScanRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Run an enterprise micro penetration test scan.

    This endpoint provides advanced security testing with:
    - 8-phase scanning process (initialization, reconnaissance, threat modeling,
      vulnerability scanning, exploitation, compliance validation, risk scoring,
      attack path generation)
    - MITRE ATT&CK-aligned threat categorization
    - Compliance framework validation (SOC2, PCI-DSS, HIPAA, GDPR, etc.)
    - Multi-tenant support with audit logging
    """
    logger.info(
        "enterprise_scan.start",
        name=request.name,
        target_url=request.attack_surface.target_url,
        scan_mode=request.scan_mode,
    )

    # Convert request to engine config
    attack_surface = AttackSurface(
        name=request.attack_surface.name,
        target_url=request.attack_surface.target_url,
        target_type=request.attack_surface.target_type,
        endpoints=request.attack_surface.endpoints,
        authentication_required=request.attack_surface.authentication_required,
        authentication_type=request.attack_surface.authentication_type,
        headers=request.attack_surface.headers,
        technologies=request.attack_surface.technologies,
        environment=request.attack_surface.environment,
    )

    # Parse threat model
    categories = []
    for cat in request.threat_model.categories:
        try:
            categories.append(ThreatCategory(cat))
        except ValueError:
            pass

    attack_vectors = []
    for vec in request.threat_model.attack_vectors:
        try:
            attack_vectors.append(AttackVector(vec))
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Unsupported attack vector: {vec}",
            )

    compliance_frameworks = []
    for fw in request.threat_model.compliance_frameworks:
        try:
            compliance_frameworks.append(ComplianceFramework(fw))
        except ValueError:
            pass

    threat_model = ThreatModel(
        name=request.threat_model.name,
        description=request.threat_model.description,
        categories=categories,
        attack_vectors=attack_vectors,
        compliance_frameworks=compliance_frameworks,
        priority=request.threat_model.priority,
    )

    # Parse scan mode
    try:
        scan_mode = ScanMode(request.scan_mode)
    except ValueError:
        scan_mode = ScanMode.ACTIVE

    config = MicroScanConfig(
        name=request.name,
        attack_surface=attack_surface,
        threat_model=threat_model,
        scan_mode=scan_mode,
        timeout_seconds=request.timeout_seconds,
        stop_on_critical=request.stop_on_critical,
        include_proof_of_concept=request.include_proof_of_concept,
        tenant_id=request.tenant_id,
        organization_id=request.organization_id,
        tags=request.tags,
    )

    # Run the scan
    result = await micro_pentest_engine.run_scan(config)

    # Count findings by severity
    critical_count = sum(
        1 for f in result.findings if f.risk_level == RiskLevel.CRITICAL
    )
    high_count = sum(1 for f in result.findings if f.risk_level == RiskLevel.HIGH)
    medium_count = sum(1 for f in result.findings if f.risk_level == RiskLevel.MEDIUM)
    low_count = sum(1 for f in result.findings if f.risk_level == RiskLevel.LOW)

    logger.info(
        "enterprise_scan.completed",
        scan_id=result.scan_id,
        findings_count=len(result.findings),
        critical_count=critical_count,
    )

    return {
        "scan_id": result.scan_id,
        "status": result.status.value,
        "findings_count": len(result.findings),
        "critical_count": critical_count,
        "high_count": high_count,
        "medium_count": medium_count,
        "low_count": low_count,
        "compliance_status": result.compliance_status,
        "attack_paths_count": len(result.attack_paths),
        "execution_time_seconds": result.execution_time_seconds,
        "summary": result.summary,
    }


@router.get("/enterprise/scan/{scan_id}", response_model=dict)
async def get_enterprise_scan_result(
    scan_id: str,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Get detailed results of an enterprise micro pentest scan."""
    result = await micro_pentest_engine.get_scan_result(scan_id)

    if not result:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Scan {scan_id} not found",
        )

    return result.to_dict()


@router.get("/enterprise/scans", response_model=dict)
async def list_enterprise_scans(
    tenant_id: Optional[str] = Query(None, description="Filter by tenant ID"),
    organization_id: Optional[str] = Query(
        None, description="Filter by organization ID"
    ),
    scan_status: Optional[str] = Query(None, description="Filter by status"),
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """List enterprise micro pentest scans with optional filtering."""
    status_filter = None
    if scan_status:
        try:
            status_filter = MicroScanStatus(scan_status)
        except ValueError:
            pass

    scans = await micro_pentest_engine.list_scans(
        tenant_id=tenant_id,
        organization_id=organization_id,
        status=status_filter,
    )

    return {
        "total": len(scans),
        "scans": [
            {
                "scan_id": s.scan_id,
                "status": s.status.value,
                "findings_count": len(s.findings),
                "started_at": s.started_at.isoformat() if s.started_at else None,
                "completed_at": s.completed_at.isoformat() if s.completed_at else None,
            }
            for s in scans
        ],
    }


@router.post("/enterprise/scan/{scan_id}/cancel", response_model=dict)
async def cancel_enterprise_scan(
    scan_id: str,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Cancel a running enterprise micro pentest scan."""
    success = await micro_pentest_engine.cancel_scan(scan_id, user_id="api_user")

    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Cannot cancel scan {scan_id}. It may not exist or is not running.",
        )

    return {"status": "cancelled", "scan_id": scan_id}


@router.get("/enterprise/audit-logs", response_model=dict)
async def get_audit_logs(
    tenant_id: Optional[str] = Query(None, description="Filter by tenant ID"),
    organization_id: Optional[str] = Query(
        None, description="Filter by organization ID"
    ),
    user_id: Optional[str] = Query(None, description="Filter by user ID"),
    action: Optional[str] = Query(None, description="Filter by action"),
    limit: int = Query(
        100, ge=1, le=1000, description="Maximum number of logs to return"
    ),
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Get audit logs for compliance tracking."""
    logs = await micro_pentest_engine.get_audit_logs(
        tenant_id=tenant_id,
        organization_id=organization_id,
        user_id=user_id,
        action=action,
        limit=limit,
    )

    return {
        "total": len(logs),
        "logs": [log.to_dict() for log in logs],
    }


@router.get("/enterprise/health", response_model=dict)
async def get_engine_health(
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """Get health status of the micro pentest engine."""
    return await micro_pentest_engine.get_health()


@router.get("/enterprise/attack-vectors", response_model=dict)
async def list_attack_vectors(
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """List all supported attack vectors."""
    return {
        "attack_vectors": [
            {
                "id": v.value,
                "name": v.name.replace("_", " ").title(),
                "description": f"Test for {v.name.replace('_', ' ').lower()} vulnerabilities",
            }
            for v in AttackVector
        ]
    }


@router.get("/enterprise/threat-categories", response_model=dict)
async def list_threat_categories(
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """List all MITRE ATT&CK-aligned threat categories."""
    return {
        "threat_categories": [
            {
                "id": c.value,
                "name": c.name.replace("_", " ").title(),
                "mitre_tactic": c.value,
            }
            for c in ThreatCategory
        ]
    }


@router.get("/enterprise/compliance-frameworks", response_model=dict)
async def list_compliance_frameworks(
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """List all supported compliance frameworks."""
    framework_info = {
        ComplianceFramework.SOC2: "SOC 2 Type II - Service Organization Control",
        ComplianceFramework.ISO27001: "ISO 27001:2022 - Information Security Management",
        ComplianceFramework.PCI_DSS: "PCI DSS v4.0 - Payment Card Industry Data Security",
        ComplianceFramework.HIPAA: "HIPAA Security Rule - Healthcare Data Protection",
        ComplianceFramework.GDPR: "GDPR Article 32 - EU Data Protection",
        ComplianceFramework.NIST_800_53: "NIST 800-53 - Federal Security Controls",
        ComplianceFramework.CIS: "CIS Controls - Center for Internet Security",
        ComplianceFramework.OWASP_TOP_10: "OWASP Top 10 2021 - Web Application Security",
    }

    return {
        "compliance_frameworks": [
            {
                "id": f.value,
                "name": f.name.replace("_", " "),
                "description": framework_info.get(f, f.value),
            }
            for f in ComplianceFramework
        ]
    }


@router.get("/enterprise/scan-modes", response_model=dict)
async def list_scan_modes(
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """List all supported scan modes."""
    mode_info = {
        ScanMode.PASSIVE: "Non-intrusive reconnaissance only",
        ScanMode.ACTIVE: "Active probing and testing (recommended)",
        ScanMode.AGGRESSIVE: "Full exploitation attempts",
        ScanMode.STEALTH: "Evasive testing to avoid detection",
    }

    return {
        "scan_modes": [
            {
                "id": m.value,
                "name": m.name.title(),
                "description": mode_info.get(m, m.value),
            }
            for m in ScanMode
        ]
    }


__all__ = ["router"]
