#!/usr/bin/env python3
"""Run a micro penetration test and capture results to a file in real-time."""

import json
import sys
import time
from pathlib import Path

import requests

OUTPUT_DIR = Path(".fixops_data")
OUTPUT_FILE = str(OUTPUT_DIR / "micropentest_live_results.txt")
BASE = "http://localhost:8000"
HEADERS = {"X-API-Key": "test-token-123", "Content-Type": "application/json"}


def log(msg):
    ts = time.strftime("%H:%M:%S")
    line = f"[{ts}] {msg}"
    print(line, flush=True)
    with open(OUTPUT_FILE, "a") as f:
        f.write(line + "\n")


def main():
    # Clear file
    with open(OUTPUT_FILE, "w") as f:
        f.write("=" * 70 + "\n")
        f.write("  ALdeci Micro Penetration Test - Live Results\n")
        f.write(f"  Started: {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime())}\n")
        f.write("=" * 70 + "\n\n")

    log("Starting ADVANCED micro penetration test...")
    cves = [
        "CVE-2021-44228",  # Log4Shell
        "CVE-2023-44487",  # HTTP/2 Rapid Reset
        "CVE-2024-3094",   # xz backdoor
        "CVE-2022-22965",  # Spring4Shell
        "CVE-2023-4966",   # Citrix Bleed
        "CVE-2014-0160",   # Heartbleed
        "CVE-2017-5638",   # Apache Struts
        "CVE-2023-27997",  # Fortinet SSL-VPN
        "CVE-2023-20198",  # Cisco IOS XE
        "CVE-2024-21887",  # Ivanti Connect Secure
        "CVE-2023-0669",   # GoAnywhere MFT
        "CVE-2023-27350",  # PaperCut
        "CVE-2024-1709",   # ConnectWise ScreenConnect
    ]
    targets = [
        "https://httpbin.org",
        "https://example.com",
        "https://www.google.com",
        "https://github.com",
    ]
    log(f"Target CVEs: {len(cves)} CVEs")
    for c in cves:
        log(f"  - {c}")
    log(f"Target URLs: {len(targets)} targets")
    for t in targets:
        log(f"  - {t}")
    log("")

    payload = {
        "cve_ids": cves,
        "target_urls": targets,
        "context": {"scan_type": "advanced", "environment": "development"},
    }

    log("Sending POST /api/v1/micro-pentest/run ...")
    t0 = time.time()

    try:
        resp = requests.post(
            f"{BASE}/api/v1/micro-pentest/run",
            json=payload,
            headers=HEADERS,
            timeout=300,
        )
        elapsed = time.time() - t0
        log(f"Response received in {elapsed:.2f}s (HTTP {resp.status_code})")
        log("")

        if resp.status_code in (200, 201):
            data = resp.json()
            # Cache full response for report generator (--cached mode)
            cache_file = OUTPUT_DIR / "pentest_report_data.json"
            cache_file.write_text(json.dumps(data, indent=2))
            log(f"Status: {data.get('status', 'unknown')}")
            log(f"Flow ID: {data.get('flow_id', 'N/A')}")
            log(f"Message: {data.get('message', 'N/A')}")
            log("")

            # --- Scan Metadata ---
            meta = data.get("scan_metadata")
            if meta:
                log("=" * 60)
                log("  SCAN METADATA")
                log("=" * 60)
                log(f"  Engine:              {meta.get('engine', 'unknown')}")
                log(f"  MPTE available:      {meta.get('mpte_available', 'N/A')}")
                log(f"  CVE tests run:       {meta.get('total_cve_tests', 0)}")
                log(f"  Targets scanned:     {meta.get('total_targets', 0)}")
                log(f"  Total findings:      {meta.get('total_findings', 0)}")
                log(f"  Scan phases:         {meta.get('scan_phases', 'N/A')}")
                log(f"  Verification stages: {meta.get('verification_stages', 'N/A')}")
                vc = meta.get("verdict_counts", {})
                if vc:
                    log("")
                    log("  VERDICT SUMMARY:")
                    log(f"    âœ“ Confirmed Vulnerable:   {vc.get('confirmed_vulnerable', 0)}")
                    log(f"    âœ“ Verified Safe:          {vc.get('verified_safe', 0)}")
                    log(f"    â—‹ Not Applicable:         {vc.get('not_applicable', 0)}")
                    log(f"    ? Unverified:             {vc.get('unverified', 0)}")
                log("")

            # --- Split cve_results: verified exploits vs CVE tests ---
            cve_results = data.get("cve_results", [])
            verified_exploits = [r for r in cve_results if r.get("finding_type") == "verified_exploit"]
            cve_only = [r for r in cve_results if r.get("finding_type") != "verified_exploit"]

            _VERDICT_ICONS = {
                "VULNERABLE_VERIFIED": "ðŸ”´ VULNERABLE (VERIFIED)",
                "NOT_VULNERABLE_VERIFIED": "ðŸŸ¢ NOT VULNERABLE (VERIFIED)",
                "NOT_APPLICABLE": "âšª NOT APPLICABLE",
                "UNVERIFIED": "ðŸŸ¡ UNVERIFIED",
            }
            bar = lambda pct: "â–ˆ" * (pct // 10) + "â–‘" * (10 - pct // 10)

            # --- Verified Exploits (shown first) ---
            if verified_exploits:
                log("=" * 60)
                log(f"  ðŸ”´ VERIFIED EXPLOITS ({len(verified_exploits)} confirmed)")
                log("=" * 60)
                for i, r in enumerate(verified_exploits, 1):
                    ev = r.get("evidence", {})
                    proof = ev.get("proof", "")
                    log("")
                    log(f"  [{i}] {r.get('title', r.get('cve_id', '?'))}")
                    log(f"      Target:      {r.get('target_url', '?')}")
                    log(f"      Verdict:     ðŸ”´ VULNERABLE (VERIFIED)")
                    log(f"      Severity:    {r.get('severity', '?')} (CVSS {r.get('cvss_score', 0.0)})")
                    log(f"      Proof:       {proof}")
                    log(f"      Confidence:  {r.get('confidence', 0.0):.0%}")
                    log(f"      Description: {r.get('description', 'N/A')}")
                    log(f"      Remediation: {r.get('remediation', 'N/A')}")
                    for k, v in ev.items():
                        if k not in ("proof", "verification_method"):
                            log(f"      Evidence[{k}]: {json.dumps(v) if isinstance(v, (dict, list)) else v}")
                log("")

            # --- Per-CVE Detailed Results ---
            if cve_only:
                log("=" * 60)
                log(f"  CVE TEST RESULTS ({len(cve_only)} tests)")
                log("=" * 60)
                for i, r in enumerate(cve_only, 1):
                    verdict = r.get("verdict", "UNVERIFIED")
                    status_label = _VERDICT_ICONS.get(verdict, verdict)
                    conf = r.get("confidence", 0.0)
                    log("")
                    log(f"  [{i}] {r.get('cve_id', '?')} vs {r.get('target_url', '?')}")
                    log(f"      Verdict:     {status_label}")
                    log(f"      Confidence:  {conf:.0%}")
                    log(f"      Severity:    {r.get('severity', '?')} (CVSS {r.get('cvss_score', 0.0)})")
                    log(f"      Test method: {r.get('test_method', '?')}")

                    # 3-bar metrics
                    app_s = r.get("applicability_score", 0)
                    cov_s = r.get("test_coverage_score", 0)
                    con_s = r.get("confidence_score", 0)
                    log(f"      Applicability:  [{bar(app_s)}] {app_s}%")
                    log(f"      Test Coverage:  [{bar(cov_s)}] {cov_s}%")
                    log(f"      Evidence Qual:  [{bar(con_s)}] {con_s}%")

                    vchain = r.get("verification_chain", "")
                    if vchain:
                        log(f"      Verification: {vchain}")

                    if verdict in ("NOT_APPLICABLE", "UNVERIFIED"):
                        ev = r.get("evidence", {})
                        reason = ev.get("reason", "")
                        if reason:
                            log(f"      Reason:      {reason}")
                    else:
                        log(f"      Description: {r.get('description', 'N/A')}")
                        log(f"      Remediation: {r.get('remediation', 'N/A')}")
                        evidence = r.get("evidence", {})
                        if evidence:
                            tests_run = evidence.get("tests_run", [])
                            if tests_run:
                                log(f"      Tests run:   {len(tests_run)} probes")
                                for t in tests_run[:5]:
                                    log(f"        - {t}")
                                if len(tests_run) > 5:
                                    log(f"        ... and {len(tests_run) - 5} more")
                            vuln_ind = evidence.get("vulnerability_indicator")
                            if vuln_ind:
                                log(f"      Indicator:   {vuln_ind}")
                            for k, v in evidence.items():
                                if k not in ("tests_run", "vulnerability_indicator", "reason"):
                                    log(f"      Evidence[{k}]: {json.dumps(v) if isinstance(v, (dict, list)) else v}")
                log("")

            # --- General Findings ---
            findings = data.get("findings", [])
            if findings:
                log("=" * 60)
                log(f"  GENERAL VULNERABILITY FINDINGS ({len(findings)} items)")
                log("=" * 60)
                for i, f in enumerate(findings, 1):
                    log(f"  [{i}] Type: {f.get('type', '?')}")
                    log(f"      CVE:      {f.get('cve_id', f.get('cve_ids', 'N/A'))}")
                    log(f"      Target:   {f.get('target', 'N/A')}")
                    log(f"      Severity: {f.get('severity', '?')}")
                    log(f"      Confidence: {f.get('confidence', 'N/A')}")
                    log(f"      Detail:   {f.get('description', 'N/A')}")
                    log("")

            # --- MITRE ATT&CK Techniques ---
            if meta:
                mitre = meta.get("mitre_techniques", [])
                if mitre:
                    log("=" * 60)
                    log(f"  MITRE ATT&CK TECHNIQUES ({len(mitre)} mapped)")
                    log("=" * 60)
                    for i, t in enumerate(mitre, 1):
                        log(f"  [{i}] {t['technique_id']} - {t['technique_name']}")
                        log(f"      Phase:        {t.get('phase', '?')}")
                        log(f"      Triggered by: {t.get('triggered_by', '?')}")
                        log(f"      Severity:     {t.get('severity', '?')}")
                        log("")

                # --- Attack Chains ---
                chains = meta.get("attack_chains", [])
                if chains:
                    log("=" * 60)
                    log(f"  ATTACK CHAINS ({len(chains)} paths)")
                    log("=" * 60)
                    for i, c in enumerate(chains, 1):
                        log(f"  [{i}] {c.get('entry_point', '?')}")
                        log(f"      Depth:      {c.get('depth', 0)} steps")
                        log(f"      Risk Level: {c.get('risk_level', '?').upper()}")
                        log(f"      Kill Chain:")
                        for j, s in enumerate(c.get("steps", []), 1):
                            log(f"        {j}. {s.get('phase', '?')} \u2192 {s.get('technique', '?')} ({s.get('name', '?')})")
                        log("")

                # --- Compliance Validation ---
                compliance = meta.get("compliance", {})
                if compliance:
                    log("=" * 60)
                    log(f"  COMPLIANCE VALIDATION ({len(compliance)} frameworks)")
                    log("=" * 60)
                    for fw, d in compliance.items():
                        icon = "\u2713 COMPLIANT" if d.get("status") == "compliant" else "\u2717 NON-COMPLIANT"
                        log(f"  {fw}: {icon} ({d.get('compliance_pct', 0)}%)")
                        log(f"      Passing: {d.get('passing', 0)}/{d.get('total_controls', 0)} controls")
                        violations = d.get("violations", [])
                        if violations:
                            log(f"      Violations:")
                            for v in violations[:5]:
                                log(f"        - {v.get('control', '?')}: {v.get('name', '?')}")
                                log(f"          Triggered by: {', '.join(v.get('triggered_by', []))}")
                        log("")

                # --- Risk Score ---
                risk = meta.get("risk_score", {})
                if risk:
                    log("=" * 60)
                    log(f"  RISK SCORE: {risk.get('score', 0)}/10 ({risk.get('level', '?').upper()})")
                    log("=" * 60)
                    log(f"  Overall Risk Level: {risk.get('level', '?').upper()}")
                    log(f"  Risk Score:         {risk.get('score', 0)}/{risk.get('max_score', 10)}")
                    log(f"  Contributing Factors:")
                    for fct in risk.get("factors", []):
                        log(f"    - {fct.get('factor', '?')}: +{fct.get('contribution', 0)} ({fct.get('detail', '')})")
                    log("")

                # --- Executive Summary ---
                summary = meta.get("executive_summary", {})
                if summary:
                    log("=" * 60)
                    log("  EXECUTIVE SUMMARY")
                    log("=" * 60)
                    log(f"  {summary.get('headline', 'N/A')}")
                    log("")
                    top_risks = summary.get("top_risks", [])
                    if top_risks:
                        log("  Top Risks:")
                        for r in top_risks:
                            log(f"    \u2022 {r}")
                        log("")
                    actions = summary.get("prioritized_actions", [])
                    if actions:
                        log("  Prioritized Actions:")
                        for a in actions:
                            log(f"    [{a.get('priority', '?')}] {a.get('action', '?')}")
                            detail = a.get("detail", "")
                            if detail:
                                log(f"        \u2192 {detail[:120]}")
                        log("")
                    surf = summary.get("attack_surface", {})
                    if surf:
                        log("  Attack Surface:")
                        log(f"    Total Findings:     {surf.get('total_findings', 0)}")
                        log(f"    Critical/High:      {surf.get('critical_high', 0)}")
                        log(f"    Exploitable CVEs:   {surf.get('exploitable_cves', 0)}")
                        log(f"    Attack Chains:      {surf.get('attack_chains', 0)}")
                        log(f"    MITRE Techniques:   {surf.get('mitre_techniques', 0)}")
                        log("")
                    comp_sum = summary.get("compliance_summary", {})
                    if comp_sum:
                        log("  Compliance Status:")
                        for fw, status in comp_sum.items():
                            icon = "\u2713" if status == "compliant" else "\u2717"
                            log(f"    {icon} {fw}: {status.upper()}")
                        log("")

                # --- PoC Commands ---
                poc_commands = meta.get("poc_commands", [])
                if poc_commands:
                    log("=" * 60)
                    log(f"  PROOF-OF-CONCEPT COMMANDS ({len(poc_commands)} generated)")
                    log("=" * 60)
                    for i, poc in enumerate(poc_commands, 1):
                        log(f"  [{i}] {poc.get('description', 'N/A')}")
                        if poc.get("cve_id"):
                            log(f"      CVE:     {poc.get('cve_id')}")
                        if poc.get("type"):
                            log(f"      Type:    {poc.get('type')}")
                        log(f"      Target:  {poc.get('target', 'N/A')}")
                        log(f"      Command:")
                        log(f"        {poc.get('curl_command', 'N/A')}")
                        log("")

                # --- False Positive Analysis ---
                fp_analysis = meta.get("false_positive_analysis", {})
                if fp_analysis:
                    log("=" * 60)
                    log("  FALSE POSITIVE ANALYSIS")
                    log("=" * 60)
                    log(f"  Estimated Accuracy: {fp_analysis.get('estimated_accuracy', 0)}%")
                    log(f"  Total Flagged:      {fp_analysis.get('total_flagged', 0)}")
                    log(f"  Total Verified:     {fp_analysis.get('total_verified', 0)}")
                    log("")

                    fp_cves = fp_analysis.get("likely_false_positive_cves", [])
                    if fp_cves:
                        log(f"  Likely False Positive CVEs ({len(fp_cves)}):")
                        for fp in fp_cves:
                            log(f"    \u26a0 {fp.get('cve_id')} on {fp.get('target')}")
                            log(f"      Reason: {fp.get('reason')}")
                        log("")

                    verified_cves = fp_analysis.get("verified_cves", [])
                    if verified_cves:
                        log(f"  Verified CVEs ({len(verified_cves)}):")
                        for v in verified_cves:
                            conf = v.get('confidence', 0)
                            log(f"    \u2713 {v.get('cve_id')} on {v.get('target')} (confidence: {conf:.0%})")
                        log("")

                    fp_findings = fp_analysis.get("likely_false_positive_findings", [])
                    if fp_findings:
                        log(f"  Likely False Positive Findings ({len(fp_findings)}):")
                        for fp in fp_findings:
                            log(f"    \u26a0 {fp}")
                        log("")

                    verified_findings = fp_analysis.get("verified_findings", [])
                    if verified_findings:
                        log(f"  Verified Findings ({len(verified_findings)}):")
                        for v in verified_findings:
                            log(f"    \u2713 {v}")
                        log("")

            if not cve_results and not findings:
                log("(No detailed results returned - check backend)")
                log("")
                log("--- Raw Response JSON ---")
                formatted = json.dumps(data, indent=2)
                for line in formatted.split("\n"):
                    log(line)
                log("--- End ---")
        else:
            log(f"Error: HTTP {resp.status_code}")
            log(f"   Body: {resp.text[:500]}")

    except requests.exceptions.Timeout:
        log("Request timed out after 300 seconds")
    except Exception as e:
        log(f"Exception: {e}")

    log("")
    log("Micro pentest run complete.")
    log(f"Full results saved to: {OUTPUT_FILE}")


if __name__ == "__main__":
    main()

