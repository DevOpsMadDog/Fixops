#!/usr/bin/env python3
"""Generate a professional HTML penetration test report from ALdeci micropentest results."""

import json
import os
import sys
import time
import webbrowser
from datetime import datetime, timezone
from pathlib import Path

import requests

BASE = "http://localhost:8000"
HEADERS = {"X-API-Key": "test-token-123", "Content-Type": "application/json"}
OUTPUT_DIR = Path(".fixops_data")
REPORT_FILE = OUTPUT_DIR / "pentest_report.html"


def run_pentest() -> dict:
    """Run micropentest and return JSON response."""
    cves = [
        "CVE-2021-44228", "CVE-2023-44487", "CVE-2024-3094", "CVE-2022-22965",
        "CVE-2023-4966", "CVE-2014-0160", "CVE-2017-5638", "CVE-2023-27997",
        "CVE-2023-20198", "CVE-2024-21887", "CVE-2023-0669", "CVE-2023-27350",
        "CVE-2024-1709",
    ]
    targets = [
        "https://httpbin.org", "https://example.com",
        "https://www.google.com", "https://github.com",
    ]
    payload = {
        "cve_ids": cves,
        "target_urls": targets,
        "context": {"scan_type": "advanced", "environment": "production"},
    }
    print("[*] Running micropentest (this may take ~2-3 minutes)...")
    t0 = time.time()
    resp = requests.post(f"{BASE}/api/v1/micro-pentest/run", json=payload, headers=HEADERS, timeout=600)
    elapsed = time.time() - t0
    print(f"[+] Completed in {elapsed:.1f}s (HTTP {resp.status_code})")
    resp.raise_for_status()
    # Cache results
    cache = OUTPUT_DIR / "pentest_report_data.json"
    cache.write_text(json.dumps(resp.json(), indent=2))
    return resp.json()


def load_cached() -> dict | None:
    """Load cached results if available."""
    cache = OUTPUT_DIR / "pentest_report_data.json"
    if cache.exists():
        return json.loads(cache.read_text())
    return None


# ‚îÄ‚îÄ‚îÄ Severity helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
SEV_COLORS = {
    "critical": "#dc2626", "high": "#ea580c", "medium": "#d97706",
    "low": "#2563eb", "info": "#6b7280", "unknown": "#9ca3af",
}
SEV_ORDER = ["critical", "high", "medium", "low", "info", "unknown"]


def sev_badge(sev: str) -> str:
    c = SEV_COLORS.get(sev, "#9ca3af")
    return f'<span class="badge" style="background:{c}">{sev.upper()}</span>'


def pct_bar(pct: float, color: str = "#22c55e") -> str:
    bg = "#dc2626" if pct < 60 else "#d97706" if pct < 85 else "#22c55e"
    return (
        f'<div class="pct-bar"><div class="pct-fill" style="width:{pct}%;background:{bg}">'
        f'{pct:.1f}%</div></div>'
    )


def risk_gauge(score: float, level: str) -> str:
    angle = score / 10 * 180
    c = SEV_COLORS.get(level, "#d97706")
    return f"""<div class="gauge-wrap">
      <div class="gauge"><div class="gauge-fill" style="transform:rotate({angle}deg);border-color:{c}"></div>
      <div class="gauge-cover"><span class="gauge-val">{score}</span><span class="gauge-max">/10</span>
      <div class="gauge-label">{level.upper()}</div></div></div></div>"""


# ‚îÄ‚îÄ‚îÄ HTML skeleton ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def build_html(data: dict) -> str:
    meta = data.get("scan_metadata") or {}
    cve_results = data.get("cve_results") or []
    findings = data.get("findings") or []
    summary = meta.get("executive_summary") or {}
    risk = meta.get("risk_score") or {}
    compliance = meta.get("compliance") or {}
    mitre = meta.get("mitre_techniques") or []
    chains = meta.get("attack_chains") or []
    fp = meta.get("false_positive_analysis") or {}
    poc = meta.get("poc_commands") or []
    now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    # Compute severity distribution
    sev_dist = {}
    for f in findings:
        s = f.get("severity", "unknown")
        sev_dist[s] = sev_dist.get(s, 0) + 1

    # Per-target summary
    target_map: dict[str, list] = {}
    for f in findings:
        t = f.get("target", "unknown")
        target_map.setdefault(t, []).append(f)

    ai = meta.get("ai_analysis") or {}

    # Split cve_results: verified exploits (promoted findings) vs CVE assessments
    verified_exploits = [r for r in cve_results if r.get("finding_type") == "verified_exploit"]
    cve_only = [r for r in cve_results if r.get("finding_type") != "verified_exploit"]

    # Build sections ‚Äî structured flow: environment ‚Üí scope ‚Üí walkthrough ‚Üí findings ‚Üí analysis
    parts = [_css(), _cover(data, now, meta), _exec_summary(summary, risk, meta)]
    # Section 1-2: Environment & Scope (understand what was tested)
    parts.append(_test_environment_section(data, meta))
    parts.append(_scope_section(data, meta))
    # Section 3: Step-by-step execution walkthrough (19 scan phases)
    parts.append(_execution_walkthrough_section(data, meta))
    # Section 4: Detailed reproduction guide for verified exploits
    parts.append(_reproduction_guide_section(data, meta))
    # Section 5: CVE verification pipeline methodology
    parts.append(_cve_test_methodology_section(data, meta))
    # Section 6: All findings with evidence & manual repro
    parts.append(_findings_detail_section(data))
    # Original sections (now deeper in the report)
    parts.append(_verified_exploits_section(verified_exploits))  # Summary of verified exploits
    parts.append(_poc_section(poc))  # Quick PoC commands
    parts.append(_severity_table(sev_dist, findings))
    parts.append(_target_breakdown(target_map))
    parts.append(_cve_matrix(cve_only))  # Only CVE-specific results, not promoted exploits
    parts.append(_mitre_section(mitre))
    parts.append(_chains_section(chains))
    parts.append(_compliance_section(compliance))
    parts.append(_fp_section(fp))
    parts.append(_ai_transparency_section(ai, meta))
    # Advanced sections: Architecture, Source Code, Threat Scenarios, Attack Surface
    parts.append(_architecture_intelligence_section(data, meta))
    parts.append(_source_code_audit_trail_section(data, meta))
    parts.append(_threat_scenario_matrix_section(data, meta))
    parts.append(_attack_surface_analysis_section(data, meta))
    parts.append(_footer(now, meta))

    return "\n".join(parts)


# ‚îÄ‚îÄ‚îÄ Section generators ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def _css():
    return """<!DOCTYPE html><html lang="en"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ALdeci Penetration Test Report</title>
<style>
:root{--bg:#0f172a;--card:#1e293b;--border:#334155;--txt:#e2e8f0;--dim:#94a3b8;--accent:#3b82f6}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--txt);line-height:1.6}
.container{max-width:1100px;margin:0 auto;padding:20px 30px}
h1{font-size:2.2rem;font-weight:700;margin-bottom:4px}
h2{font-size:1.5rem;font-weight:600;margin:40px 0 16px;padding-bottom:8px;border-bottom:2px solid var(--accent);color:#fff}
h3{font-size:1.1rem;font-weight:600;margin:20px 0 8px;color:#cbd5e1}
.card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:24px;margin-bottom:20px}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
.grid4{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:12px}
.stat{text-align:center;padding:16px;background:var(--bg);border-radius:10px}
.stat .num{font-size:2rem;font-weight:700;color:#fff}
.stat .lbl{font-size:.75rem;text-transform:uppercase;color:var(--dim);letter-spacing:.05em}
.badge{display:inline-block;padding:2px 10px;border-radius:20px;font-size:.7rem;font-weight:700;color:#fff;text-transform:uppercase;letter-spacing:.04em}
table{width:100%;border-collapse:collapse;font-size:.85rem}
th{text-align:left;padding:10px 12px;background:var(--bg);color:var(--dim);font-weight:600;text-transform:uppercase;font-size:.7rem;letter-spacing:.05em}
td{padding:10px 12px;border-bottom:1px solid var(--border)}
tr:hover td{background:rgba(59,130,246,.04)}
.pct-bar{background:var(--bg);border-radius:6px;height:22px;overflow:hidden;position:relative}
.pct-fill{height:100%;border-radius:6px;display:flex;align-items:center;justify-content:flex-end;padding-right:8px;font-size:.7rem;font-weight:700;color:#fff;min-width:40px;transition:width .4s}
.gauge-wrap{display:flex;justify-content:center;padding:10px 0}
.gauge{width:180px;height:90px;position:relative;overflow:hidden}
.gauge::before{content:'';display:block;width:180px;height:90px;border-radius:90px 90px 0 0;background:var(--bg);border:8px solid var(--border);border-bottom:none}
.gauge-fill{position:absolute;bottom:0;left:0;width:180px;height:90px;border-radius:90px 90px 0 0;border:8px solid;border-bottom:none;transform-origin:center bottom;transform:rotate(0deg);transition:transform .6s}
.gauge-cover{position:absolute;bottom:0;left:50%;transform:translateX(-50%);text-align:center;line-height:1.2}
.gauge-val{font-size:2rem;font-weight:800;color:#fff}
.gauge-max{font-size:.8rem;color:var(--dim)}
.gauge-label{font-size:.7rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;margin-top:2px}
code{background:var(--bg);padding:2px 6px;border-radius:4px;font-size:.82rem;color:#7dd3fc;font-family:'SF Mono',Consolas,monospace}
pre{background:#0c1222;padding:14px 18px;border-radius:8px;overflow-x:auto;font-size:.78rem;line-height:1.5;color:#a5f3fc;font-family:'SF Mono',Consolas,monospace;border:1px solid var(--border)}
.tag{display:inline-block;background:var(--bg);border:1px solid var(--border);padding:2px 8px;border-radius:6px;font-size:.72rem;margin:2px}
.cover{text-align:center;padding:60px 20px 40px;border-bottom:2px solid var(--accent)}
.cover .logo{font-size:3rem;font-weight:800;background:linear-gradient(135deg,#3b82f6,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:-.03em}
.cover .sub{color:var(--dim);font-size:1rem;margin-top:6px}
.kpi-row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:20px}
.kpi{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:14px 22px;text-align:center;min-width:130px}
.kpi .v{font-size:1.6rem;font-weight:700}
.kpi .k{font-size:.68rem;color:var(--dim);text-transform:uppercase;letter-spacing:.04em}
.chain-step{display:flex;align-items:center;gap:8px;margin:4px 0}
.chain-arrow{color:var(--accent);font-weight:700}
.finding-detail{margin:8px 0;padding:10px 14px;background:var(--bg);border-left:3px solid var(--accent);border-radius:0 8px 8px 0}
@media print{body{background:#fff;color:#1e293b}.card{border-color:#e2e8f0;break-inside:avoid}
  .cover .logo{color:#3b82f6;-webkit-text-fill-color:#3b82f6}h2{color:#1e293b}
  th{background:#f1f5f9}td{border-color:#e2e8f0}pre,code{background:#f8fafc;color:#0f172a}.badge{print-color-adjust:exact;-webkit-print-color-adjust:exact}}
</style></head><body><div class="container">"""


def _cover(data, now, meta):
    vc = meta.get("verdict_counts") or {}
    return f"""<div class="cover"><div class="logo">ALdeci</div>
<div class="sub">Penetration Test Report</div>
<p style="color:var(--dim);margin-top:8px;font-size:.85rem">Generated {now}</p>
<div class="kpi-row">
<div class="kpi"><div class="v" style="color:#dc2626">{vc.get('confirmed_vulnerable',0)}</div><div class="k">Confirmed Vulnerable</div></div>
<div class="kpi"><div class="v" style="color:#22c55e">{vc.get('verified_safe',0)}</div><div class="k">Verified Safe</div></div>
<div class="kpi"><div class="v" style="color:#94a3b8">{vc.get('not_applicable',0)}</div><div class="k">Not Applicable</div></div>
<div class="kpi"><div class="v" style="color:#eab308">{vc.get('unverified',0)}</div><div class="k">Unverified</div></div>
<div class="kpi"><div class="v">{meta.get('total_findings',0)}</div><div class="k">Total Findings</div></div>
<div class="kpi"><div class="v">{meta.get('total_cve_tests',0)}</div><div class="k">CVE Tests</div></div>
</div></div>"""


def _exec_summary(summary, risk, meta):
    headline = summary.get("headline", "N/A")
    gauge = risk_gauge(risk.get("score", 0), risk.get("level", "medium"))
    factors = "".join(
        f'<div style="margin:4px 0"><code>{f.get("factor","")}</code> +{f.get("contribution",0)}'
        f' <span style="color:var(--dim);font-size:.8rem">({f.get("detail","")})</span></div>'
        for f in risk.get("factors", [])
    )
    risks_li = "".join(f"<li style='margin:4px 0'>{r}</li>" for r in summary.get("top_risks", []))
    surf = summary.get("attack_surface", {})
    actions_rows = ""
    for a in summary.get("prioritized_actions", []):
        p = a.get("priority", "?")
        c = "#dc2626" if p == "P0" else "#ea580c" if p == "P1" else "#2563eb"
        actions_rows += (f'<tr><td><span class="badge" style="background:{c}">{p}</span></td>'
                         f'<td>{a.get("action","")}</td>'
                         f'<td style="color:var(--dim);font-size:.8rem">{a.get("detail","")[:120]}</td></tr>')
    actions_tbl = (f'<div class="card"><h3>Prioritized Actions</h3><table><thead><tr><th>Priority</th>'
                   f'<th>Action</th><th>Detail</th></tr></thead><tbody>{actions_rows}</tbody></table></div>'
                   if actions_rows else "")
    return f"""<h2>Executive Summary</h2>
<div class="card"><p style="font-size:1.1rem;font-weight:600;margin-bottom:16px">{headline}</p>
<div class="grid2"><div>{gauge}</div><div><h3>Risk Factors</h3>{factors}</div></div></div>
<div class="grid2"><div class="card"><h3>Top Risks</h3><ul style="padding-left:20px">{risks_li}</ul></div>
<div class="card"><h3>Attack Surface</h3><div class="grid2">
<div class="stat"><div class="num">{surf.get("total_findings",0)}</div><div class="lbl">Findings</div></div>
<div class="stat"><div class="num">{surf.get("critical_high",0)}</div><div class="lbl">Critical/High</div></div>
<div class="stat"><div class="num">{surf.get("exploitable_cves",0)}</div><div class="lbl">Exploitable CVEs</div></div>
<div class="stat"><div class="num">{surf.get("attack_chains",0)}</div><div class="lbl">Attack Chains</div></div>
</div></div></div>{actions_tbl}"""


def _verified_exploits_section(verified_exploits):
    """Verified exploits section ‚Äî the actionable heart of the report."""
    if not verified_exploits:
        return ""
    rows = ""
    for r in verified_exploits:
        ev = r.get("evidence", {})
        proof = ev.get("proof", "")
        title = r.get("title", r.get("cve_id", "?"))
        target = r.get("target_url", "?")
        sev = r.get("severity", "medium")
        cwe = r.get("cwe_id", "")
        # Build evidence detail HTML
        ev_items = ""
        for k, v in ev.items():
            if k in ("proof", "verification_method"):
                continue
            ev_items += f'<div style="font-size:.78rem;margin:2px 0"><code>{k}</code>: <strong>{v}</strong></div>'
        rows += (f'<div class="finding-detail" style="border-left-color:#dc2626">'
                 f'<div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">'
                 f'{sev_badge(sev)} <strong>{title}</strong>'
                 f'{f" <code>{cwe}</code>" if cwe else ""}</div>'
                 f'<div style="font-size:.82rem;margin-bottom:4px"><strong>Target:</strong> <code>{target}</code></div>'
                 f'<div style="font-size:.82rem;margin-bottom:6px"><strong>Proof:</strong> {proof}</div>'
                 f'<div style="font-size:.82rem;color:var(--dim)">{r.get("description","")}</div>'
                 f'<details style="margin-top:6px"><summary style="cursor:pointer;font-size:.78rem;color:var(--accent)">Evidence Details</summary>'
                 f'<div style="margin-top:4px;padding:8px;background:var(--bg);border-radius:6px">{ev_items}</div></details>'
                 f'<div style="margin-top:6px;font-size:.78rem;color:var(--dim)"><strong>Remediation:</strong> {r.get("remediation","")}</div>'
                 f'</div>')
    count = len(verified_exploits)
    return (f'<h2 style="color:#dc2626">üî¥ Verified Exploits ({count})</h2>'
            f'<div class="card" style="border-color:#dc2626">'
            f'<p style="font-size:.85rem;margin-bottom:12px">These vulnerabilities were <strong>confirmed exploitable</strong> '
            f'with real HTTP requests and differential analysis. Each includes reproduction proof.</p>'
            f'{rows}</div>')


def _severity_table(sev_dist, findings):
    rows = ""
    for s in SEV_ORDER:
        cnt = sev_dist.get(s, 0)
        if cnt:
            pct = cnt / len(findings) * 100 if findings else 0
            rows += f"<tr><td>{sev_badge(s)}</td><td>{cnt}</td><td>{pct_bar(pct)}</td></tr>"
    return f"""<h2>Severity Distribution</h2><div class="card">
<table><thead><tr><th>Severity</th><th>Count</th><th>Distribution</th></tr></thead>
<tbody>{rows}</tbody></table></div>"""


def _target_breakdown(target_map):
    sections = ""
    for target, tfindings in sorted(target_map.items()):
        sc = {}
        for f in tfindings:
            s = f.get("severity", "unknown"); sc[s] = sc.get(s, 0) + 1
        badges = " ".join(f'{sev_badge(s)}&nbsp;√ó{c}' for s, c in sorted(sc.items(), key=lambda x: SEV_ORDER.index(x[0]) if x[0] in SEV_ORDER else 99))
        frows = ""
        for f in tfindings:
            frows += (f'<div class="finding-detail"><strong>{f.get("title", f.get("type", "?"))}</strong> '
                      f'{sev_badge(f.get("severity","unknown"))}'
                      f'<div style="color:var(--dim);font-size:.82rem;margin-top:4px">{f.get("description","")[:200]}</div></div>')
        sections += f'<div class="card"><h3><code>{target}</code> ‚Äî {len(tfindings)} findings</h3><div style="margin:8px 0">{badges}</div>{frows}</div>'
    return f"<h2>Findings by Target</h2>{sections}"


def _cve_matrix(cve_results):
    if not cve_results:
        return "<h2>CVE Assessment Matrix</h2><div class='card'><p>No CVE tests executed.</p></div>"
    _VC = {"VULNERABLE_VERIFIED": ("#dc2626", "üî¥ VULNERABLE"), "NOT_VULNERABLE_VERIFIED": ("#22c55e", "üü¢ NOT VULNERABLE"),
           "NOT_APPLICABLE": ("#94a3b8", "‚ö™ NOT APPLICABLE"), "UNVERIFIED": ("#eab308", "üü° UNVERIFIED")}
    # Count by verdict for the collapsible summary
    vc_counts = {}
    for r in cve_results:
        v = r.get("verdict", "UNVERIFIED")
        vc_counts[v] = vc_counts.get(v, 0) + 1
    na_count = vc_counts.get("NOT_APPLICABLE", 0)
    unv_count = vc_counts.get("UNVERIFIED", 0)
    rows = ""
    for r in cve_results:
        v = r.get("verdict", "UNVERIFIED"); vc, vl = _VC.get(v, ("#94a3b8", v))
        app_s, cov_s, con_s = r.get("applicability_score", 0), r.get("test_coverage_score", 0), r.get("confidence_score", 0)
        if v == "NOT_APPLICABLE":
            ev = r.get("evidence", {}); reason = ev.get("reason", "")
            detail = f'<div style="font-size:.78rem;color:var(--dim)">{reason if reason else "Product not detected on target"}</div>'
        elif v == "UNVERIFIED":
            ev = r.get("evidence", {})
            reason = ev.get("reason", "")
            method = r.get("test_method", "")
            detail = f'<div style="font-size:.78rem;color:var(--dim)">{reason or "No exploit test available"}'
            if method:
                detail += f' <span style="font-size:.72rem">(method: {method})</span>'
            detail += '</div>'
        else:
            detail = f'<div style="font-size:.78rem;color:var(--dim)">{r.get("description","")[:120]}</div>'
        rows += (f'<tr><td><code>{r.get("cve_id","?")}</code></td>'
                 f'<td style="font-size:.78rem;max-width:160px;overflow:hidden;text-overflow:ellipsis">{r.get("target_url","?")}</td>'
                 f'<td><span class="badge" style="background:{vc}">{vl}</span></td>'
                 f'<td>{sev_badge(r.get("severity","unknown"))} <span style="color:var(--dim);font-size:.78rem">CVSS {r.get("cvss_score",0)}</span></td>'
                 f'<td style="min-width:110px"><div style="font-size:.7rem;color:var(--dim)">Applicability</div>{pct_bar(app_s)}'
                 f'<div style="font-size:.7rem;color:var(--dim);margin-top:3px">Test Coverage</div>{pct_bar(cov_s)}'
                 f'<div style="font-size:.7rem;color:var(--dim);margin-top:3px">Evidence Qual</div>{pct_bar(con_s)}</td>'
                 f'<td>{detail}</td></tr>')
    # Collapsible if mostly NOT_APPLICABLE ‚Äî don't bury the user in irrelevant rows
    collapse = na_count + unv_count > 10
    summary_txt = f'{na_count} not applicable, {unv_count} unverified' if collapse else ''
    inner = (f'<table><thead><tr><th>CVE</th><th>Target</th><th>Verdict</th><th>Severity</th><th>Metrics</th><th>Details</th></tr></thead>'
             f'<tbody>{rows}</tbody></table>')
    if collapse:
        inner = (f'<details><summary style="cursor:pointer;font-size:.85rem;color:var(--accent);margin-bottom:8px">'
                 f'Show {len(cve_results)} CVE tests ({summary_txt})</summary>{inner}</details>')
    return f'<h2>CVE Assessment Matrix</h2><div class="card" style="overflow-x:auto">{inner}</div>'


def _mitre_section(mitre):
    if not mitre:
        return ""
    rows = "".join(
        f'<tr><td><code>{t.get("technique_id","")}</code></td><td>{t.get("technique_name","")}</td>'
        f'<td>{t.get("phase","")}</td><td>{sev_badge(t.get("severity","info"))}</td>'
        f'<td style="color:var(--dim);font-size:.82rem">{t.get("triggered_by","")}</td></tr>'
        for t in mitre)
    return (f'<h2>MITRE ATT&CK Mapping</h2><div class="card"><table><thead><tr><th>Technique ID</th><th>Name</th>'
            f'<th>Kill-Chain Phase</th><th>Severity</th><th>Triggered By</th></tr></thead><tbody>{rows}</tbody></table></div>')


def _chains_section(chains):
    if not chains:
        return ""
    items = ""
    for c in chains:
        steps_html = ""
        for i, s in enumerate(c.get("steps", [])):
            arrow = '<span class="chain-arrow">‚Üí</span> ' if i > 0 else ""
            steps_html += f'<div class="chain-step">{arrow}<span class="tag">{s.get("phase","")}</span> <span>{s.get("technique","")} ({s.get("name","")})</span></div>'
        bc = SEV_COLORS.get(c.get("risk_level", "medium"), "#d97706")
        items += (f'<div class="card"><h3>{c.get("entry_point","?")} ‚Äî {c.get("depth",0)} steps '
                  f'<span class="badge" style="background:{bc}">{c.get("risk_level","?").upper()}</span></h3>{steps_html}</div>')
    return f"<h2>Attack Chains</h2>{items}"


def _compliance_section(compliance):
    if not compliance:
        return ""
    cards = ""
    for fw, d in compliance.items():
        st = d.get("status", "unknown"); col = "#22c55e" if st == "compliant" else "#dc2626"
        pct = d.get("compliance_pct", 0)
        viols = "".join(f'<div style="margin:4px 0;font-size:.82rem">‚Ä¢ <code>{v.get("control","")}</code> {v.get("name","")}</div>' for v in d.get("violations", [])[:5])
        cards += (f'<div class="card"><h3>{fw} <span class="badge" style="background:{col}">{st.upper()}</span></h3>'
                  f'{pct_bar(pct)}<div style="margin-top:8px;font-size:.82rem;color:var(--dim)">Passing: {d.get("passing",0)}/{d.get("total_controls",0)} controls</div>{viols}</div>')
    return f'<h2>Compliance Validation</h2><div class="grid2">{cards}</div>'


def _fp_section(fp):
    if not fp:
        return ""
    acc = fp.get("estimated_accuracy", 0); tf = fp.get("total_flagged", 0); tv = fp.get("total_verified", 0)
    fp_rows = "".join(f'<tr><td><code>{f.get("cve_id","")}</code></td><td>{f.get("target","")}</td><td style="color:var(--dim)">{f.get("reason","")}</td></tr>' for f in fp.get("likely_false_positive_cves", []))
    tbl = f'<table style="margin-top:16px"><thead><tr><th>CVE</th><th>Target</th><th>Reason</th></tr></thead><tbody>{fp_rows}</tbody></table>' if fp_rows else ""
    return (f'<h2>False Positive Analysis</h2><div class="card"><div class="grid3">'
            f'<div class="stat"><div class="num">{acc}%</div><div class="lbl">Estimated Accuracy</div></div>'
            f'<div class="stat"><div class="num">{tf}</div><div class="lbl">Total Flagged</div></div>'
            f'<div class="stat"><div class="num">{tv}</div><div class="lbl">Verified Findings</div></div></div>{tbl}</div>')


def _poc_section(poc):
    if not poc:
        return ""
    items = ""
    for p in poc:
        cve_tag = f' <code>{p.get("cve_id","")}</code>' if p.get("cve_id") else ""
        poc_type = p.get("type", "")
        type_tag = f' <span class="tag">{poc_type}</span>' if poc_type else ""
        items += (f'<div class="finding-detail"><strong>{p.get("description","")}</strong>{cve_tag}{type_tag}'
                  f'<div style="color:var(--dim);font-size:.8rem;margin:4px 0">Target: {p.get("target","?")}</div>'
                  f'<pre>{p.get("curl_command","")}</pre></div>')
    return (f'<h2>üîß Proof-of-Concept Commands ({len(poc)})</h2>'
            f'<div class="card"><p style="font-size:.85rem;margin-bottom:12px;color:var(--dim)">'
            f'Copy-paste these commands to reproduce each finding.</p>{items}</div>')


def _ai_transparency_section(ai: dict, meta: dict) -> str:
    """Full AI transparency disclosure section."""
    ai_enabled = ai.get("ai_enabled", False)
    if not ai_enabled and not ai.get("providers_available"):
        # No AI info at all ‚Äî show a short notice
        return (
            '<h2>AI Engine Disclosure</h2><div class="card">'
            '<p style="color:var(--dim)">AI analysis layer was <strong>not active</strong> for this scan. '
            'The deterministic 4-stage verification pipeline produced all results. '
            'To enable AI-powered multi-LLM consensus, configure API keys for OpenAI, Anthropic, and/or Google Gemini.</p></div>'
        )

    providers = ai.get("providers_available", {})
    role_map = {"openai": "GPT-4 (Team Lead)", "anthropic": "Claude (Developer)", "gemini": "Gemini (Architect)"}
    prov_rows = "".join(
        f'<tr><td><strong>{n.title()}</strong></td>'
        f'<td>{"‚úÖ Configured" if v else "‚ùå Not configured"}</td>'
        f'<td>{role_map.get(n, "‚Äî")}</td></tr>'
        for n, v in providers.items()
    )

    consensus_cfg = ai.get("consensus_config", {})
    weights = consensus_cfg.get("weights", {})
    threshold = consensus_cfg.get("threshold", "‚Äî")

    # AI risk assessments table
    assessments = ai.get("ai_risk_assessments", [])
    assess_rows = ""
    for a in assessments[:10]:
        assess_rows += (
            f'<tr><td><code>{a.get("cve_id","")}</code></td>'
            f'<td>{a.get("target","")}</td>'
            f'<td>{a.get("consensus_action","‚Äî")}</td>'
            f'<td>{a.get("consensus_confidence",0):.1%}</td>'
            f'<td style="font-size:.78rem">{a.get("consensus_reasoning","")[:120]}</td></tr>'
        )

    # Exploit strategies
    exploits = ai.get("ai_enhanced_findings", [])
    exploit_rows = ""
    for e in exploits[:5]:
        exploit_rows += (
            f'<tr><td><code>{e.get("cve_id","")}</code></td>'
            f'<td>{e.get("exploit_type","")}</td>'
            f'<td>{e.get("complexity","")}</td>'
            f'<td>{e.get("success_probability",0):.0%}</td>'
            f'<td>{", ".join(e.get("evasion_techniques",[])[:3]) or "‚Äî"}</td></tr>'
        )

    status_color = "#22c55e" if ai_enabled else "#eab308"
    status_label = "ACTIVE" if ai_enabled else "DEGRADED"

    html = f'''<h2>AI Engine Disclosure</h2><div class="card">
<div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
<span class="badge" style="background:{status_color};font-size:.85rem;padding:6px 14px">{status_label}</span>
<span style="color:var(--dim);font-size:.85rem">PentAGI Multi-AI Consensus Engine</span>
</div>

<div class="grid2">
<div>
<h3>Architecture</h3>
<p style="font-size:.85rem">ALdeci is built on <strong>PentAGI</strong>, a multi-AI orchestration framework that coordinates
3 LLM providers in parallel for consensus-based security decisions. Each provider plays a specialized role:</p>
<table style="margin-top:8px">
<tr style="background:var(--bg)"><th>Provider</th><th>Status</th><th>Role</th></tr>
{prov_rows}
</table>
</div>
<div>
<h3>Consensus Configuration</h3>
<table>
<tr><td><strong>Threshold</strong></td><td>{threshold}</td></tr>
<tr><td><strong>Architect weight</strong></td><td>{weights.get("architect","‚Äî")}</td></tr>
<tr><td><strong>Developer weight</strong></td><td>{weights.get("developer","‚Äî")}</td></tr>
<tr><td><strong>Lead weight</strong></td><td>{weights.get("lead","‚Äî")}</td></tr>
<tr><td><strong>Timeout</strong></td><td>{consensus_cfg.get("timeout_seconds","‚Äî")}s per call</td></tr>
<tr><td><strong>Max retries</strong></td><td>{consensus_cfg.get("max_retries","‚Äî")}</td></tr>
</table>
<h3 style="margin-top:12px">Statistics</h3>
<table>
<tr><td>Consensus decisions</td><td><strong>{ai.get("consensus_decisions",0)}</strong></td></tr>
<tr><td>Exploit strategies</td><td><strong>{ai.get("exploit_strategies_generated",0)}</strong></td></tr>
<tr><td>Total LLM calls</td><td>{ai.get("total_llm_calls",0)}</td></tr>
<tr><td>Successful calls</td><td>{ai.get("successful_llm_calls",0)}</td></tr>
<tr><td>Fallback calls</td><td>{ai.get("fallback_llm_calls",0)}</td></tr>
<tr><td>AI duration</td><td>{ai.get("duration_seconds",0):.1f}s</td></tr>
</table>
</div>
</div>'''

    if assess_rows:
        html += f'''
<h3 style="margin-top:20px">AI Risk Assessments (Multi-LLM Consensus)</h3>
<div style="overflow-x:auto"><table>
<tr style="background:var(--bg)"><th>CVE</th><th>Target</th><th>Action</th><th>Confidence</th><th>Reasoning</th></tr>
{assess_rows}</table></div>'''

    if exploit_rows:
        html += f'''
<h3 style="margin-top:20px">AI-Generated Exploit Strategies</h3>
<div style="overflow-x:auto"><table>
<tr style="background:var(--bg)"><th>CVE</th><th>Type</th><th>Complexity</th><th>Success Prob.</th><th>Evasion Techniques</th></tr>
{exploit_rows}</table></div>'''

    html += '</div>'
    return html


def _test_environment_section(data: dict, meta: dict) -> str:
    """Test environment, tools, and prerequisites for reproduction."""
    targets = data.get("target_urls", [])
    cves = data.get("cve_ids", [])
    ai = meta.get("ai_analysis", {})
    providers = ai.get("providers_available", {})

    prov_rows = ""
    for name, available in providers.items():
        role = {"openai": "GPT-4 ‚Äî Team Lead / Strategy", "anthropic": "Claude ‚Äî Developer / Exploitability",
                "gemini": "Gemini ‚Äî Architect / Attack Surface"}.get(name, "‚Äî")
        status = "‚úÖ Configured" if available else "‚ùå Not configured"
        prov_rows += f"<tr><td><strong>{name.title()}</strong></td><td>{status}</td><td>{role}</td></tr>"

    return f'''<h2>üìã 1. Test Environment &amp; Prerequisites</h2>
<div class="card">
<p style="font-size:.9rem;margin-bottom:16px">This section describes exactly what tools and environment were used so you can <strong>reproduce every test</strong> on your own machine.</p>

<div class="grid2">
<div>
<h3>Engine &amp; Runtime</h3>
<table>
<tr><td><strong>Engine</strong></td><td><code>{meta.get("engine", "aldeci_pentagi_ai_v1")}</code></td></tr>
<tr><td><strong>Runtime</strong></td><td>Python 3.14+ with <code>asyncio</code></td></tr>
<tr><td><strong>HTTP Client</strong></td><td><code>httpx</code> (async, follows redirects, TLS verification)</td></tr>
<tr><td><strong>Scanner</strong></td><td>ALdeci RealVulnerabilityScanner ‚Äî 19 scan modules</td></tr>
<tr><td><strong>CVE Tester</strong></td><td>ALdeci CVETestRegistry ‚Äî decorator-based CVE-specific tests</td></tr>
<tr><td><strong>AI Layer</strong></td><td>{"PentAGI Multi-AI Consensus (active)" if meta.get("ai_powered") else "Disabled"}</td></tr>
<tr><td><strong>Scan Duration</strong></td><td>{ai.get("duration_seconds", 0):.0f}s (AI) + scanner time</td></tr>
</table>
</div>
<div>
<h3>How to Reproduce (Manual)</h3>
<p style="font-size:.85rem">You only need <code>curl</code> (pre-installed on macOS/Linux) to reproduce verified exploits. For the full scan:</p>
<pre style="font-size:.78rem">
# 1. Install Python 3.14+ and httpx
pip install httpx

# 2. For each PoC command below, copy-paste into terminal
# 3. Compare output with "Expected Result" column

# Or run the full ALdeci scan:
python tools/run_micropentest.py
</pre>
</div>
</div>

{"<h3>AI Providers (for AI-enhanced scanning)</h3><table><tr><th>Provider</th><th>Status</th><th>Role</th></tr>" + prov_rows + "</table>" if prov_rows else ""}

<h3 style="margin-top:16px">Key Dependencies for Manual Reproduction</h3>
<div class="grid3">
<div class="stat"><div class="num" style="font-size:1.2rem">curl</div><div class="lbl">HTTP requests (pre-installed)</div></div>
<div class="stat"><div class="num" style="font-size:1.2rem">openssl</div><div class="lbl">SSL/TLS checks (pre-installed)</div></div>
<div class="stat"><div class="num" style="font-size:1.2rem">grep/jq</div><div class="lbl">Response parsing (pre-installed)</div></div>
</div>
</div>'''


def _scope_section(data: dict, meta: dict) -> str:
    """Scope and configuration ‚Äî what was tested."""
    targets = data.get("target_urls", [])
    cves = data.get("cve_ids", [])
    vc = meta.get("verdict_counts", {})

    target_rows = "".join(f"<tr><td><code>{t}</code></td><td>HTTPS</td><td>External</td></tr>" for t in targets)

    cve_rows = ""
    for cve in cves:
        # Find the first result for this CVE
        sev = "unknown"
        desc = ""
        for r in data.get("cve_results", []):
            if r.get("cve_id") == cve:
                sev = r.get("severity", "unknown")
                desc = r.get("description", "")[:80]
                break
        cve_rows += f"<tr><td><code>{cve}</code></td><td>{sev_badge(sev)}</td><td style='font-size:.8rem;color:var(--dim)'>{desc}</td></tr>"

    return f'''<h2>üéØ 2. Scope &amp; Configuration</h2>
<div class="card">
<p style="font-size:.9rem;margin-bottom:12px">This defines <strong>exactly what was tested</strong> ‚Äî which targets, which CVEs, and what scan parameters.</p>

<div class="grid2">
<div>
<h3>Target Systems ({len(targets)})</h3>
<table><thead><tr><th>URL</th><th>Protocol</th><th>Network</th></tr></thead>
<tbody>{target_rows}</tbody></table>
<p style="font-size:.78rem;color:var(--dim);margin-top:8px">Each target was scanned across all 19 security check modules. Total test combinations: {len(targets)} targets √ó 19 phases = {len(targets) * 19} checks.</p>
</div>
<div>
<h3>Scan Parameters</h3>
<table>
<tr><td><strong>Scan Type</strong></td><td>Advanced (all 19 phases)</td></tr>
<tr><td><strong>Verification Stages</strong></td><td>{meta.get("verification_stages", 4)} stages per CVE</td></tr>
<tr><td><strong>CVEs Tested</strong></td><td>{len(cves)} CVEs √ó {len(targets)} targets = {meta.get("total_cve_tests", 0)} tests</td></tr>
<tr><td><strong>Confidence Threshold</strong></td><td>60% minimum</td></tr>
<tr><td><strong>AI Consensus</strong></td><td>{"Enabled (multi-LLM)" if meta.get("ai_powered") else "Disabled"}</td></tr>
</table>
</div>
</div>

<h3 style="margin-top:16px">CVEs Under Test ({len(cves)})</h3>
<div style="overflow-x:auto"><table><thead><tr><th>CVE ID</th><th>Severity</th><th>Description</th></tr></thead>
<tbody>{cve_rows}</tbody></table></div>
</div>'''



# ‚îÄ‚îÄ‚îÄ 19 Scan Phases reference ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
_SCAN_PHASES = [
    ("Security Headers", "Checks for missing or weak HTTP security headers (X-Frame-Options, X-Content-Type-Options, HSTS, CSP, Permissions-Policy).",
     "curl -sD- {url} | grep -iE 'x-frame|x-content-type|strict-transport|content-security'",
     "Look for MISSING headers ‚Äî each missing header is a finding."),
    ("SSL/TLS Configuration", "Validates TLS versions, cipher suites, certificate validity, HSTS preload.",
     "openssl s_client -connect {host}:443 -tls1_2 < /dev/null 2>&1 | grep -E 'Protocol|Cipher|Verify'",
     "Weak ciphers or expired certs indicate misconfiguration."),
    ("SQL Injection", "Sends SQL meta-characters (', \", ;--, OR 1=1) in query params and analyzes error responses.",
     "curl -s '{url}?id=1%27%20OR%201%3D1--' | grep -iE 'sql|syntax|mysql|postgres|oracle|error'",
     "Database error messages in response = likely injectable."),
    ("Cross-Site Scripting (XSS)", "Injects script tags and event handlers in parameters, checks if reflected in response body.",
     "curl -s '{url}?q=<script>alert(1)</script>' | grep -i '<script>'",
     "If payload appears unescaped in response body = reflected XSS."),
    ("Information Disclosure", "Checks Server header, X-Powered-By, error page details for version leaks.",
     "curl -sD- {url} | grep -iE 'server:|x-powered-by:'",
     "Server version strings reveal technology stack to attackers."),
    ("Path Traversal", "Attempts directory traversal sequences (../../etc/passwd) to detect file inclusion.",
     "curl -s '{url}/..%2F..%2F..%2Fetc%2Fpasswd' | head -5",
     "Content of /etc/passwd or similar = path traversal vulnerability."),
    ("CORS Misconfiguration", "Sends request with malicious Origin header, checks if server reflects it with credentials.",
     "curl -sD- -H 'Origin: https://evil.com' {url} | grep -i 'access-control'",
     "If Access-Control-Allow-Origin reflects evil.com with Allow-Credentials: true = exploitable CORS."),
    ("Cookie Security", "Inspects Set-Cookie headers for HttpOnly, Secure, SameSite flags.",
     "curl -sD- {url} | grep -i 'set-cookie'",
     "Missing HttpOnly/Secure/SameSite flags expose cookies to theft."),
    ("HTTP Methods", "Tests for dangerous HTTP methods (PUT, DELETE, TRACE, OPTIONS) on endpoints.",
     "curl -sD- -X OPTIONS {url} | grep -i 'allow:'",
     "Enabled TRACE/PUT/DELETE methods may allow data modification."),
    ("Technology Fingerprinting", "Identifies web server, framework, CDN, and libraries from response patterns.",
     "curl -sD- {url} | grep -iE 'server:|x-powered|via:|x-aspnet'",
     "Maps technology stack for CVE applicability assessment."),
    ("WAF Detection", "Detects Web Application Firewalls by analyzing response patterns to attack payloads.",
     "curl -sD- '{url}/?test=<script>' | grep -iE 'cf-ray|x-sucuri|x-cdn|server.*cloudflare'",
     "WAF presence affects exploitation feasibility of other findings."),
    ("Open Redirect", "Tests URL parameters (url=, redirect=, dest=, next=) for redirect to external domains.",
     "curl -sD- -L '{url}?dest=https://evil.com' | grep -i 'location.*evil.com'",
     "If server redirects to attacker URL = phishing/OAuth token theft vector."),
    ("CRLF Injection", "Injects \\r\\n sequences into headers to test for HTTP response splitting.",
     "curl -sD- '{url}/%0d%0aInjected-Header:true' | grep -i 'injected-header'",
     "Custom header appearing in response = CRLF injection."),
    ("API/Endpoint Discovery", "Probes common API paths (/api, /graphql, /swagger, /health, /.env, /admin).",
     "curl -s -o /dev/null -w '%{{http_code}}' {url}/api/v1/",
     "200/401/403 responses reveal hidden API endpoints."),
    ("Server-Side Template Injection", "Injects template expressions ({{{{7*7}}}}, ${{7*7}}) and checks for evaluation.",
     "curl -s '{url}?name={{{{7*7}}}}' | grep '49'",
     "If '49' appears in response body = SSTI vulnerability."),
    ("HTTP Request Smuggling", "Tests for CL.TE and TE.CL smuggling via conflicting Content-Length/Transfer-Encoding.",
     "# Advanced ‚Äî requires crafted HTTP/1.1 requests\ncurl -s -H 'Transfer-Encoding: chunked' -H 'Content-Length: 0' {url}",
     "Discrepancies in how front-end vs back-end parse request = smuggling."),
    ("Host Header Injection", "Sends request with modified Host header and checks if reflected in response.",
     "curl -sD- -H 'Host: evil.example.com' {url} | grep -i 'evil.example.com'",
     "If injected host appears in response = cache poisoning/password reset hijacking."),
    ("Deserialization", "Tests for insecure deserialization by sending crafted serialized objects.",
     "# Tests Java/Python/PHP serialization markers in responses\ncurl -s {url} | grep -iE 'java\\.io|pickle|unserialize'",
     "Serialization markers in error messages indicate deserialization attack surface."),
    ("Cache Poisoning", "Tests cache key manipulation via unkeyed headers to poison cached responses.",
     "curl -sD- -H 'X-Forwarded-Host: evil.com' {url} | grep -iE 'evil\\.com|x-cache|age:'",
     "If X-Forwarded-Host reflects in cached response = cache poisoning."),
]


def _execution_walkthrough_section(data: dict, meta: dict) -> str:
    """Step-by-step walkthrough of all 19 scan phases."""
    targets = data.get("target_urls", [])
    sample_url = targets[0] if targets else "https://example.com"
    sample_host = sample_url.replace("https://", "").replace("http://", "").split("/")[0]

    rows = ""
    for i, (name, desc, cmd, interpret) in enumerate(_SCAN_PHASES, 1):
        example_cmd = cmd.replace("{url}", sample_url).replace("{host}", sample_host)
        # Escape HTML
        example_cmd = example_cmd.replace("<", "&lt;").replace(">", "&gt;")

        rows += f'''<div class="finding-detail" style="border-left-color:var(--accent)">
<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
<span class="badge" style="background:var(--accent)">Phase {i}</span>
<strong>{name}</strong>
</div>
<p style="font-size:.85rem;margin-bottom:8px">{desc}</p>
<div style="margin-bottom:6px">
<div style="font-size:.72rem;text-transform:uppercase;color:var(--dim);letter-spacing:.04em;margin-bottom:2px">Manual Reproduction Command</div>
<pre>{example_cmd}</pre>
</div>
<div style="font-size:.82rem;color:var(--dim)"><strong>How to Interpret:</strong> {interpret}</div>
</div>'''

    return f'''<h2>üîç 3. Step-by-Step Execution Walkthrough</h2>
<div class="card">
<p style="font-size:.9rem;margin-bottom:12px">The scanner executed <strong>19 security check phases</strong> against each target.
Below is exactly what each phase does, the <code>curl</code> command to reproduce it manually, and how to interpret results.</p>
<p style="font-size:.82rem;color:var(--dim);margin-bottom:16px"><strong>Tip:</strong> Replace <code>{sample_url}</code> with your own target URL to test your own systems.
These commands work on any macOS/Linux terminal with curl installed.</p>
{rows}
</div>'''



def _reproduction_guide_section(data: dict, meta: dict) -> str:
    """Detailed reproduction guide for each verified exploit."""
    cve_results = data.get("cve_results", [])
    findings = data.get("findings", [])
    poc = meta.get("poc_commands", [])

    verified = [r for r in cve_results if r.get("finding_type") == "verified_exploit"]
    if not verified:
        return ""

    items = ""
    for idx, v in enumerate(verified, 1):
        ev = v.get("evidence", {})
        target = v.get("target_url", "?")
        title = v.get("title", v.get("cve_id", "?"))
        sev = v.get("severity", "medium")
        method = ev.get("verification_method", "response_analysis")

        # Find matching PoC command
        poc_cmd = ""
        for p in poc:
            if p.get("target", "") == target and (v.get("title", "") in p.get("description", "") or
                                                    v.get("cve_id", "").split("-")[-1].lower() in p.get("type", "").lower()):
                poc_cmd = p.get("curl_command", "")
                break

        # Build step-by-step based on verification method
        if "cors" in title.lower():
            steps = f'''<div class="finding-detail" style="border-left-color:#dc2626">
<strong>Step 1: Send request with malicious Origin header</strong>
<pre>curl -sD- -H 'Origin: https://evil.com' '{target}'</pre>
<strong>Step 2: Check the response headers</strong>
<pre>curl -sD- -H 'Origin: https://evil.com' '{target}' | grep -i 'access-control'</pre>
<strong>Step 3: Verify what you should see</strong>
<div style="font-size:.85rem;margin:8px 0;padding:8px;background:#0c1222;border-radius:4px;color:#a5f3fc">
<strong>Expected output (VULNERABLE):</strong><br>
<code>access-control-allow-origin: https://evil.com</code><br>
<code>access-control-allow-credentials: true</code><br><br>
<strong>Safe output (NOT vulnerable):</strong><br>
<code>access-control-allow-origin: https://yourdomain.com</code> (not reflecting evil.com)<br>
OR no access-control headers at all
</div>
<strong>Step 4: Understand the impact</strong>
<p style="font-size:.85rem">If the server reflects <code>https://evil.com</code> as the allowed origin AND sets <code>Allow-Credentials: true</code>, an attacker can:</p>
<ul style="font-size:.85rem;padding-left:20px;margin:4px 0">
<li>Read sensitive data from the target via a malicious website</li>
<li>Steal session cookies and authentication tokens</li>
<li>Perform actions on behalf of the victim user</li>
</ul>
<strong>Our scan found:</strong> Origin <code>{ev.get("origin_sent","evil.com")}</code> ‚Üí ACAO: <code>{ev.get("acao","?")}</code>, Credentials: <code>{ev.get("acac","?")}</code>
</div>'''
        elif "host" in title.lower():
            injected = ev.get("injected_host", "aldeci-evil.example.com")
            steps = f'''<div class="finding-detail" style="border-left-color:#dc2626">
<strong>Step 1: Send request with injected Host header</strong>
<pre>curl -sD- -H 'Host: {injected}' '{target}'</pre>
<strong>Step 2: Check if injected value appears in response</strong>
<pre>curl -s -H 'Host: {injected}' '{target}' | grep -i '{injected}'</pre>
<strong>Step 3: Verify what you should see</strong>
<div style="font-size:.85rem;margin:8px 0;padding:8px;background:#0c1222;border-radius:4px;color:#a5f3fc">
<strong>Expected output (VULNERABLE):</strong><br>
The response body or headers contain <code>{injected}</code><br><br>
<strong>Safe output (NOT vulnerable):</strong><br>
No mention of <code>{injected}</code> anywhere in the response
</div>
<strong>Step 4: Differential confirmation (what the scanner did)</strong>
<p style="font-size:.85rem">The scanner sends TWO requests ‚Äî one normal, one with the injected Host ‚Äî and compares responses. If the injected hostname <em>only</em> appears in the modified request, it confirms the vulnerability (not a static string).</p>
<pre># Normal request (baseline)
curl -s '{target}' > baseline.html
# Injected request
curl -s -H 'Host: {injected}' '{target}' > injected.html
# Compare
diff baseline.html injected.html | grep '{injected}'</pre>
<strong>Step 5: Understand the impact</strong>
<ul style="font-size:.85rem;padding-left:20px;margin:4px 0">
<li><strong>Cache poisoning:</strong> CDN caches the response with the evil host ‚Üí all users see poisoned page</li>
<li><strong>Password reset hijacking:</strong> Reset link sent to user contains evil domain</li>
<li><strong>SSRF:</strong> Server makes internal requests using the injected host</li>
</ul>
<strong>Our scan found:</strong> Injected <code>{injected}</code> ‚Äî reflected: <code>{ev.get("reflected","?")}</code>, differential: <code>{ev.get("differential","?")}</code>
</div>'''
        else:
            # Generic reproduction for other exploit types
            steps = f'''<div class="finding-detail" style="border-left-color:#dc2626">
<strong>Step 1: Run the PoC command</strong>
<pre>{poc_cmd if poc_cmd else f"curl -sD- '{target}'"}</pre>
<strong>Step 2: Examine the response</strong>
<p style="font-size:.85rem">Look for evidence matching: <code>{ev.get("proof", "See evidence details below")}</code></p>
<strong>Step 3: Evidence from our scan</strong>
<div style="font-size:.82rem;margin:4px 0">''' + "".join(
                f'<div><code>{k}</code>: <strong>{val}</strong></div>'
                for k, val in ev.items() if k not in ("proof", "verification_method")
            ) + '''</div>
</div>'''

        items += f'''<div class="card" style="border-color:#dc2626;margin-bottom:16px">
<div style="display:flex;align-items:center;gap:8px;margin-bottom:12px">
<span class="badge" style="background:#dc2626;font-size:.85rem;padding:4px 12px">Exploit #{idx}</span>
{sev_badge(sev)} <strong style="font-size:1.05rem">{title}</strong>
</div>
<table style="margin-bottom:12px">
<tr><td><strong>Target</strong></td><td><code>{target}</code></td></tr>
<tr><td><strong>Confidence</strong></td><td>{v.get("confidence_score", v.get("confidence", 0) * 100):.0f}%</td></tr>
<tr><td><strong>Verification Method</strong></td><td>{method.replace("_", " ").title()}</td></tr>
<tr><td><strong>Verification Chain</strong></td><td><code>{v.get("verification_chain", "scan‚Üídetect‚Üíexploit‚Üíverify")}</code></td></tr>
<tr><td><strong>CWE</strong></td><td><code>{v.get("cwe_id", "N/A")}</code></td></tr>
<tr><td><strong>CVSS</strong></td><td>{v.get("cvss_score", 0)}</td></tr>
</table>
<h3>Reproduction Steps (copy-paste these commands)</h3>
{steps}
<div style="margin-top:12px;padding:10px;background:var(--bg);border-radius:8px">
<strong>Remediation:</strong> <span style="font-size:.85rem">{v.get("remediation", "N/A")}</span>
</div>
</div>'''

    return f'''<h2>üî¨ 4. Detailed Reproduction Guide ‚Äî Verified Exploits</h2>
<div style="margin-bottom:16px">
<p style="font-size:.9rem;margin-bottom:8px">For each confirmed vulnerability, here are <strong>exact step-by-step instructions</strong> that anyone (including non-pentesters) can follow to verify the exploit independently.</p>
<p style="font-size:.82rem;color:var(--dim)">Requirements: A terminal with <code>curl</code> installed (macOS/Linux ‚Äî pre-installed). No special tools needed.</p>
</div>
{items}'''


def _cve_test_methodology_section(data: dict, meta: dict) -> str:
    """Explain the 4-stage CVE verification pipeline with real examples."""
    cve_results = data.get("cve_results", [])
    # Pick one NOT_APPLICABLE and one UNVERIFIED as examples
    na_example = next((r for r in cve_results if r.get("verdict") == "NOT_APPLICABLE"), None)
    unv_example = next((r for r in cve_results if r.get("verdict") == "UNVERIFIED"), None)

    na_html = ""
    if na_example:
        ev = na_example.get("evidence", {})
        verification = ev.get("verification", {})
        stages = verification.get("verification_stages", []) if isinstance(verification, dict) else []
        stage_rows = ""
        for s in stages:
            status_color = "#22c55e" if s.get("result") in ("PASS", "pass", "BLOCKED") else "#eab308"
            stage_rows += (f'<tr><td><strong>{s.get("stage","")}</strong></td>'
                           f'<td><span style="color:{status_color}">{s.get("result","")}</span></td>'
                           f'<td style="font-size:.8rem">{s.get("detail","")[:100]}</td></tr>')
        na_html = f'''<div class="finding-detail">
<strong>Example: {na_example.get("cve_id")} on {na_example.get("target_url")}</strong>
<p style="font-size:.85rem;color:var(--dim)">Verdict: NOT_APPLICABLE ‚Äî {ev.get("reason","Product not detected")}</p>
{f'<table style="margin-top:6px"><tr><th>Stage</th><th>Result</th><th>Detail</th></tr>{stage_rows}</table>' if stage_rows else ""}
</div>'''

    unv_html = ""
    if unv_example:
        ev = unv_example.get("evidence", {})
        unv_html = f'''<div class="finding-detail">
<strong>Example: {unv_example.get("cve_id")} on {unv_example.get("target_url")}</strong>
<p style="font-size:.85rem;color:var(--dim)">Verdict: UNVERIFIED ‚Äî {ev.get("note", ev.get("reason","No specific test exists"))[:150]}</p>
<p style="font-size:.82rem">Test method: <code>{unv_example.get("test_method","generic")}</code></p>
</div>'''

    ai_section = ""
    if meta.get("ai_powered"):
        ai = meta.get("ai_analysis", {})
        ai_section = f'''<h3 style="margin-top:20px">Stage 5: AI Consensus (PentAGI)</h3>
<p style="font-size:.85rem">For UNVERIFIED CVEs, the AI layer provides additional analysis:</p>
<ol style="padding-left:20px;font-size:.85rem">
<li><strong>Gemini (Architect)</strong> analyzes the attack surface and business impact</li>
<li><strong>Claude (Developer)</strong> evaluates exploitability and suggests tools/payloads</li>
<li><strong>GPT-4 (Team Lead)</strong> synthesizes a go/no-go decision with risk level</li>
<li><strong>Consensus Composer</strong> merges all opinions with weights (architect=0.35, developer=0.40, lead=0.25)</li>
</ol>
<p style="font-size:.85rem;margin-top:8px"><strong>Stats:</strong> {ai.get("consensus_decisions",0)} consensus decisions made, {ai.get("total_llm_calls",0)} LLM calls, {ai.get("duration_seconds",0):.0f}s AI processing time.</p>'''

    return f'''<h2>üß™ 5. CVE Verification Pipeline ‚Äî How Each CVE Was Tested</h2>
<div class="card">
<p style="font-size:.9rem;margin-bottom:12px">Every CVE goes through a <strong>4-stage verification pipeline</strong>. This prevents false positives by requiring multiple forms of evidence before confirming a vulnerability.</p>

<div class="grid2">
<div>
<h3>Stage 1: Product Detection</h3>
<p style="font-size:.85rem">Before testing any CVE, the scanner first checks if the <strong>affected product</strong> is running on the target. For example, CVE-2021-44228 (Log4Shell) only affects Apache Log4j ‚Äî so we first look for Log4j indicators.</p>
<p style="font-size:.82rem;color:var(--dim);margin-top:4px"><strong>How:</strong> Checks <code>Server</code> header, <code>X-Powered-By</code>, response body patterns, cookies, and known fingerprints.</p>
<p style="font-size:.82rem;color:var(--dim)"><strong>If product NOT found:</strong> Verdict = NOT_APPLICABLE (skip remaining stages)</p>

<h3 style="margin-top:12px">Stage 2: Version Fingerprinting</h3>
<p style="font-size:.85rem">If the product is found, attempt to identify the <strong>exact version</strong>. Many CVEs affect only specific version ranges.</p>
<p style="font-size:.82rem;color:var(--dim)"><strong>How:</strong> Parses version strings from headers, error pages, known version-specific behaviors.</p>
</div>
<div>
<h3>Stage 3: Exploit Verification</h3>
<p style="font-size:.85rem">Sends a <strong>targeted exploit payload</strong> specific to the CVE and analyzes the response for signs of successful exploitation.</p>
<p style="font-size:.82rem;color:var(--dim)"><strong>How:</strong> CVE-specific test functions send crafted HTTP requests and check for vulnerability indicators in the response.</p>

<h3 style="margin-top:12px">Stage 4: Differential Confirmation</h3>
<p style="font-size:.85rem">Compares the response to a <strong>benign request</strong> to confirm the finding isn't just a normal server behavior.</p>
<p style="font-size:.82rem;color:var(--dim)"><strong>How:</strong> Sends identical request without exploit payload. If vulnerable behavior only appears with the exploit ‚Üí confirmed vulnerability.</p>
</div>
</div>

{ai_section}

<h3 style="margin-top:20px">Real Examples from This Scan</h3>
{na_html}
{unv_html}
</div>'''


def _findings_detail_section(data: dict) -> str:
    """Detailed breakdown of all general findings with reproduction instructions."""
    findings = data.get("findings", [])
    if not findings:
        return ""

    items = ""
    for i, f in enumerate(findings, 1):
        ev = f.get("evidence", {})
        target = f.get("target", "?")
        title = f.get("title", "?")
        sev = f.get("severity", "unknown")
        desc = f.get("description", "")
        vuln_type = f.get("vulnerability_type", "")
        remediation = f.get("remediation", "")
        cwe = f.get("cwe_id", "")

        # Build evidence HTML
        ev_html = ""
        for k, v in ev.items():
            if isinstance(v, dict):
                ev_html += f'<div style="font-size:.78rem"><code>{k}</code>: {json.dumps(v)[:120]}</div>'
            elif isinstance(v, list):
                ev_html += f'<div style="font-size:.78rem"><code>{k}</code>: {", ".join(str(x)[:40] for x in v[:5])}</div>'
            else:
                ev_html += f'<div style="font-size:.78rem"><code>{k}</code>: <strong>{str(v)[:100]}</strong></div>'

        # Manual reproduction hint based on type
        repro = ""
        vt_lower = vuln_type.lower()
        if "header" in vt_lower or "security_headers" in vt_lower:
            repro = f"<pre>curl -sD- '{target}' | grep -iE 'x-frame|x-content|strict-transport|content-security|permissions-policy'</pre>"
        elif "cors" in vt_lower:
            repro = f"<pre>curl -sD- -H 'Origin: https://evil.com' '{target}' | grep -i 'access-control'</pre>"
        elif "cookie" in vt_lower:
            repro = f"<pre>curl -sD- '{target}' | grep -i 'set-cookie'</pre>"
        elif "information_disclosure" in vt_lower:
            repro = f"<pre>curl -sD- '{target}' | grep -iE 'server:|x-powered-by:'</pre>"
        elif "technology" in vt_lower or "fingerprint" in vt_lower:
            repro = f"<pre>curl -sD- '{target}' | head -20</pre>"
        elif "waf" in vt_lower:
            repro = f"<pre>curl -sD- '{target}' | grep -iE 'cf-ray|cloudflare|x-cdn|server'</pre>"
        elif "host" in vt_lower:
            repro = f"<pre>curl -sD- -H 'Host: evil.example.com' '{target}' | grep -i 'evil'</pre>"
        elif "api" in vt_lower:
            repro = f"<pre>curl -s -o /dev/null -w '%{{http_code}}' '{target}/api/v1/' && echo</pre>"
        else:
            repro = f"<pre>curl -sD- '{target}'</pre>"

        items += f'''<tr>
<td style="font-size:.78rem;white-space:nowrap">{i}</td>
<td>{sev_badge(sev)}</td>
<td><strong>{title}</strong>
<div style="font-size:.78rem;color:var(--dim)">{desc[:120]}</div></td>
<td><code style="font-size:.72rem">{target}</code></td>
<td><details><summary style="cursor:pointer;font-size:.78rem;color:var(--accent)">Evidence + Repro</summary>
<div style="margin-top:4px">{ev_html}
<div style="margin-top:6px;font-size:.72rem;text-transform:uppercase;color:var(--dim)">Manual Reproduction:</div>
{repro}
{f'<div style="font-size:.78rem;margin-top:4px"><strong>Remediation:</strong> {remediation}</div>' if remediation else ""}
</div></details></td>
</tr>'''

    return f'''<h2>üìä 6. All Findings ‚Äî Detailed Evidence &amp; Reproduction</h2>
<div class="card" style="overflow-x:auto">
<p style="font-size:.9rem;margin-bottom:12px">Every finding discovered during the scan, with evidence and manual reproduction commands. Expand each row to see how to reproduce.</p>
<table><thead><tr><th>#</th><th>Severity</th><th>Finding</th><th>Target</th><th>Evidence &amp; Reproduction</th></tr></thead>
<tbody>{items}</tbody></table>
</div>'''


# ‚îÄ‚îÄ‚îÄ Architecture Intelligence Section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _architecture_intelligence_section(data: dict, meta: dict) -> str:
    """Section: Target Architecture Intelligence ‚Äî OS, cloud, tech stack, security posture."""
    profiles = meta.get("architecture_profiles") or {}
    if not profiles:
        return ""
    cards = ""
    for url, p in profiles.items():
        os_info = p.get("os_fingerprint", {})
        cloud = p.get("cloud_provider", {})
        cdn = p.get("cdn_waf", {})
        ts = p.get("tech_stack", {})
        sec = p.get("security_posture", {})
        conf = p.get("confidence", 0)
        arch_cls = p.get("architecture_class", "unknown")
        deploy = p.get("deployment_model", "unknown")
        # OS row
        os_row = f"<tr><td>üñ•Ô∏è OS</td><td><strong>{os_info.get('os','Unknown')}</strong> ‚Äî {os_info.get('evidence','No evidence')}</td></tr>" if os_info else ""
        # Cloud row
        cloud_name = cloud.get("provider", "None detected")
        cloud_conf = cloud.get("confidence", "low")
        cloud_row = f"<tr><td>‚òÅÔ∏è Cloud</td><td><strong>{cloud_name}</strong> (confidence: {cloud_conf})</td></tr>"
        # CDN/WAF row
        cdn_name = cdn.get("name", "None detected")
        cdn_type = cdn.get("type", "")
        cdn_row = f"<tr><td>üõ°Ô∏è CDN/WAF</td><td><strong>{cdn_name}</strong>{' (' + cdn_type + ')' if cdn_type else ''}</td></tr>"
        # Tech stack rows
        ts_rows = ""
        for comp, val in ts.items():
            if val:
                label = comp.replace("_", " ").title()
                ts_rows += f"<tr><td>‚öôÔ∏è {label}</td><td><strong>{val}</strong></td></tr>"
        # Security posture
        sec_rows = ""
        if sec:
            https = "‚úÖ Yes" if sec.get("https") else "‚ùå No"
            hsts = "‚úÖ Yes" if sec.get("hsts") else "‚ùå No"
            csp = "‚úÖ Yes" if sec.get("csp") else "‚ùå No"
            sec_pct = sec.get("security_headers_percentage", 0)
            waf = "‚úÖ Present" if sec.get("waf_detected") else "‚ö†Ô∏è Not detected"
            sec_rows = f"""<tr><td>üîí HTTPS</td><td>{https}</td></tr>
<tr><td>üìå HSTS</td><td>{hsts}</td></tr>
<tr><td>üõ°Ô∏è CSP</td><td>{csp}</td></tr>
<tr><td>üìä Security Headers</td><td>{sec_pct:.0%} coverage</td></tr>
<tr><td>üî• WAF</td><td>{waf}</td></tr>"""
        cards += f'''<div style="background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:16px">
<h3 style="margin-top:0;color:var(--accent)">{url}</h3>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:16px">
<div>
<h4 style="margin:0 0 8px">Infrastructure</h4>
<table style="width:100%;font-size:.85rem"><tbody>
{os_row}{cloud_row}{cdn_row}
<tr><td>üèóÔ∏è Architecture</td><td><strong>{arch_cls.title()}</strong></td></tr>
<tr><td>üöÄ Deployment</td><td><strong>{deploy.title()}</strong></td></tr>
</tbody></table>
</div>
<div>
<h4 style="margin:0 0 8px">Tech Stack & Security</h4>
<table style="width:100%;font-size:.85rem"><tbody>
{ts_rows}{sec_rows}
</tbody></table>
</div>
</div>
<div style="text-align:right;font-size:.75rem;color:var(--dim);margin-top:8px">Profiling confidence: {conf:.0%}</div>
</div>'''
    return f'''<div class="section">
<h2>üèóÔ∏è Architecture Intelligence</h2>
<p>Phase 0 architecture profiling runs <strong>before</strong> any vulnerability tests. It fingerprints each target's OS, cloud provider, CDN/WAF, tech stack, and security posture to guide context-aware scanning.</p>
{cards}
</div>'''


# ‚îÄ‚îÄ‚îÄ Source Code Audit Trail Section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _source_code_audit_trail_section(data: dict, meta: dict) -> str:
    """Section: exact source file/function/line for each finding's detection logic."""
    findings = data.get("findings") or []
    if not findings:
        return ""
    rows = ""
    seen = set()
    for f in findings:
        sf = f.get("source_file", "")
        sfn = f.get("source_function", "")
        sl = f.get("source_lines", "")
        dl = f.get("detection_logic", "")
        if not sf or sfn in seen:
            continue
        seen.add(sfn)
        title = f.get("title", "Unknown")
        vtype = f.get("vulnerability_type", "")
        rows += f'''<tr>
<td><strong>{title}</strong><br><span style="font-size:.75rem;color:var(--dim)">{vtype}</span></td>
<td><code>{sf}</code></td>
<td><code>{sfn}()</code></td>
<td><code>L{sl}</code></td>
<td style="font-size:.8rem">{dl[:200]}{"‚Ä¶" if len(dl) > 200 else ""}</td>
</tr>'''
    if not rows:
        return ""
    return f'''<div class="section">
<h2>üîç Source Code Audit Trail</h2>
<p>Every finding traces back to an exact file, function, and line range in the ALdeci codebase. This allows auditors to verify <em>how</em> each vulnerability was detected and reproduce the detection independently.</p>
<div style="overflow-x:auto">
<table><thead><tr><th>Finding</th><th>Source File</th><th>Function</th><th>Lines</th><th>Detection Logic</th></tr></thead>
<tbody>{rows}</tbody></table>
</div>
</div>'''


# ‚îÄ‚îÄ‚îÄ Threat Scenario Matrix Section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _threat_scenario_matrix_section(data: dict, meta: dict) -> str:
    """Section: threat scenario narratives, actor profiles, business impact for each finding type."""
    findings = data.get("findings") or []
    if not findings:
        return ""
    rows = ""
    seen = set()
    for f in findings:
        ts = f.get("threat_scenario", "")
        vtype = f.get("vulnerability_type", "")
        if not ts or vtype in seen:
            continue
        seen.add(vtype)
        actor = f.get("threat_actor", "Unknown")
        complexity = f.get("attack_complexity", "?")
        impacts = f.get("business_impact", [])
        owasp = f.get("owasp_top10", "")
        stride_val = f.get("stride", "")
        cwe = f.get("cwe_id") or ""
        examples = f.get("real_world_examples", [])
        os_rel = f.get("os_relevance", "")
        priority = f.get("remediation_priority", "")
        # Color code complexity
        cx_color = {"LOW": "#e74c3c", "MEDIUM": "#f39c12", "HIGH": "#27ae60"}.get(complexity, "#666")
        # Color code priority
        pr_color = {"CRITICAL": "#e74c3c", "HIGH": "#e67e22", "MEDIUM": "#f1c40f", "LOW": "#27ae60"}.get(priority, "#666")
        impact_html = "".join(f"<li>{i}</li>" for i in impacts[:4])
        examples_html = "".join(f"<li style='font-size:.8rem;color:var(--dim)'>{e}</li>" for e in examples[:3])
        title = f.get("title", vtype)
        rows += f'''<tr>
<td><strong>{title}</strong><br><span style="font-size:.75rem">{owasp}</span><br><code>{cwe}</code></td>
<td style="font-size:.85rem">{ts[:300]}{"‚Ä¶" if len(ts) > 300 else ""}</td>
<td>{actor}<br><span style="color:{cx_color};font-weight:bold">Complexity: {complexity}</span></td>
<td><ul style="margin:0;padding-left:16px">{impact_html}</ul></td>
<td><span style="color:{pr_color};font-weight:bold">{priority}</span><br><small>{stride_val}</small><br><small>{os_rel[:60]}</small></td>
<td><ul style="margin:0;padding-left:16px;font-size:.8rem">{examples_html}</ul></td>
</tr>'''
    if not rows:
        return ""
    return f'''<div class="section">
<h2>‚öîÔ∏è Threat Scenario Matrix</h2>
<p>Each vulnerability type is mapped to a <strong>real-world attack narrative</strong> explaining <em>why</em> it matters, who would exploit it, and what the business impact would be.</p>
<div style="overflow-x:auto">
<table><thead><tr><th>Vulnerability</th><th>Threat Scenario</th><th>Threat Actor / Complexity</th><th>Business Impact</th><th>Priority / STRIDE</th><th>Real-World Examples</th></tr></thead>
<tbody>{rows}</tbody></table>
</div>
</div>'''


# ‚îÄ‚îÄ‚îÄ Attack Surface Analysis Section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _attack_surface_analysis_section(data: dict, meta: dict) -> str:
    """Section: comprehensive attack surface breakdown per target."""
    profiles = meta.get("architecture_profiles") or {}
    findings = data.get("findings") or []
    cve_results = data.get("cve_results") or []
    if not findings and not cve_results:
        return ""
    # Compute per-target attack surface
    target_urls = data.get("target_urls") or []
    cards = ""
    for url in target_urls:
        tf = [f for f in findings if f.get("target") == url]
        tc = [c for c in cve_results if c.get("target_url") == url]
        vulns_by_sev = {}
        for f in tf:
            s = f.get("severity", "info")
            vulns_by_sev[s] = vulns_by_sev.get(s, 0) + 1
        confirmed = [c for c in tc if c.get("verdict") == "VULNERABLE_VERIFIED"]
        not_app = [c for c in tc if c.get("verdict") == "NOT_APPLICABLE"]
        # Security layers from architecture profile
        p = profiles.get(url, {})
        sec = p.get("security_posture", {})
        layers = []
        if sec.get("https"):
            layers.append("‚úÖ HTTPS/TLS")
        if sec.get("hsts"):
            layers.append("‚úÖ HSTS")
        if sec.get("csp"):
            layers.append("‚úÖ CSP")
        if sec.get("waf_detected"):
            layers.append("‚úÖ WAF Active")
        if not layers:
            layers.append("‚ö†Ô∏è No defense layers detected")
        _sev_colors = {"critical": "#e74c3c", "high": "#e67e22", "medium": "#f1c40f", "low": "#27ae60", "info": "#3498db"}
        sev_html = " ".join(f'<span style="background:{_sev_colors.get(s, "#666")};color:#fff;padding:2px 8px;border-radius:4px;font-size:.8rem;margin-right:4px">{s.upper()}: {c}</span>' for s, c in sorted(vulns_by_sev.items()))
        defense_html = " ".join(f'<span style="font-size:.85rem">{l}</span>' for l in layers)
        entry_points = len(tf)
        cards += f'''<div style="background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:12px">
<h3 style="margin-top:0;color:var(--accent)">{url}</h3>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;text-align:center;margin-bottom:12px">
<div style="background:var(--bg);padding:12px;border-radius:6px"><div style="font-size:1.5rem;font-weight:bold">{entry_points}</div><div style="font-size:.75rem;color:var(--dim)">Entry Points</div></div>
<div style="background:var(--bg);padding:12px;border-radius:6px"><div style="font-size:1.5rem;font-weight:bold;color:#e74c3c">{len(confirmed)}</div><div style="font-size:.75rem;color:var(--dim)">Confirmed Vulns</div></div>
<div style="background:var(--bg);padding:12px;border-radius:6px"><div style="font-size:1.5rem;font-weight:bold">{len(tc)}</div><div style="font-size:.75rem;color:var(--dim)">CVEs Tested</div></div>
<div style="background:var(--bg);padding:12px;border-radius:6px"><div style="font-size:1.5rem;font-weight:bold;color:#27ae60">{len(not_app)}</div><div style="font-size:.75rem;color:var(--dim)">Not Applicable</div></div>
</div>
<div style="margin-bottom:8px"><strong>Severity Distribution:</strong> {sev_html if sev_html else "<em>No findings</em>"}</div>
<div><strong>Defense Layers:</strong> {defense_html}</div>
</div>'''
    if not cards:
        return ""
    return f'''<div class="section">
<h2>üéØ Attack Surface Analysis</h2>
<p>Per-target breakdown of entry points discovered, vulnerabilities confirmed, defense layers detected, and overall exposure.</p>
{cards}
</div>'''


def _footer(now, meta: dict):
    engine = meta.get("engine", "aldeci_deterministic_v3")
    ai_powered = meta.get("ai_powered", False)
    engine_desc = f"{engine} ‚Ä¢ {'Multi-AI Consensus + ' if ai_powered else ''}4-stage verification"
    return (f'<div style="text-align:center;padding:40px 0 20px;color:var(--dim);font-size:.75rem;border-top:1px solid var(--border);margin-top:40px">'
            f'<p><strong>ALdeci</strong> ‚Äî Security Vulnerability Management Platform</p>'
            f'<p>Report generated {now} ‚Ä¢ Engine: {engine_desc}</p>'
            f'<p style="margin-top:8px">This report is confidential and intended for authorized recipients only.</p>'
            f'</div></div></body></html>')


if __name__ == "__main__":
    use_cache = "--cached" in sys.argv
    if use_cache:
        data = load_cached()
        if not data:
            print("[!] No cached data found. Running live scan...")
            data = run_pentest()
    else:
        data = run_pentest()

    html = build_html(data)
    REPORT_FILE.write_text(html)
    print(f"[+] Report saved to {REPORT_FILE}")
    abs_path = REPORT_FILE.resolve()
    print(f"[*] Opening in browser: file://{abs_path}")
    webbrowser.open(f"file://{abs_path}")

