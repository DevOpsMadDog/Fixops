# Enterprise Micro Penetration Testing Engine

## Overview

The Enterprise Micro Penetration Testing Engine is an advanced, automated security testing platform designed for enterprise environments. It provides targeted, continuous security validation with deep integration into CI/CD pipelines, compliance frameworks, and security operations.

## Features

### ğŸ¯ Micro Pen Testing
- **Targeted Testing**: Focus on specific attack vectors and threat models
- **Automated Execution**: Continuous security validation without manual intervention
- **Multi-Mode Scanning**: Passive, Active, Aggressive, and Stealth modes
- **Real-time Results**: Immediate feedback on security posture

### ğŸ›¡ï¸ Advanced Threat Modeling
- **MITRE ATT&CK Alignment**: Map attacks to MITRE techniques
- **OWASP Integration**: Built-in OWASP Top 10 testing
- **Custom Threat Models**: Define your own threat scenarios
- **Attack Path Generation**: Visualize potential attack chains

### ğŸ“Š Compliance & Governance
- **Multi-Framework Support**: SOC2, ISO27001, PCI-DSS, HIPAA, GDPR, NIST 800-53, CIS
- **Automated Validation**: Continuous compliance checking
- **Audit Logging**: Complete audit trail for compliance requirements
- **Violation Tracking**: Real-time compliance violation detection

### ğŸ¢ Enterprise Features
- **Multi-Tenancy**: Isolated testing environments per tenant
- **RBAC**: Role-based access control for security operations
- **API-First**: RESTful API for easy integration
- **Scalability**: Horizontal scaling for large deployments

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Enterprise Micro Pentest                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Attack       â”‚  â”‚  Threat       â”‚  â”‚  Compliance     â”‚ â”‚
â”‚  â”‚  Surface      â”‚  â”‚  Modeling     â”‚  â”‚  Validation     â”‚ â”‚
â”‚  â”‚  Mapping      â”‚  â”‚  Engine       â”‚  â”‚  Engine         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Vulnerabilityâ”‚  â”‚  Exploitation â”‚  â”‚  Risk Scoring   â”‚ â”‚
â”‚  â”‚  Scanner      â”‚  â”‚  Engine       â”‚  â”‚  & Priority     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Audit & Compliance Logging                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Quick Start

### Installation

```bash
# Install dependencies
pip install -r requirements.txt

# Set up environment
export FIXOPS_API_KEY="your-api-key"
export FIXOPS_TENANT_ID="your-tenant-id"
```

### Basic Usage

#### 1. Create a Scan

```bash
curl -X POST http://localhost:8000/api/v1/micro-pentest/scans \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-Tenant-ID: $TENANT_ID" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "API Security Scan",
    "attack_surface": {
      "name": "Payment API",
      "target_url": "https://api.example.com",
      "target_type": "api",
      "endpoints": ["/api/payments", "/api/users", "/api/auth"],
      "authentication_required": true,
      "authentication_type": "jwt",
      "environment": "staging"
    },
    "threat_model": {
      "name": "OWASP API Top 10",
      "description": "Test for common API vulnerabilities",
      "categories": ["initial_access", "credential_access"],
      "attack_vectors": ["sql_injection", "authentication_bypass", "api_abuse"],
      "priority": 8,
      "compliance_frameworks": ["owasp_top_10", "soc2"]
    },
    "scan_mode": "active",
    "stop_on_critical": true,
    "include_proof_of_concept": true
  }'
```

#### 2. Execute the Scan

```bash
curl -X POST http://localhost:8000/api/v1/micro-pentest/scans/{scan_id}/execute \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-Tenant-ID: $TENANT_ID"
```

#### 3. Get Results

```bash
curl -X GET http://localhost:8000/api/v1/micro-pentest/scans/{scan_id} \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-Tenant-ID: $TENANT_ID"
```

## Attack Vectors

The engine tests for the following attack vectors:

| Attack Vector | Description | Risk Level |
|--------------|-------------|------------|
| **SQL Injection** | Database query manipulation | Critical |
| **XSS** | Cross-site scripting attacks | High |
| **CSRF** | Cross-site request forgery | Medium |
| **SSRF** | Server-side request forgery | High |
| **Command Injection** | OS command execution | Critical |
| **Path Traversal** | Directory traversal attacks | High |
| **Authentication Bypass** | Authentication mechanism weaknesses | Critical |
| **Authorization Bypass** | Access control violations | Critical |
| **Session Hijacking** | Session token attacks | High |
| **API Abuse** | API rate limiting, mass assignment | Medium |
| **Cryptographic Weakness** | Weak crypto implementations | High |
| **Configuration Error** | Security misconfigurations | Medium |
| **Dependency Vulnerability** | Third-party component issues | Varies |
| **Secrets Exposure** | Leaked credentials/keys | Critical |
| **Container Escape** | Container breakout attempts | Critical |
| **Cloud Misconfiguration** | Cloud security issues | High |

## Scan Modes

### Passive Mode
- Non-intrusive reconnaissance
- Information gathering only
- No exploitation attempts
- Safe for production environments

### Active Mode
- Active vulnerability probing
- Targeted exploitation attempts
- Proof-of-concept generation
- Recommended for staging/test environments

### Aggressive Mode
- Full exploitation attempts
- Extensive testing coverage
- May trigger security alerts
- Use only in isolated test environments

### Stealth Mode
- Evasive testing techniques
- Low detection probability
- Rate-limited operations
- For testing detection capabilities

## Compliance Frameworks

### Supported Frameworks

- **SOC2**: Security and availability controls
- **ISO27001**: Information security management
- **PCI-DSS**: Payment card industry standards
- **HIPAA**: Healthcare data protection
- **GDPR**: Data privacy regulations
- **NIST 800-53**: Federal security controls
- **CIS**: Center for Internet Security benchmarks
- **OWASP Top 10**: Web application security

### Compliance Validation

The engine automatically validates security posture against compliance requirements:

```json
{
  "compliance_status": {
    "soc2": false,
    "owasp_top_10": false,
    "pci_dss": true
  },
  "violations": [
    {
      "framework": "soc2",
      "finding": "Critical authentication bypass vulnerability",
      "remediation": "Implement multi-factor authentication"
    }
  ]
}
```

## API Reference

### Endpoints

#### `POST /api/v1/micro-pentest/scans`
Create a new micro penetration test scan.

**Request Body:**
- `name` (string): Scan name
- `attack_surface` (object): Target definition
- `threat_model` (object): Threat model configuration
- `scan_mode` (string): Scan mode (passive, active, aggressive, stealth)
- `timeout_seconds` (int): Timeout in seconds
- `stop_on_critical` (bool): Stop on critical finding

**Response:** Scan result with queued status

#### `POST /api/v1/micro-pentest/scans/{scan_id}/execute`
Execute a queued scan.

**Response:** Scan result with running status

#### `GET /api/v1/micro-pentest/scans/{scan_id}`
Get scan result by ID.

**Response:** Complete scan result with findings

#### `GET /api/v1/micro-pentest/scans`
List all scans for the authenticated tenant.

**Query Parameters:**
- `status` (string): Filter by status

**Response:** List of scan results

#### `POST /api/v1/micro-pentest/scans/{scan_id}/cancel`
Cancel a running scan.

**Response:** Success message

#### `GET /api/v1/micro-pentest/audit-logs`
Get audit logs for compliance tracking.

**Query Parameters:**
- `action` (string): Filter by action
- `start_date` (string): Start date (ISO format)
- `end_date` (string): End date (ISO format)
- `limit` (int): Maximum results

**Response:** List of audit log entries

## Security Best Practices

### 1. Authentication & Authorization
- Always use API keys or JWT tokens
- Implement RBAC for scan execution
- Audit all security testing activities

### 2. Environment Isolation
- Use staging/test environments for aggressive scans
- Implement network segmentation
- Monitor for scan-related traffic

### 3. Rate Limiting
- Configure appropriate rate limits
- Respect target system capacity
- Use passive mode for production

### 4. Compliance
- Enable audit logging
- Track compliance violations
- Generate compliance reports

### 5. Incident Response
- Monitor critical findings
- Automate alerting
- Integrate with SIEM/SOAR

## Integration Examples

### CI/CD Pipeline (GitHub Actions)

```yaml
name: Security Scan

on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Run Micro Pentest
        run: |
          SCAN_ID=$(curl -X POST $PENTEST_API/scans \
            -H "Authorization: Bearer $TOKEN" \
            -d @scan-config.json | jq -r '.scan_id')
          
          curl -X POST $PENTEST_API/scans/$SCAN_ID/execute \
            -H "Authorization: Bearer $TOKEN"
          
          # Wait for completion and check results
          while true; do
            STATUS=$(curl -X GET $PENTEST_API/scans/$SCAN_ID \
              -H "Authorization: Bearer $TOKEN" | jq -r '.status')
            
            if [ "$STATUS" = "completed" ]; then
              break
            fi
            sleep 10
          done
          
          # Fail build on critical findings
          CRITICAL=$(curl -X GET $PENTEST_API/scans/$SCAN_ID \
            -H "Authorization: Bearer $TOKEN" | \
            jq '.summary.findings_by_risk.critical')
          
          if [ "$CRITICAL" -gt 0 ]; then
            echo "Critical vulnerabilities found!"
            exit 1
          fi
```

### Python Integration

```python
import asyncio
from fixops_enterprise.src.services.micro_pentest_engine import (
    AttackSurface,
    MicroPentestEngine,
    MicroScanConfig,
    ScanMode,
    ThreatModel,
    AttackVector,
    ThreatCategory,
    ComplianceFramework,
)

async def run_security_scan():
    engine = MicroPentestEngine()
    
    # Define attack surface
    attack_surface = AttackSurface(
        name="Production API",
        target_url="https://api.example.com",
        target_type="api",
        endpoints=["/api/v1/users", "/api/v1/payments"],
        authentication_required=True,
        authentication_type="oauth2",
    )
    
    # Define threat model
    threat_model = ThreatModel(
        name="Critical Security Test",
        description="Test for critical vulnerabilities",
        categories=[ThreatCategory.INITIAL_ACCESS],
        attack_vectors=[
            AttackVector.SQL_INJECTION,
            AttackVector.AUTHENTICATION_BYPASS,
        ],
        compliance_frameworks=[ComplianceFramework.OWASP_TOP_10],
    )
    
    # Create and execute scan
    config = MicroScanConfig(
        name="Daily Security Scan",
        attack_surface=attack_surface,
        threat_model=threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="acme-corp",
        organization_id="eng-team",
        created_by="security-bot",
    )
    
    result = await engine.create_micro_scan(config, "security-bot")
    result = await engine.execute_micro_scan(result.scan_id, "security-bot")
    
    # Process results
    print(f"Scan completed in {result.execution_time_seconds}s")
    print(f"Total findings: {len(result.findings)}")
    
    for finding in result.findings:
        if finding.risk_level.value in ["critical", "high"]:
            print(f"[{finding.risk_level.value.upper()}] {finding.title}")
            print(f"  Affected: {finding.affected_endpoint}")
            print(f"  Remediation: {finding.remediation}")

if __name__ == "__main__":
    asyncio.run(run_security_scan())
```

## Troubleshooting

### Common Issues

#### Scan Timeout
**Problem**: Scan times out before completion

**Solution**:
- Increase `timeout_seconds` in scan config
- Reduce scope of attack surface
- Use passive mode for initial reconnaissance

#### Authentication Failures
**Problem**: API requests fail with 401 Unauthorized

**Solution**:
- Verify API key/JWT token validity
- Check tenant ID header
- Ensure proper RBAC permissions

#### False Positives
**Problem**: Scan reports vulnerabilities that don't exist

**Solution**:
- Review scan evidence carefully
- Adjust scan mode (use passive for initial assessment)
- Configure attack surface more precisely

## Performance Tuning

### Optimization Tips

1. **Rate Limiting**: Balance between speed and target system load
2. **Threading**: Adjust `max_threads` based on infrastructure
3. **Timeout**: Set appropriate timeouts for different scan modes
4. **Scope**: Limit attack surface to relevant endpoints

### Recommended Settings

| Environment | Scan Mode | Rate Limit | Max Threads | Timeout |
|------------|-----------|------------|-------------|---------|
| Production | Passive | 5 rps | 2 | 300s |
| Staging | Active | 20 rps | 5 | 600s |
| Testing | Aggressive | 50 rps | 10 | 1200s |

## Roadmap

### Upcoming Features

- [ ] Machine learning-based vulnerability detection
- [ ] Automated remediation suggestions
- [ ] Integration with vulnerability databases (CVE, NVD)
- [ ] Advanced reporting and visualization
- [ ] WebSocket support for real-time updates
- [ ] Plugin system for custom attack vectors
- [ ] Container and Kubernetes security scanning
- [ ] Infrastructure-as-Code security validation

## Support

For issues, questions, or contributions:

- **Documentation**: See `/docs` directory
- **API Reference**: See OpenAPI spec at `/api/v1/docs`
- **Issues**: File bug reports and feature requests
- **Security**: Report security issues privately

## License

Enterprise license - Contact sales for licensing information

## Credits

Built with:
- FastAPI
- Pydantic
- Python 3.11+
- MITRE ATT&CK Framework
- OWASP Security Guidelines
