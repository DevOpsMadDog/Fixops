"""Core micro penetration test functionality for PentAGI integration.

This module provides the shared business logic for micropentests, used by both
the main API router and the enterprise API router.
"""

from __future__ import annotations

import asyncio
import os
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

import httpx
import structlog

logger = structlog.get_logger(__name__)


@dataclass
class MicroPentestConfig:
    """Configuration for micro penetration tests."""

    pentagi_url: str = field(
        default_factory=lambda: os.environ.get(
            "PENTAGI_BASE_URL", "http://pentagi:8443"
        )
    )
    timeout_seconds: float = 300.0  # 5 minutes for pen tests
    provider: str = "openai"  # Default LLM provider


@dataclass
class MicroPentestResult:
    """Result of a micro penetration test."""

    status: str
    flow_id: Optional[int] = None
    cve_ids: List[str] = field(default_factory=list)
    target_urls: List[str] = field(default_factory=list)
    message: str = ""
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        result: Dict[str, Any] = {
            "status": self.status,
            "cve_ids": self.cve_ids,
            "target_urls": self.target_urls,
            "message": self.message,
        }
        if self.flow_id is not None:
            result["flow_id"] = self.flow_id
        if self.error:
            result["error"] = self.error
        return result


@dataclass
class MicroPentestStatus:
    """Status of a micro penetration test flow."""

    flow_id: int
    status: str
    progress: int = 0
    tasks: List[Dict[str, Any]] = field(default_factory=list)
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        result = {
            "flow_id": self.flow_id,
            "status": self.status,
            "progress": self.progress,
            "tasks": self.tasks,
        }
        if self.error:
            result["error"] = self.error
        return result


def _get_pentagi_client(config: MicroPentestConfig) -> httpx.AsyncClient:
    """Get PentAGI API client."""
    return httpx.AsyncClient(
        base_url=config.pentagi_url,
        timeout=config.timeout_seconds,
    )


async def run_micro_pentest(
    cve_ids: List[str],
    target_urls: List[str],
    context: Optional[Dict[str, Any]] = None,
    config: Optional[MicroPentestConfig] = None,
) -> MicroPentestResult:
    """Run micro penetration tests for selected CVEs using PentAGI.

    Args:
        cve_ids: List of CVE IDs to test
        target_urls: List of target URLs to test against
        context: Optional context information for the test
        config: Optional configuration (uses defaults if not provided)

    Returns:
        MicroPentestResult with status and flow_id if successful
    """
    if config is None:
        config = MicroPentestConfig()

    if not cve_ids:
        return MicroPentestResult(
            status="error",
            error="At least one CVE ID is required",
        )

    if not target_urls:
        return MicroPentestResult(
            status="error",
            error="At least one target URL is required",
        )

    logger.info(
        "micro_pentest.start",
        cve_count=len(cve_ids),
        target_count=len(target_urls),
        cve_ids=cve_ids[:5],  # Log first 5 CVEs
    )

    # Prepare PentAGI flow request
    pentagi_payload: Dict[str, Any] = {
        "input": (
            f"Perform micro penetration tests for CVEs: {', '.join(cve_ids)}. "
            f"Target URLs: {', '.join(target_urls)}. "
            f"Focus on verifying exploitability and impact assessment. "
            f"Test each CVE individually and provide detailed findings."
        ),
        "provider": config.provider,
        "functions": {
            "disabled": [],
            "functions": [],
        },
    }

    # Add context if provided
    if context:
        pentagi_payload["context"] = context

    try:
        async with _get_pentagi_client(config) as client:
            response = await client.post(
                "/api/v1/flows",
                json=pentagi_payload,
                headers={"Content-Type": "application/json"},
            )

            if response.status_code != 201:
                logger.error(
                    "micro_pentest.pentagi_error",
                    status_code=response.status_code,
                    response_text=response.text,
                )
                return MicroPentestResult(
                    status="error",
                    cve_ids=cve_ids,
                    target_urls=target_urls,
                    error=f"PentAGI API error: {response.text}",
                )

            # PentAGI returns: { "data": { "id": ..., ... } } or { "id": ..., ... }
            flow_data = response.json()
            flow_obj = flow_data.get("data", flow_data)
            flow_id = flow_obj.get("id") or flow_obj.get("flow_id")

            logger.info("micro_pentest.flow_created", flow_id=flow_id)

            return MicroPentestResult(
                status="started",
                flow_id=flow_id,
                cve_ids=cve_ids,
                target_urls=target_urls,
                message=f"Micro penetration test started for {len(cve_ids)} CVEs",
            )

    except httpx.TimeoutException:
        logger.error("micro_pentest.timeout")
        return MicroPentestResult(
            status="error",
            cve_ids=cve_ids,
            target_urls=target_urls,
            error="PentAGI request timeout",
        )
    except httpx.RequestError as e:
        logger.error("micro_pentest.request_error", exc_info=e)
        return MicroPentestResult(
            status="error",
            cve_ids=cve_ids,
            target_urls=target_urls,
            error="Failed to connect to PentAGI",
        )


async def get_micro_pentest_status(
    flow_id: int,
    config: Optional[MicroPentestConfig] = None,
) -> MicroPentestStatus:
    """Get status of a micro penetration test flow.

    Args:
        flow_id: The PentAGI flow ID
        config: Optional configuration (uses defaults if not provided)

    Returns:
        MicroPentestStatus with current status and progress
    """
    if config is None:
        config = MicroPentestConfig()

    try:
        async with _get_pentagi_client(config) as client:
            response = await client.get(f"/api/v1/flows/{flow_id}")

            if response.status_code != 200:
                return MicroPentestStatus(
                    flow_id=flow_id,
                    status="error",
                    error=f"Failed to get flow status: {response.text}",
                )

            flow_data = response.json()
            return MicroPentestStatus(
                flow_id=flow_id,
                status=flow_data.get("status", "unknown"),
                progress=flow_data.get("progress", 0),
                tasks=flow_data.get("tasks", []),
            )

    except httpx.RequestError as e:
        logger.error("micro_pentest.status_error", flow_id=flow_id, exc_info=e)
        return MicroPentestStatus(
            flow_id=flow_id,
            status="error",
            error="Failed to connect to PentAGI",
        )


@dataclass
class BatchTestConfig:
    """Configuration for a single test in a batch."""

    cve_ids: List[str] = field(default_factory=list)
    target_urls: List[str] = field(default_factory=list)
    context: Dict[str, Any] = field(default_factory=dict)


async def run_batch_micro_pentests(
    test_configs: List[BatchTestConfig],
    config: Optional[MicroPentestConfig] = None,
) -> Dict[str, Any]:
    """Run multiple micro penetration tests in parallel.

    Args:
        test_configs: List of test configurations
        config: Optional configuration (uses defaults if not provided)

    Returns:
        Dictionary with batch results
    """
    if config is None:
        config = MicroPentestConfig()

    if not test_configs:
        return {
            "status": "error",
            "error": "At least one test configuration is required",
            "total": 0,
            "successful": 0,
            "failed": 0,
            "results": [],
        }

    logger.info("micro_pentest.batch_start", count=len(test_configs))

    # Run tests in parallel
    tasks = [
        run_micro_pentest(
            cve_ids=tc.cve_ids,
            target_urls=tc.target_urls,
            context=tc.context,
            config=config,
        )
        for tc in test_configs
    ]

    results = await asyncio.gather(*tasks, return_exceptions=True)

    successful = [
        r
        for r in results
        if isinstance(r, MicroPentestResult) and r.status == "started"
    ]
    failed = [
        r
        for r in results
        if isinstance(r, Exception)
        or (isinstance(r, MicroPentestResult) and r.status == "error")
    ]

    return {
        "status": "completed",
        "total": len(test_configs),
        "successful": len(successful),
        "failed": len(failed),
        "results": [
            r.to_dict()
            if isinstance(r, MicroPentestResult)
            else {"status": "error", "error": str(r)}
            for r in results
        ],
    }


__all__ = [
    "MicroPentestConfig",
    "MicroPentestResult",
    "MicroPentestStatus",
    "BatchTestConfig",
    "run_micro_pentest",
    "get_micro_pentest_status",
    "run_batch_micro_pentests",
]
