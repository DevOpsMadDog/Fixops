"""Core micro penetration test functionality for PentAGI integration.

This module provides the shared business logic for micropentests, used by both
the main API router and the enterprise API router.
"""

from __future__ import annotations

import asyncio
import os
import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse

import httpx
import structlog

logger = structlog.get_logger(__name__)

# Maximum context size to prevent accidentally sending large payloads
MAX_CONTEXT_SIZE = 10000  # 10KB limit

# CVE ID pattern for validation
CVE_PATTERN = re.compile(r"^CVE-\d{4}-\d{4,}$", re.IGNORECASE)

# Allowed URL schemes for target URLs
ALLOWED_URL_SCHEMES = {"http", "https"}


def _validate_cve_id(cve_id: str) -> bool:
    """Validate CVE ID format to prevent prompt injection."""
    return bool(CVE_PATTERN.match(cve_id))


def _validate_target_url(url: str) -> bool:
    """Validate target URL to prevent SSRF attacks.

    Only allows http/https schemes and rejects internal/private IPs.
    """
    try:
        parsed = urlparse(url)
        if parsed.scheme not in ALLOWED_URL_SCHEMES:
            return False
        if not parsed.netloc:
            return False
        # Block localhost and common internal hostnames
        hostname = parsed.hostname or ""
        if hostname in ("localhost", "127.0.0.1", "0.0.0.0", "::1"):
            return False
        # Block private IP ranges (basic check)
        if hostname.startswith(
            (
                "10.",
                "192.168.",
                "172.16.",
                "172.17.",
                "172.18.",
                "172.19.",
                "172.20.",
                "172.21.",
                "172.22.",
                "172.23.",
                "172.24.",
                "172.25.",
                "172.26.",
                "172.27.",
                "172.28.",
                "172.29.",
                "172.30.",
                "172.31.",
            )
        ):
            return False
        return True
    except Exception:
        return False


def _sanitize_context(context: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
    """Validate and sanitize context to prevent oversized payloads."""
    if context is None:
        return None
    import json

    try:
        serialized = json.dumps(context)
        if len(serialized) > MAX_CONTEXT_SIZE:
            logger.warning(
                "micro_pentest.context_too_large",
                size=len(serialized),
                max_size=MAX_CONTEXT_SIZE,
            )
            return {
                "error": "Context too large, truncated",
                "original_size": len(serialized),
            }
        return context
    except (TypeError, ValueError):
        return {"error": "Context could not be serialized"}


@dataclass
class MicroPentestConfig:
    """Configuration for micro penetration tests."""

    pentagi_url: str = field(
        default_factory=lambda: os.environ.get(
            "PENTAGI_BASE_URL", "https://pentagi:8443"
        )
    )
    verify_ssl: bool = field(
        default_factory=lambda: os.environ.get("PENTAGI_VERIFY_SSL", "false").lower() == "true"
    )
    timeout_seconds: float = 300.0  # 5 minutes for pen tests
    provider: str = "openai"  # Default LLM provider


@dataclass
class MicroPentestResult:
    """Result of a micro penetration test."""

    status: str
    flow_id: Optional[int] = None
    cve_ids: List[str] = field(default_factory=list)
    target_urls: List[str] = field(default_factory=list)
    message: str = ""
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        result: Dict[str, Any] = {
            "status": self.status,
            "cve_ids": self.cve_ids,
            "target_urls": self.target_urls,
            "message": self.message,
        }
        if self.flow_id is not None:
            result["flow_id"] = self.flow_id
        if self.error:
            result["error"] = self.error
        return result


@dataclass
class MicroPentestStatus:
    """Status of a micro penetration test flow."""

    flow_id: int
    status: str
    progress: int = 0
    tasks: List[Dict[str, Any]] = field(default_factory=list)
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        result = {
            "flow_id": self.flow_id,
            "status": self.status,
            "progress": self.progress,
            "tasks": self.tasks,
        }
        if self.error:
            result["error"] = self.error
        return result


def _get_pentagi_client(config: MicroPentestConfig) -> httpx.AsyncClient:
    """Get PentAGI API client."""
    return httpx.AsyncClient(
        base_url=config.pentagi_url,
        timeout=config.timeout_seconds,
        verify=config.verify_ssl,  # Self-signed certs need verify=False
    )


async def run_micro_pentest(
    cve_ids: List[str],
    target_urls: List[str],
    context: Optional[Dict[str, Any]] = None,
    config: Optional[MicroPentestConfig] = None,
) -> MicroPentestResult:
    """Run micro penetration tests for selected CVEs using PentAGI.

    Args:
        cve_ids: List of CVE IDs to test
        target_urls: List of target URLs to test against
        context: Optional context information for the test
        config: Optional configuration (uses defaults if not provided)

    Returns:
        MicroPentestResult with status and flow_id if successful
    """
    if config is None:
        config = MicroPentestConfig()

    if not cve_ids:
        return MicroPentestResult(
            status="error",
            error="At least one CVE ID is required",
        )

    if not target_urls:
        return MicroPentestResult(
            status="error",
            error="At least one target URL is required",
        )

    # Validate CVE IDs to prevent prompt injection
    invalid_cves = [cve for cve in cve_ids if not _validate_cve_id(cve)]
    if invalid_cves:
        return MicroPentestResult(
            status="error",
            error=f"Invalid CVE ID format: {', '.join(invalid_cves[:3])}. Expected format: CVE-YYYY-NNNNN",
        )

    # Validate target URLs to prevent SSRF
    invalid_urls = [url for url in target_urls if not _validate_target_url(url)]
    if invalid_urls:
        return MicroPentestResult(
            status="error",
            error=f"Invalid or blocked target URL: {invalid_urls[0]}. Only http/https URLs to external hosts allowed.",
        )

    # Sanitize context to prevent oversized payloads
    sanitized_context = _sanitize_context(context)

    logger.info(
        "micro_pentest.start",
        cve_count=len(cve_ids),
        target_count=len(target_urls),
        cve_ids=cve_ids[:5],  # Log first 5 CVEs
    )

    # Prepare PentAGI flow request
    pentagi_payload: Dict[str, Any] = {
        "input": (
            f"Perform micro penetration tests for CVEs: {', '.join(cve_ids)}. "
            f"Target URLs: {', '.join(target_urls)}. "
            f"Focus on verifying exploitability and impact assessment. "
            f"Test each CVE individually and provide detailed findings."
        ),
        "provider": config.provider,
        "functions": {
            "disabled": [],
            "functions": [],
        },
    }

    # Add context if provided
    if sanitized_context:
        pentagi_payload["context"] = sanitized_context

    try:
        async with _get_pentagi_client(config) as client:
            response = await client.post(
                "/api/v1/flows",
                json=pentagi_payload,
                headers={"Content-Type": "application/json"},
            )

            if response.status_code != 201:
                logger.warning(
                    "micro_pentest.pentagi_error_fallback",
                    status_code=response.status_code,
                    response_text=response.text[:200] if response.text else "",
                    message="PentAGI returned error, falling back to built-in scanner",
                )
                # Fallback to built-in scanner when PentAGI returns errors
                return await _run_builtin_vulnerability_scan(cve_ids, target_urls)

            # PentAGI returns: { "data": { "id": ..., ... } } or { "id": ..., ... }
            flow_data = response.json()
            flow_obj = flow_data.get("data", flow_data)
            flow_id = flow_obj.get("id") or flow_obj.get("flow_id")

            # Validate flow_id was returned
            if flow_id is None:
                logger.error(
                    "micro_pentest.missing_flow_id",
                    response_data=flow_data,
                )
                return MicroPentestResult(
                    status="error",
                    cve_ids=cve_ids,
                    target_urls=target_urls,
                    error="PentAGI response missing flow_id",
                )

            logger.info("micro_pentest.flow_created", flow_id=flow_id)

            return MicroPentestResult(
                status="started",
                flow_id=flow_id,
                cve_ids=cve_ids,
                target_urls=target_urls,
                message=f"Micro penetration test started for {len(cve_ids)} CVEs",
            )

    except httpx.TimeoutException:
        logger.error("micro_pentest.timeout")
        return MicroPentestResult(
            status="error",
            cve_ids=cve_ids,
            target_urls=target_urls,
            error="PentAGI request timeout",
        )
    except httpx.RequestError as e:
        logger.warning(
            "micro_pentest.pentagi_unavailable",
            exc_info=e,
            message="Falling back to built-in real scanner",
        )
        # Fallback to built-in real scanner when PentAGI is unavailable
        return await _run_builtin_vulnerability_scan(cve_ids, target_urls)


async def _run_builtin_vulnerability_scan(
    cve_ids: List[str],
    target_urls: List[str],
) -> MicroPentestResult:
    """Run vulnerability scan using built-in real scanner as fallback.

    This is used when PentAGI is unavailable but we still want to provide
    real vulnerability scanning capabilities including CVE-specific testing.
    """
    try:
        from core.cve_tester import CVEVulnerabilityTester
        from core.real_scanner import get_real_vuln_scanner

        all_findings = []
        cve_results = []
        
        # Run CVE-specific tests
        cve_tester = CVEVulnerabilityTester(timeout=30.0, verify_ssl=False)
        cve_test_results = await cve_tester.test_multiple_cves(cve_ids, target_urls)
        
        for result in cve_test_results:
            cve_results.append({
                "cve_id": result.cve_id,
                "target_url": result.target_url,
                "vulnerable": result.vulnerable,
                "confidence": result.confidence,
                "severity": result.severity,
                "cvss_score": result.cvss_score,
                "description": result.description,
                "remediation": result.remediation,
                "test_method": result.test_method,
                "evidence": result.evidence,
            })
            
            if result.vulnerable:
                all_findings.append({
                    "type": "cve_vulnerability",
                    "cve_id": result.cve_id,
                    "target": result.target_url,
                    "severity": result.severity,
                    "confidence": result.confidence,
                    "description": result.description,
                })

        # Also run general vulnerability scan
        scanner = get_real_vuln_scanner()
        for target_url in target_urls:
            try:
                # Run real HTTP-based vulnerability scan
                findings = await asyncio.get_event_loop().run_in_executor(
                    None, scanner.scan_target, target_url
                )
                for finding in findings:
                    finding["cve_ids"] = cve_ids
                    all_findings.append(finding)
            except Exception as scan_error:
                logger.warning(
                    "micro_pentest.target_scan_error",
                    target=target_url,
                    error=str(scan_error),
                )

        # Generate a tracking flow_id
        import random
        flow_id = random.randint(100000, 999999)
        
        # Count vulnerable CVEs
        vulnerable_cves = [r for r in cve_results if r.get("vulnerable")]

        return MicroPentestResult(
            status="completed",
            flow_id=flow_id,
            cve_ids=cve_ids,
            target_urls=target_urls,
            message=(
                f"CVE testing completed: {len(vulnerable_cves)}/{len(cve_ids)} CVEs potentially vulnerable, "
                f"{len(all_findings)} total findings (PentAGI unavailable, using built-in CVE tester)"
            ),
        )

    except ImportError as ie:
        logger.error("micro_pentest.scanner_import_error", error=str(ie))
        return MicroPentestResult(
            status="error",
            cve_ids=cve_ids,
            target_urls=target_urls,
            error="Built-in scanner not available and PentAGI unreachable",
        )
    except Exception as e:
        logger.error("micro_pentest.builtin_scan_error", exc_info=e)
        return MicroPentestResult(
            status="error",
            cve_ids=cve_ids,
            target_urls=target_urls,
            error=f"Built-in scan failed: {str(e)}",
        )


async def get_micro_pentest_status(
    flow_id: int,
    config: Optional[MicroPentestConfig] = None,
) -> MicroPentestStatus:
    """Get status of a micro penetration test flow.

    Args:
        flow_id: The PentAGI flow ID
        config: Optional configuration (uses defaults if not provided)

    Returns:
        MicroPentestStatus with current status and progress
    """
    if config is None:
        config = MicroPentestConfig()

    try:
        async with _get_pentagi_client(config) as client:
            response = await client.get(f"/api/v1/flows/{flow_id}")

            if response.status_code != 200:
                return MicroPentestStatus(
                    flow_id=flow_id,
                    status="error",
                    error=f"Failed to get flow status: {response.text}",
                )

            flow_data = response.json()
            return MicroPentestStatus(
                flow_id=flow_id,
                status=flow_data.get("status", "unknown"),
                progress=flow_data.get("progress", 0),
                tasks=flow_data.get("tasks", []),
            )

    except httpx.RequestError as e:
        logger.error("micro_pentest.status_error", flow_id=flow_id, exc_info=e)
        return MicroPentestStatus(
            flow_id=flow_id,
            status="error",
            error="Failed to connect to PentAGI",
        )


@dataclass
class BatchTestConfig:
    """Configuration for a single test in a batch."""

    cve_ids: List[str] = field(default_factory=list)
    target_urls: List[str] = field(default_factory=list)
    context: Dict[str, Any] = field(default_factory=dict)


async def run_batch_micro_pentests(
    test_configs: List[BatchTestConfig],
    config: Optional[MicroPentestConfig] = None,
) -> Dict[str, Any]:
    """Run multiple micro penetration tests in parallel.

    Args:
        test_configs: List of test configurations
        config: Optional configuration (uses defaults if not provided)

    Returns:
        Dictionary with batch results
    """
    if config is None:
        config = MicroPentestConfig()

    if not test_configs:
        return {
            "status": "error",
            "error": "At least one test configuration is required",
            "total": 0,
            "successful": 0,
            "failed": 0,
            "results": [],
        }

    logger.info("micro_pentest.batch_start", count=len(test_configs))

    # Run tests in parallel
    tasks = [
        run_micro_pentest(
            cve_ids=tc.cve_ids,
            target_urls=tc.target_urls,
            context=tc.context,
            config=config,
        )
        for tc in test_configs
    ]

    results = await asyncio.gather(*tasks, return_exceptions=True)

    successful = [
        r
        for r in results
        if isinstance(r, MicroPentestResult) and r.status == "started"
    ]
    failed = [
        r
        for r in results
        if isinstance(r, Exception)
        or (isinstance(r, MicroPentestResult) and r.status == "error")
    ]

    return {
        "status": "completed",
        "total": len(test_configs),
        "successful": len(successful),
        "failed": len(failed),
        "results": [
            r.to_dict()
            if isinstance(r, MicroPentestResult)
            else {"status": "error", "error": str(r)}
            for r in results
        ],
    }


__all__ = [
    "MicroPentestConfig",
    "MicroPentestResult",
    "MicroPentestStatus",
    "BatchTestConfig",
    "run_micro_pentest",
    "get_micro_pentest_status",
    "run_batch_micro_pentests",
]
