"""Exploit signal evaluation utilities derived from overlay configuration."""

from __future__ import annotations

import atexit
import json
import logging
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping, Optional, Tuple

import requests
from requests import RequestException
from requests.adapters import HTTPAdapter
from urllib3.util import Retry

from apps.api.normalizers import CVERecordSummary, NormalizedCVEFeed
from core.configuration import OverlayConfig, load_overlay
from core.paths import ensure_secure_directory


logger = logging.getLogger(__name__)
_DEFAULT_TRUTHY = {True, "true", "yes", "1", 1}


def _iter_dict(data: Mapping[str, Any], path: Iterable[str]) -> Optional[Any]:
    value: Any = data
    for key in path:
        if not isinstance(value, Mapping):
            return None
        value = value.get(key)
    return value


def _extract_value(record: CVERecordSummary, fields: Iterable[str]) -> Optional[Any]:
    """Return the first non-null value for a list of candidate field paths."""

    for field in fields:
        if not field:
            continue
        segments = [segment for segment in str(field).split(".") if segment]
        if not segments:
            continue
        value = _iter_dict(record.raw, segments)
        if value is not None:
            return value
    return None


@dataclass
class ExploitSignal:
    """Configuration for a specific exploit signal."""

    identifier: str
    label: str
    mode: str
    fields: tuple[str, ...]
    threshold: Optional[float] = None
    truthy: Optional[set[Any]] = None
    severity_floor: Optional[str] = None
    escalate_to: Optional[str] = None
    rationale: Optional[str] = None

    @classmethod
    def from_mapping(
        cls, identifier: str, mapping: Mapping[str, Any]
    ) -> "ExploitSignal":
        label = str(mapping.get("label") or identifier)
        mode = str(mapping.get("mode") or "probability").lower()
        fields_raw = mapping.get("fields") or []
        if isinstance(fields_raw, str):
            fields = (fields_raw,)
        else:
            fields = tuple(str(field) for field in fields_raw if str(field).strip())
        threshold_value = mapping.get("threshold")
        try:
            threshold = float(threshold_value) if threshold_value is not None else None
        except (TypeError, ValueError):
            threshold = None
        truthy_raw = mapping.get("truthy")
        truthy = None
        if isinstance(truthy_raw, Iterable) and not isinstance(
            truthy_raw, (str, bytes)
        ):
            truthy = {value for value in truthy_raw}
        severity_floor = mapping.get("severity_floor")
        escalate_to = mapping.get("escalate_to")
        rationale = mapping.get("rationale")
        return cls(
            identifier=identifier,
            label=label,
            mode=mode,
            fields=fields,
            threshold=threshold,
            truthy=truthy,
            severity_floor=str(severity_floor).lower() if severity_floor else None,
            escalate_to=str(escalate_to).lower() if escalate_to else None,
            rationale=str(rationale) if rationale else None,
        )

    def evaluate(self, record: CVERecordSummary) -> Optional[Dict[str, Any]]:
        """Return a match description if the record meets the configured condition."""

        if not self.fields:
            return None
        value = _extract_value(record, self.fields)
        if value is None:
            return None

        match: Optional[Dict[str, Any]] = None
        if self.mode == "boolean":
            truthy = self.truthy or _DEFAULT_TRUTHY
            if value in truthy or (
                isinstance(value, str) and value.lower() in {"true", "yes"}
            ):
                match = {"value": value, "comparison": "truthy"}
        else:  # default probability comparison
            try:
                numeric_value = float(value)
            except (TypeError, ValueError):
                return None
            if self.threshold is not None and numeric_value >= self.threshold:
                match = {
                    "value": numeric_value,
                    "comparison": ">=",
                    "threshold": self.threshold,
                }

        if match is None:
            return None

        match["cve_id"] = record.cve_id
        match["title"] = record.title
        if self.severity_floor:
            match["severity_floor"] = self.severity_floor
        if self.escalate_to:
            match["escalate_to"] = self.escalate_to
        return match


class ExploitSignalEvaluator:
    """Aggregate exploitability insights from CVE feeds."""

    def __init__(self, settings: Mapping[str, Any]):
        signals_config = (
            settings.get("signals") if isinstance(settings, Mapping) else None
        )
        self.signals: Dict[str, ExploitSignal] = {}
        if isinstance(signals_config, Mapping):
            for identifier, payload in signals_config.items():
                if isinstance(payload, Mapping):
                    signal = ExploitSignal.from_mapping(str(identifier), payload)
                    if signal.fields:
                        self.signals[signal.identifier] = signal
        self.metadata = {k: v for k, v in settings.items() if k != "signals"}
        refreshed = self.metadata.get("last_refreshed")
        self.last_refreshed: Optional[datetime]
        if isinstance(refreshed, str):
            try:
                self.last_refreshed = datetime.fromisoformat(
                    refreshed.replace("Z", "+00:00")
                )
            except ValueError:
                self.last_refreshed = None
        else:
            self.last_refreshed = None
        max_age = self.metadata.get("max_age_days", 14)
        try:
            self.max_age_days = int(max_age)
        except (TypeError, ValueError):
            self.max_age_days = 14

    def evaluate(self, cve_feed: NormalizedCVEFeed) -> Optional[Dict[str, Any]]:
        if not self.signals:
            return None

        overview = {
            "signals_configured": len(self.signals),
            "records_evaluated": len(cve_feed.records),
            "matched_records": 0,
        }
        signals_summary: Dict[str, Dict[str, Any]] = {}
        escalations: list[Dict[str, Any]] = []

        for identifier, signal in self.signals.items():
            summary = {
                "label": signal.label,
                "matches": [],
                "match_count": 0,
            }
            if signal.threshold is not None:
                summary["threshold"] = signal.threshold
            if signal.mode == "boolean":
                summary["mode"] = "boolean"
            else:
                summary["mode"] = "probability"
            if signal.rationale:
                summary["rationale"] = signal.rationale

            for record in cve_feed.records:
                result = signal.evaluate(record)
                if not result:
                    continue
                summary["matches"].append(result)
                summary["match_count"] += 1
                overview["matched_records"] += 1
                if result.get("escalate_to") or result.get("severity_floor"):
                    escalations.append(
                        {
                            "cve_id": record.cve_id,
                            "signal": identifier,
                            "recommended_severity": result.get("escalate_to")
                            or result.get("severity_floor"),
                        }
                    )

            signals_summary[identifier] = summary

        status = "fresh"
        warnings: list[str] = []
        if self.last_refreshed is not None:
            now = datetime.now(timezone.utc)
            delta: timedelta = now - self.last_refreshed
            overview["last_refreshed"] = self.last_refreshed.isoformat()
            overview["age_days"] = round(delta.total_seconds() / 86400, 2)
            if delta > timedelta(days=self.max_age_days):
                status = "stale"
                warnings.append(
                    "Exploit signal thresholds exceed configured max age; refresh feeds to maintain accuracy."
                )
        overview["status"] = status

        payload: Dict[str, Any] = {
            "overview": overview,
            "signals": signals_summary,
        }
        if escalations:
            payload["escalations"] = escalations
        if self.metadata:
            payload["metadata"] = self.metadata
        if warnings:
            payload["warnings"] = warnings
        return payload


class ExploitFeedRefresher:
    """Auto-refresh exploit feeds and annotate CVE records when stale."""

    def __init__(self, overlay: "OverlayConfig") -> None:
        self.overlay = overlay
        settings = overlay.exploit_signals or {}
        refresh = (
            settings.get("auto_refresh") if isinstance(settings, Mapping) else None
        )
        self.enabled = bool(refresh and refresh.get("enabled", True))
        self.refresh_interval_hours = (
            int(refresh.get("refresh_interval_hours", 24))
            if isinstance(refresh, Mapping)
            else 24
        )
        self.feeds: List[Dict[str, Any]] = []
        if isinstance(refresh, Mapping):
            entries = refresh.get("feeds")
            if isinstance(entries, Iterable):
                for entry in entries:
                    if not isinstance(entry, Mapping):
                        continue
                    spec = self._normalise_feed_spec(entry)
                    if spec:
                        self.feeds.append(spec)

        directories = overlay.data_directories
        feeds_dir = directories.get("feeds_dir")
        if feeds_dir is None:
            root = (
                overlay.allowed_data_roots[0]
                if overlay.allowed_data_roots
                else Path("data").resolve()
            )
            feeds_dir = (root / "feeds" / overlay.mode).resolve()
            directories["feeds_dir"] = feeds_dir
        self.feeds_dir = ensure_secure_directory(feeds_dir)
        self.session = requests.Session()
        self._configure_session()

    def _configure_session(self) -> None:
        retry = Retry(
            total=3,
            backoff_factor=0.5,
            status_forcelist=(500, 502, 503, 504),
            allowed_methods=("GET",),
        )
        adapter = HTTPAdapter(max_retries=retry)
        self.session.mount("https://", adapter)
        self.session.mount("http://", adapter)

    def _normalise_feed_spec(
        self, mapping: Mapping[str, Any]
    ) -> Optional[Dict[str, Any]]:
        identifier = str(mapping.get("id") or mapping.get("name") or "").strip()
        if not identifier:
            return None
        url = mapping.get("url")
        path = mapping.get("path")
        destination = mapping.get("destination") or mapping.get("dest")
        cve_field = str(mapping.get("cve_field") or "cveID")
        score_field = mapping.get("score_field")
        mark_exploited = bool(mapping.get("mark_exploited"))
        attributes = (
            mapping.get("attributes")
            if isinstance(mapping.get("attributes"), Mapping)
            else {}
        )
        timeout = float(mapping.get("timeout", 10.0) or 10.0)

        spec: Dict[str, Any] = {
            "id": identifier,
            "url": str(url) if url else None,
            "path": str(path) if path else None,
            "destination": str(destination) if destination else None,
            "cve_field": cve_field,
            "score_field": str(score_field) if score_field else None,
            "mark_exploited": mark_exploited,
            "attributes": dict(attributes),
            "timeout": timeout,
        }
        return spec

    def _needs_refresh(self, last_refreshed: Optional[datetime]) -> bool:
        if last_refreshed is None:
            return True
        threshold = datetime.now(timezone.utc) - timedelta(
            hours=self.refresh_interval_hours
        )
        return last_refreshed < threshold

    def refresh(
        self,
        cve_feed: NormalizedCVEFeed,
        last_refreshed: Optional[datetime],
    ) -> Optional[Dict[str, Any]]:
        if not self.enabled or not self.feeds:
            return None
        if not self._needs_refresh(last_refreshed):
            return {"status": "fresh", "feeds": []}

        refreshed_at = datetime.now(timezone.utc)
        feed_summaries: List[Dict[str, Any]] = []
        for spec in self.feeds:
            summary = self._apply_feed(spec, cve_feed)
            feed_summaries.append(summary)

        success = any(summary.get("status") == "loaded" for summary in feed_summaries)
        payload: Dict[str, Any] = {"feeds": feed_summaries}
        if success:
            cve_feed.metadata.setdefault("auto_refresh", {})
            cve_feed.metadata["auto_refresh"].update(
                {
                    "refreshed_at": refreshed_at.isoformat(),
                    "feeds": [s.get("id") for s in feed_summaries],
                }
            )
            self.overlay.exploit_signals["last_refreshed"] = (
                refreshed_at.isoformat().replace("+00:00", "Z")
            )
            payload["status"] = "refreshed"
            payload["refreshed_at"] = refreshed_at.isoformat()
        else:
            payload["status"] = "failed"
        return payload

    def _read_destination(self, destination: Optional[str]) -> Optional[Path]:
        if not destination:
            return None
        path = Path(destination)
        if not path.is_absolute():
            path = (self.feeds_dir / path).resolve()
        ensure_secure_directory(path.parent)
        return path

    def _load_feed_data(
        self, spec: Mapping[str, Any]
    ) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        raw_payload: Optional[str] = None
        destination_path = self._read_destination(spec.get("destination"))
        if spec.get("path"):
            path = Path(str(spec["path"]))
            if not path.is_absolute():
                path = (self.feeds_dir / path).resolve()
            if path.exists():
                raw_payload = path.read_text(encoding="utf-8")
        elif spec.get("url"):
            try:
                response = self.session.get(
                    spec["url"], timeout=spec.get("timeout", 10.0)
                )
                response.raise_for_status()
                raw_payload = response.text
            except (
                RequestException
            ) as exc:  # pragma: no cover - network failure surface
                return [], {
                    "id": spec.get("id"),
                    "status": "failed",
                    "error": str(exc),
                    "source": spec.get("url"),
                }
        if raw_payload is None:
            return [], {
                "id": spec.get("id"),
                "status": "skipped",
                "reason": "no data retrieved",
            }

        if destination_path:
            ensure_secure_directory(destination_path.parent)
            destination_path.write_text(raw_payload, encoding="utf-8")

        try:
            parsed = json.loads(raw_payload)
        except json.JSONDecodeError:
            return [], {
                "id": spec.get("id"),
                "status": "failed",
                "error": "invalid json payload",
            }

        entries: List[Dict[str, Any]] = []
        if isinstance(parsed, list):
            entries = [entry for entry in parsed if isinstance(entry, Mapping)]  # type: ignore[list-item]
        elif isinstance(parsed, Mapping):
            for key in ("vulnerabilities", "cves", "items", "data"):
                candidate = parsed.get(key)
                if isinstance(candidate, list):
                    entries = [entry for entry in candidate if isinstance(entry, Mapping)]  # type: ignore[list-item]
                    break
            else:
                entries = [parsed] if parsed else []

        metadata = {
            "id": spec.get("id"),
            "status": "loaded",
            "entry_count": len(entries),
        }
        source = spec.get("url") or spec.get("path")
        if source:
            metadata["source"] = source
        if destination_path:
            metadata["stored_at"] = str(destination_path)
        return entries, metadata

    def _apply_feed(
        self, spec: Mapping[str, Any], cve_feed: NormalizedCVEFeed
    ) -> Dict[str, Any]:
        entries, metadata = self._load_feed_data(spec)
        if metadata.get("status") != "loaded":
            return metadata

        cve_field = str(spec.get("cve_field") or "cveID")
        score_field = spec.get("score_field")
        mark_exploited = bool(spec.get("mark_exploited"))
        attributes = (
            spec.get("attributes")
            if isinstance(spec.get("attributes"), Mapping)
            else {}
        )

        matched = 0
        for entry in entries:
            cve_id = self._extract_cve_id(entry, cve_field)
            if not cve_id:
                continue
            score_value = (
                self._extract_nested_value(entry, score_field) if score_field else None
            )
            for record in cve_feed.records:
                if record.cve_id.lower() != cve_id.lower():
                    continue
                record.raw.setdefault(spec.get("id"), {})
                if isinstance(attributes, Mapping):
                    record.raw[spec.get("id")].update(attributes)
                if score_value is not None:
                    record.raw[spec.get("id")]["score"] = score_value
                if mark_exploited:
                    record.exploited = True
                matched += 1

        metadata["matched"] = matched
        return metadata

    @staticmethod
    def _extract_nested_value(
        entry: Mapping[str, Any], field: Optional[str]
    ) -> Optional[Any]:
        if not field:
            return None
        segments = [segment for segment in str(field).split(".") if segment]
        value: Any = entry
        for segment in segments:
            if not isinstance(value, Mapping):
                return None
            value = value.get(segment)
            if value is None:
                return None
        return value

    @staticmethod
    def _extract_cve_id(entry: Mapping[str, Any], field: str) -> Optional[str]:
        value = entry.get(field)
        if isinstance(value, str) and value:
            return value
        for fallback in ("cve", "cve_id", "cveId", "cveID"):
            alt = entry.get(fallback)
            if isinstance(alt, str) and alt:
                return alt
        return None


def _refresh_named_feed(overlay: OverlayConfig, feed_id: str) -> Dict[str, Any]:
    refresher = ExploitFeedRefresher(overlay)
    specs = [spec for spec in refresher.feeds if spec.get("id") == feed_id]
    if not specs:
        return {"status": "skipped", "reason": f"feed '{feed_id}' not configured"}
    refresher.feeds = specs
    dummy_feed = NormalizedCVEFeed(records=[], errors=[], metadata={})
    result = refresher.refresh(dummy_feed, last_refreshed=None)
    if not result:
        return {"status": "skipped", "reason": "refresh disabled"}
    return result


def load_latest_kev_feed(overlay: Optional[OverlayConfig] = None) -> Dict[str, Any]:
    instance = overlay or load_overlay()
    return _refresh_named_feed(instance, "kev")


def load_latest_epss_feed(overlay: Optional[OverlayConfig] = None) -> Dict[str, Any]:
    instance = overlay or load_overlay()
    return _refresh_named_feed(instance, "epss")


def refresh_exploit_feeds() -> None:
    overlay = load_overlay()
    try:
        kev_result = load_latest_kev_feed(overlay)
        epss_result = load_latest_epss_feed(overlay)
        logger.info(
            "Exploit feeds refreshed", extra={"kev": kev_result, "epss": epss_result}
        )
    except Exception:  # pragma: no cover - defensive logging
        logger.exception("Feed refresh failed")


def _start_scheduler() -> None:
    try:
        from apscheduler.schedulers.background import BackgroundScheduler
    except Exception as exc:  # pragma: no cover - optional dependency
        logger.warning("APScheduler unavailable or failed: %s; skipping scheduler", exc)
        return

    scheduler = BackgroundScheduler()
    scheduler.add_job(
        refresh_exploit_feeds, "interval", hours=24, max_instances=1, coalesce=True
    )
    scheduler.start()
    atexit.register(lambda: scheduler.shutdown(wait=False))
    logger.info("Exploit feed scheduler started (24h interval).")


_start_scheduler()


__all__ = [
    "ExploitSignalEvaluator",
    "ExploitFeedRefresher",
    "refresh_exploit_feeds",
    "load_latest_kev_feed",
    "load_latest_epss_feed",
]
