"""Exploit signal evaluation utilities derived from overlay configuration."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Iterable, Mapping, Optional

from backend.normalizers import CVERecordSummary, NormalizedCVEFeed


_DEFAULT_TRUTHY = {True, "true", "yes", "1", 1}


def _iter_dict(data: Mapping[str, Any], path: Iterable[str]) -> Optional[Any]:
    value: Any = data
    for key in path:
        if not isinstance(value, Mapping):
            return None
        value = value.get(key)
    return value


def _extract_value(record: CVERecordSummary, fields: Iterable[str]) -> Optional[Any]:
    """Return the first non-null value for a list of candidate field paths."""

    for field in fields:
        if not field:
            continue
        segments = [segment for segment in str(field).split(".") if segment]
        if not segments:
            continue
        value = _iter_dict(record.raw, segments)
        if value is not None:
            return value
    return None


@dataclass
class ExploitSignal:
    """Configuration for a specific exploit signal."""

    identifier: str
    label: str
    mode: str
    fields: tuple[str, ...]
    threshold: Optional[float] = None
    truthy: Optional[set[Any]] = None
    severity_floor: Optional[str] = None
    escalate_to: Optional[str] = None
    rationale: Optional[str] = None

    @classmethod
    def from_mapping(cls, identifier: str, mapping: Mapping[str, Any]) -> "ExploitSignal":
        label = str(mapping.get("label") or identifier)
        mode = str(mapping.get("mode") or "probability").lower()
        fields_raw = mapping.get("fields") or []
        if isinstance(fields_raw, str):
            fields = (fields_raw,)
        else:
            fields = tuple(str(field) for field in fields_raw if str(field).strip())
        threshold_value = mapping.get("threshold")
        try:
            threshold = float(threshold_value) if threshold_value is not None else None
        except (TypeError, ValueError):
            threshold = None
        truthy_raw = mapping.get("truthy")
        truthy = None
        if isinstance(truthy_raw, Iterable) and not isinstance(truthy_raw, (str, bytes)):
            truthy = {value for value in truthy_raw}
        severity_floor = mapping.get("severity_floor")
        escalate_to = mapping.get("escalate_to")
        rationale = mapping.get("rationale")
        return cls(
            identifier=identifier,
            label=label,
            mode=mode,
            fields=fields,
            threshold=threshold,
            truthy=truthy,
            severity_floor=str(severity_floor).lower() if severity_floor else None,
            escalate_to=str(escalate_to).lower() if escalate_to else None,
            rationale=str(rationale) if rationale else None,
        )

    def evaluate(self, record: CVERecordSummary) -> Optional[Dict[str, Any]]:
        """Return a match description if the record meets the configured condition."""

        if not self.fields:
            return None
        value = _extract_value(record, self.fields)
        if value is None:
            return None

        match: Optional[Dict[str, Any]] = None
        if self.mode == "boolean":
            truthy = self.truthy or _DEFAULT_TRUTHY
            if value in truthy or (isinstance(value, str) and value.lower() in {"true", "yes"}):
                match = {"value": value, "comparison": "truthy"}
        else:  # default probability comparison
            try:
                numeric_value = float(value)
            except (TypeError, ValueError):
                return None
            if self.threshold is not None and numeric_value >= self.threshold:
                match = {"value": numeric_value, "comparison": ">=", "threshold": self.threshold}

        if match is None:
            return None

        match["cve_id"] = record.cve_id
        match["title"] = record.title
        if self.severity_floor:
            match["severity_floor"] = self.severity_floor
        if self.escalate_to:
            match["escalate_to"] = self.escalate_to
        return match


class ExploitSignalEvaluator:
    """Aggregate exploitability insights from CVE feeds."""

    def __init__(self, settings: Mapping[str, Any]):
        signals_config = settings.get("signals") if isinstance(settings, Mapping) else None
        self.signals: Dict[str, ExploitSignal] = {}
        if isinstance(signals_config, Mapping):
            for identifier, payload in signals_config.items():
                if isinstance(payload, Mapping):
                    signal = ExploitSignal.from_mapping(str(identifier), payload)
                    if signal.fields:
                        self.signals[signal.identifier] = signal
        self.metadata = {k: v for k, v in settings.items() if k != "signals"}

    def evaluate(self, cve_feed: NormalizedCVEFeed) -> Optional[Dict[str, Any]]:
        if not self.signals:
            return None

        overview = {
            "signals_configured": len(self.signals),
            "records_evaluated": len(cve_feed.records),
            "matched_records": 0,
        }
        signals_summary: Dict[str, Dict[str, Any]] = {}
        escalations: list[Dict[str, Any]] = []

        for identifier, signal in self.signals.items():
            summary = {
                "label": signal.label,
                "matches": [],
                "match_count": 0,
            }
            if signal.threshold is not None:
                summary["threshold"] = signal.threshold
            if signal.mode == "boolean":
                summary["mode"] = "boolean"
            else:
                summary["mode"] = "probability"
            if signal.rationale:
                summary["rationale"] = signal.rationale

            for record in cve_feed.records:
                result = signal.evaluate(record)
                if not result:
                    continue
                summary["matches"].append(result)
                summary["match_count"] += 1
                overview["matched_records"] += 1
                if result.get("escalate_to") or result.get("severity_floor"):
                    escalations.append(
                        {
                            "cve_id": record.cve_id,
                            "signal": identifier,
                            "recommended_severity": result.get("escalate_to")
                            or result.get("severity_floor"),
                        }
                    )

            signals_summary[identifier] = summary

        payload: Dict[str, Any] = {
            "overview": overview,
            "signals": signals_summary,
        }
        if escalations:
            payload["escalations"] = escalations
        if self.metadata:
            payload["metadata"] = self.metadata
        return payload


__all__ = ["ExploitSignalEvaluator"]
