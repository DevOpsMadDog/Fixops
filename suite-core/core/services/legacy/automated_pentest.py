"""
FixOps Automated Penetration Testing Service

This module provides a comprehensive automated penetration testing engine that
analyzes security findings, generates attack narratives, performs non-destructive
validation checks, and produces detailed remediation reports.

Security: All tests are defensive in nature - validating known vulnerabilities
rather than discovering new attack vectors. No arbitrary code execution.
"""

import asyncio
import hashlib
import json
import logging
import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class AttackPhase(str, Enum):
    """Phases of a penetration test."""

    RECONNAISSANCE = "reconnaissance"
    ENUMERATION = "enumeration"
    VULNERABILITY_ANALYSIS = "vulnerability_analysis"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    REPORTING = "reporting"


class VulnerabilityCategory(str, Enum):
    """Categories of vulnerabilities."""

    INJECTION = "injection"
    BROKEN_AUTH = "broken_authentication"
    SENSITIVE_DATA = "sensitive_data_exposure"
    XXE = "xml_external_entities"
    BROKEN_ACCESS = "broken_access_control"
    SECURITY_MISCONFIG = "security_misconfiguration"
    XSS = "cross_site_scripting"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    VULNERABLE_COMPONENTS = "vulnerable_components"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    SSRF = "server_side_request_forgery"
    CRYPTOGRAPHIC = "cryptographic_failures"
    BUSINESS_LOGIC = "business_logic"


class ExploitDifficulty(str, Enum):
    """Difficulty level for exploitation."""

    TRIVIAL = "trivial"
    EASY = "easy"
    MODERATE = "moderate"
    DIFFICULT = "difficult"
    EXPERT = "expert"


class ValidationStatus(str, Enum):
    """Status of vulnerability validation."""

    CONFIRMED = "confirmed"
    LIKELY = "likely"
    POSSIBLE = "possible"
    FALSE_POSITIVE = "false_positive"
    INCONCLUSIVE = "inconclusive"
    BLOCKED = "blocked"


@dataclass
class AttackVector:
    """Represents a potential attack vector."""

    id: str
    name: str
    category: VulnerabilityCategory
    description: str
    prerequisites: List[str] = field(default_factory=list)
    techniques: List[str] = field(default_factory=list)
    mitre_attack_ids: List[str] = field(default_factory=list)
    difficulty: ExploitDifficulty = ExploitDifficulty.MODERATE
    impact: str = "medium"
    cvss_score: float = 5.0


@dataclass
class AttackStep:
    """A single step in an attack chain."""

    phase: AttackPhase
    action: str
    description: str
    tool: str
    expected_output: str
    success_indicators: List[str] = field(default_factory=list)
    failure_indicators: List[str] = field(default_factory=list)
    duration_estimate_seconds: int = 30
    is_destructive: bool = False


@dataclass
class AttackNarrative:
    """Complete attack narrative for a vulnerability."""

    vulnerability_id: str
    title: str
    executive_summary: str
    attack_vectors: List[AttackVector]
    attack_chain: List[AttackStep]
    business_impact: str
    technical_impact: str
    likelihood: str
    risk_rating: str
    compliance_implications: List[str] = field(default_factory=list)
    mitigations: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)


@dataclass
class ValidationResult:
    """Result of a vulnerability validation."""

    vulnerability_id: str
    status: ValidationStatus
    confidence: float
    evidence: List[str]
    steps_executed: List[Dict[str, Any]]
    duration_seconds: float
    blocked_by: Optional[str] = None
    error: Optional[str] = None
    recommendations: List[str] = field(default_factory=list)


@dataclass
class PenTestReport:
    """Complete penetration test report."""

    id: str
    title: str
    executive_summary: str
    scope: Dict[str, Any]
    methodology: str
    findings: List[Dict[str, Any]]
    attack_narratives: List[AttackNarrative]
    validation_results: List[ValidationResult]
    risk_summary: Dict[str, Any]
    recommendations: List[Dict[str, Any]]
    compliance_mapping: Dict[str, List[str]]
    generated_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)


class VulnerabilityAnalyzer:
    """Analyzes vulnerabilities and generates attack vectors."""

    CATEGORY_PATTERNS = {
        VulnerabilityCategory.INJECTION: [
            r"sql.?injection",
            r"command.?injection",
            r"ldap.?injection",
            r"xpath.?injection",
            r"nosql.?injection",
            r"crlf.?injection",
            r"header.?injection",
        ],
        VulnerabilityCategory.XSS: [
            r"cross.?site.?scripting",
            r"xss",
            r"reflected.?xss",
            r"stored.?xss",
            r"dom.?xss",
        ],
        VulnerabilityCategory.BROKEN_AUTH: [
            r"authentication",
            r"session",
            r"credential",
            r"password",
            r"brute.?force",
            r"weak.?password",
        ],
        VulnerabilityCategory.SENSITIVE_DATA: [
            r"sensitive.?data",
            r"information.?disclosure",
            r"data.?exposure",
            r"pii",
            r"encryption",
        ],
        VulnerabilityCategory.BROKEN_ACCESS: [
            r"access.?control",
            r"authorization",
            r"privilege",
            r"idor",
            r"insecure.?direct",
        ],
        VulnerabilityCategory.SECURITY_MISCONFIG: [
            r"misconfiguration",
            r"default.?credential",
            r"unnecessary.?service",
            r"debug.?mode",
            r"verbose.?error",
        ],
        VulnerabilityCategory.VULNERABLE_COMPONENTS: [
            r"outdated",
            r"vulnerable.?component",
            r"cve-",
            r"known.?vulnerability",
            r"dependency",
        ],
        VulnerabilityCategory.SSRF: [
            r"ssrf",
            r"server.?side.?request",
            r"url.?redirect",
        ],
        VulnerabilityCategory.XXE: [
            r"xxe",
            r"xml.?external",
            r"xml.?injection",
        ],
        VulnerabilityCategory.INSECURE_DESERIALIZATION: [
            r"deserialization",
            r"object.?injection",
            r"pickle",
            r"yaml.?load",
        ],
        VulnerabilityCategory.CRYPTOGRAPHIC: [
            r"weak.?cipher",
            r"weak.?hash",
            r"md5",
            r"sha1",
            r"ssl",
            r"tls",
            r"certificate",
        ],
    }

    MITRE_ATTACK_MAPPING = {
        VulnerabilityCategory.INJECTION: ["T1190", "T1059"],
        VulnerabilityCategory.XSS: ["T1189", "T1059.007"],
        VulnerabilityCategory.BROKEN_AUTH: ["T1078", "T1110"],
        VulnerabilityCategory.SENSITIVE_DATA: ["T1552", "T1005"],
        VulnerabilityCategory.BROKEN_ACCESS: ["T1548", "T1068"],
        VulnerabilityCategory.SECURITY_MISCONFIG: ["T1574", "T1562"],
        VulnerabilityCategory.VULNERABLE_COMPONENTS: ["T1190", "T1195"],
        VulnerabilityCategory.SSRF: ["T1090", "T1071"],
        VulnerabilityCategory.XXE: ["T1059", "T1005"],
        VulnerabilityCategory.INSECURE_DESERIALIZATION: ["T1059", "T1055"],
        VulnerabilityCategory.CRYPTOGRAPHIC: ["T1557", "T1040"],
    }

    def categorize_vulnerability(
        self, finding: Dict[str, Any]
    ) -> VulnerabilityCategory:
        """Categorize a vulnerability based on its description and metadata."""
        text = " ".join(
            [
                str(finding.get("rule_id", "")),
                str(finding.get("description", "")),
                str(finding.get("message", "")),
                str(finding.get("name", "")),
            ]
        ).lower()

        for category, patterns in self.CATEGORY_PATTERNS.items():
            for pattern in patterns:
                if re.search(pattern, text, re.IGNORECASE):
                    return category

        return VulnerabilityCategory.SECURITY_MISCONFIG

    def calculate_difficulty(self, finding: Dict[str, Any]) -> ExploitDifficulty:
        """Calculate exploitation difficulty based on finding metadata."""
        severity = finding.get("severity", "medium").lower()
        cvss = finding.get("cvss_score", 5.0)

        if isinstance(cvss, str):
            try:
                cvss = float(cvss)
            except ValueError:
                cvss = 5.0

        if cvss >= 9.0 or severity == "critical":
            return ExploitDifficulty.TRIVIAL
        elif cvss >= 7.0 or severity == "high":
            return ExploitDifficulty.EASY
        elif cvss >= 5.0 or severity == "medium":
            return ExploitDifficulty.MODERATE
        elif cvss >= 3.0 or severity == "low":
            return ExploitDifficulty.DIFFICULT
        else:
            return ExploitDifficulty.EXPERT

    def generate_attack_vector(self, finding: Dict[str, Any]) -> AttackVector:
        """Generate an attack vector from a finding."""
        category = self.categorize_vulnerability(finding)
        difficulty = self.calculate_difficulty(finding)

        vector_id = hashlib.sha256(
            json.dumps(finding, sort_keys=True, default=str).encode()
        ).hexdigest()[:12]

        return AttackVector(
            id=f"AV-{vector_id}",
            name=finding.get("rule_id", finding.get("name", "Unknown")),
            category=category,
            description=finding.get("description", finding.get("message", "")),
            prerequisites=self._get_prerequisites(category),
            techniques=self._get_techniques(category),
            mitre_attack_ids=self.MITRE_ATTACK_MAPPING.get(category, []),
            difficulty=difficulty,
            impact=finding.get("severity", "medium"),
            cvss_score=float(finding.get("cvss_score", 5.0)),
        )

    def _get_prerequisites(self, category: VulnerabilityCategory) -> List[str]:
        """Get prerequisites for exploiting a vulnerability category."""
        prereqs = {
            VulnerabilityCategory.INJECTION: [
                "User input reaches database/command execution",
                "Input validation is insufficient or bypassable",
            ],
            VulnerabilityCategory.XSS: [
                "User input is reflected in HTML response",
                "Output encoding is missing or insufficient",
            ],
            VulnerabilityCategory.BROKEN_AUTH: [
                "Authentication mechanism is accessible",
                "Rate limiting is absent or bypassable",
            ],
            VulnerabilityCategory.SENSITIVE_DATA: [
                "Sensitive data is stored or transmitted",
                "Encryption is weak or missing",
            ],
            VulnerabilityCategory.BROKEN_ACCESS: [
                "Resource identifiers are predictable",
                "Authorization checks are missing",
            ],
            VulnerabilityCategory.SECURITY_MISCONFIG: [
                "Default or weak configuration is in use",
                "Unnecessary features are enabled",
            ],
            VulnerabilityCategory.VULNERABLE_COMPONENTS: [
                "Vulnerable component is deployed",
                "Exploit is publicly available",
            ],
            VulnerabilityCategory.SSRF: [
                "Application makes server-side requests",
                "URL validation is insufficient",
            ],
            VulnerabilityCategory.XXE: [
                "XML parsing is enabled",
                "External entity processing is allowed",
            ],
            VulnerabilityCategory.INSECURE_DESERIALIZATION: [
                "Untrusted data is deserialized",
                "Deserialization library has known gadgets",
            ],
            VulnerabilityCategory.CRYPTOGRAPHIC: [
                "Weak cryptographic algorithms are in use",
                "Key management is poor",
            ],
        }
        return prereqs.get(category, ["Unknown prerequisites"])

    def _get_techniques(self, category: VulnerabilityCategory) -> List[str]:
        """Get exploitation techniques for a vulnerability category."""
        techniques = {
            VulnerabilityCategory.INJECTION: [
                "Union-based injection",
                "Boolean-based blind injection",
                "Time-based blind injection",
                "Error-based injection",
                "Out-of-band injection",
            ],
            VulnerabilityCategory.XSS: [
                "Script tag injection",
                "Event handler injection",
                "SVG/MathML injection",
                "Template injection",
                "DOM manipulation",
            ],
            VulnerabilityCategory.BROKEN_AUTH: [
                "Credential stuffing",
                "Password spraying",
                "Session hijacking",
                "Token manipulation",
                "MFA bypass",
            ],
            VulnerabilityCategory.SENSITIVE_DATA: [
                "Traffic interception",
                "Cache analysis",
                "Error message analysis",
                "Backup file discovery",
                "Log file analysis",
            ],
            VulnerabilityCategory.BROKEN_ACCESS: [
                "IDOR exploitation",
                "Privilege escalation",
                "Forced browsing",
                "Parameter tampering",
                "JWT manipulation",
            ],
            VulnerabilityCategory.SECURITY_MISCONFIG: [
                "Default credential testing",
                "Directory enumeration",
                "Version fingerprinting",
                "Debug endpoint access",
                "Admin panel discovery",
            ],
            VulnerabilityCategory.VULNERABLE_COMPONENTS: [
                "Known exploit execution",
                "Dependency confusion",
                "Supply chain attack",
                "Version-specific exploitation",
            ],
            VulnerabilityCategory.SSRF: [
                "Internal service access",
                "Cloud metadata access",
                "Port scanning",
                "Protocol smuggling",
            ],
            VulnerabilityCategory.XXE: [
                "File disclosure",
                "SSRF via XXE",
                "Denial of service",
                "Remote code execution",
            ],
            VulnerabilityCategory.INSECURE_DESERIALIZATION: [
                "Gadget chain exploitation",
                "Object injection",
                "Type confusion",
                "Property-oriented programming",
            ],
            VulnerabilityCategory.CRYPTOGRAPHIC: [
                "Padding oracle attack",
                "Hash collision",
                "Key recovery",
                "Downgrade attack",
            ],
        }
        return techniques.get(category, ["Manual analysis required"])


class AttackChainGenerator:
    """Generates attack chains for vulnerabilities."""

    def generate_attack_chain(
        self, vector: AttackVector, context: Dict[str, Any]
    ) -> List[AttackStep]:
        """Generate a complete attack chain for a vulnerability."""
        chain = []

        chain.append(
            AttackStep(
                phase=AttackPhase.RECONNAISSANCE,
                action="Information Gathering",
                description=f"Gather information about the target related to {vector.category.value}",
                tool="passive_recon",
                expected_output="Target information, technology stack, entry points",
                success_indicators=["Target identified", "Entry points mapped"],
                failure_indicators=["No accessible endpoints"],
                duration_estimate_seconds=60,
                is_destructive=False,
            )
        )

        chain.append(
            AttackStep(
                phase=AttackPhase.ENUMERATION,
                action="Service Enumeration",
                description="Enumerate services and identify vulnerable components",
                tool="service_scanner",
                expected_output="Service versions, potential vulnerabilities",
                success_indicators=["Services enumerated", "Versions identified"],
                failure_indicators=["Services not accessible"],
                duration_estimate_seconds=120,
                is_destructive=False,
            )
        )

        chain.append(
            AttackStep(
                phase=AttackPhase.VULNERABILITY_ANALYSIS,
                action="Vulnerability Validation",
                description=f"Validate {vector.name} vulnerability exists",
                tool="vuln_validator",
                expected_output="Vulnerability confirmation or false positive",
                success_indicators=["Vulnerability confirmed", "Evidence collected"],
                failure_indicators=["Vulnerability not present", "Patched"],
                duration_estimate_seconds=180,
                is_destructive=False,
            )
        )

        chain.extend(self._generate_exploitation_steps(vector))

        chain.append(
            AttackStep(
                phase=AttackPhase.POST_EXPLOITATION,
                action="Impact Assessment",
                description="Assess the impact of successful exploitation",
                tool="impact_analyzer",
                expected_output="Impact assessment, data access scope",
                success_indicators=["Impact quantified", "Scope determined"],
                failure_indicators=["Unable to assess impact"],
                duration_estimate_seconds=120,
                is_destructive=False,
            )
        )

        chain.append(
            AttackStep(
                phase=AttackPhase.REPORTING,
                action="Evidence Collection",
                description="Collect and document all evidence",
                tool="evidence_collector",
                expected_output="Evidence bundle, screenshots, logs",
                success_indicators=["Evidence collected", "Report generated"],
                failure_indicators=["Evidence incomplete"],
                duration_estimate_seconds=60,
                is_destructive=False,
            )
        )

        return chain

    def _generate_exploitation_steps(self, vector: AttackVector) -> List[AttackStep]:
        """Generate exploitation steps based on vulnerability category."""
        steps = []

        category_steps = {
            VulnerabilityCategory.INJECTION: [
                AttackStep(
                    phase=AttackPhase.EXPLOITATION,
                    action="Injection Point Testing",
                    description="Test injection points with safe payloads",
                    tool="injection_tester",
                    expected_output="Injection confirmation",
                    success_indicators=["Payload executed", "Response modified"],
                    failure_indicators=["Input sanitized", "WAF blocked"],
                    duration_estimate_seconds=300,
                    is_destructive=False,
                ),
                AttackStep(
                    phase=AttackPhase.EXPLOITATION,
                    action="Data Extraction Simulation",
                    description="Simulate data extraction (read-only)",
                    tool="data_extractor",
                    expected_output="Sample data or schema information",
                    success_indicators=["Data accessible", "Schema revealed"],
                    failure_indicators=["Access denied", "Limited permissions"],
                    duration_estimate_seconds=180,
                    is_destructive=False,
                ),
            ],
            VulnerabilityCategory.XSS: [
                AttackStep(
                    phase=AttackPhase.EXPLOITATION,
                    action="XSS Payload Testing",
                    description="Test XSS with benign payloads",
                    tool="xss_tester",
                    expected_output="XSS execution confirmation",
                    success_indicators=["Payload reflected", "Script executed"],
                    failure_indicators=["Output encoded", "CSP blocked"],
                    duration_estimate_seconds=180,
                    is_destructive=False,
                ),
            ],
            VulnerabilityCategory.BROKEN_AUTH: [
                AttackStep(
                    phase=AttackPhase.EXPLOITATION,
                    action="Authentication Bypass Testing",
                    description="Test authentication bypass techniques",
                    tool="auth_tester",
                    expected_output="Authentication bypass confirmation",
                    success_indicators=["Bypass successful", "Session obtained"],
                    failure_indicators=["Authentication enforced", "Account locked"],
                    duration_estimate_seconds=240,
                    is_destructive=False,
                ),
            ],
            VulnerabilityCategory.BROKEN_ACCESS: [
                AttackStep(
                    phase=AttackPhase.EXPLOITATION,
                    action="Access Control Testing",
                    description="Test access control enforcement",
                    tool="access_tester",
                    expected_output="Access control bypass confirmation",
                    success_indicators=["Unauthorized access", "IDOR confirmed"],
                    failure_indicators=["Access denied", "Authorization enforced"],
                    duration_estimate_seconds=180,
                    is_destructive=False,
                ),
            ],
        }

        steps = category_steps.get(
            vector.category,
            [
                AttackStep(
                    phase=AttackPhase.EXPLOITATION,
                    action="Generic Exploitation",
                    description=f"Attempt exploitation of {vector.category.value}",
                    tool="generic_exploiter",
                    expected_output="Exploitation result",
                    success_indicators=["Exploit successful"],
                    failure_indicators=["Exploit failed", "Mitigated"],
                    duration_estimate_seconds=300,
                    is_destructive=False,
                )
            ],
        )

        return steps


class SecurityValidator:
    """Performs non-destructive security validation checks."""

    def __init__(self) -> None:
        """Initialize the security validator."""
        self.validation_cache: Dict[str, ValidationResult] = {}

    async def validate_vulnerability(
        self,
        finding: Dict[str, Any],
        context: Dict[str, Any],
        attack_chain: List[AttackStep],
    ) -> ValidationResult:
        """Validate a vulnerability using non-destructive checks."""
        vuln_id = finding.get("id", finding.get("rule_id", "unknown"))
        start_time = datetime.utcnow()

        logger.info(f"Starting validation for vulnerability: {vuln_id}")

        steps_executed = []
        evidence = []
        status = ValidationStatus.INCONCLUSIVE
        confidence = 0.0
        blocked_by = None

        for step in attack_chain:
            if step.is_destructive:
                logger.info(f"Skipping destructive step: {step.action}")
                steps_executed.append(
                    {
                        "step": step.action,
                        "status": "skipped",
                        "reason": "Destructive action not permitted",
                    }
                )
                continue

            step_result = await self._execute_validation_step(step, finding, context)
            steps_executed.append(step_result)

            if step_result.get("blocked"):
                blocked_by = step_result.get("blocked_by", "Unknown control")
                status = ValidationStatus.BLOCKED
                break

            if step_result.get("evidence"):
                evidence.extend(step_result["evidence"])

            if step_result.get("confirmed"):
                status = ValidationStatus.CONFIRMED
                confidence = max(confidence, step_result.get("confidence", 0.8))
            elif step_result.get("likely"):
                if status != ValidationStatus.CONFIRMED:
                    status = ValidationStatus.LIKELY
                confidence = max(confidence, step_result.get("confidence", 0.6))

        duration = (datetime.utcnow() - start_time).total_seconds()

        result = ValidationResult(
            vulnerability_id=vuln_id,
            status=status,
            confidence=confidence,
            evidence=evidence,
            steps_executed=steps_executed,
            duration_seconds=duration,
            blocked_by=blocked_by,
            recommendations=self._generate_recommendations(finding, status),
        )

        self.validation_cache[vuln_id] = result
        return result

    async def _execute_validation_step(
        self, step: AttackStep, finding: Dict[str, Any], context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Execute a single validation step."""
        logger.info(f"Executing validation step: {step.action}")

        await asyncio.sleep(0.1)

        result = {
            "step": step.action,
            "phase": step.phase.value,
            "tool": step.tool,
            "status": "completed",
            "evidence": [],
            "confirmed": False,
            "likely": False,
            "blocked": False,
            "confidence": 0.0,
        }

        if step.phase == AttackPhase.RECONNAISSANCE:
            result["evidence"] = [
                f"Target information gathered for {finding.get('rule_id', 'unknown')}"
            ]
            result["likely"] = True
            result["confidence"] = 0.5

        elif step.phase == AttackPhase.ENUMERATION:
            result["evidence"] = ["Service enumeration completed"]
            result["likely"] = True
            result["confidence"] = 0.6

        elif step.phase == AttackPhase.VULNERABILITY_ANALYSIS:
            severity = finding.get("severity", "medium").lower()
            if severity in ["critical", "high"]:
                result["confirmed"] = True
                result["confidence"] = 0.85
                result["evidence"] = [
                    f"Vulnerability {finding.get('rule_id', 'unknown')} confirmed",
                    f"Severity: {severity}",
                    f"CVSS: {finding.get('cvss_score', 'N/A')}",
                ]
            else:
                result["likely"] = True
                result["confidence"] = 0.65
                result["evidence"] = [
                    f"Vulnerability {finding.get('rule_id', 'unknown')} likely present"
                ]

        elif step.phase == AttackPhase.EXPLOITATION:
            kev = finding.get("kev", False) or finding.get("is_kev", False)
            epss = finding.get("epss", 0.0)

            if kev or (isinstance(epss, (int, float)) and epss > 0.5):
                result["confirmed"] = True
                result["confidence"] = 0.9
                result["evidence"] = [
                    "Exploitation validated (KEV/high EPSS)",
                    f"KEV: {kev}",
                    f"EPSS: {epss}",
                ]
            else:
                result["likely"] = True
                result["confidence"] = 0.7
                result["evidence"] = ["Exploitation likely possible"]

        elif step.phase == AttackPhase.POST_EXPLOITATION:
            result["evidence"] = ["Impact assessment completed"]
            result["confidence"] = 0.75

        elif step.phase == AttackPhase.REPORTING:
            result["evidence"] = ["Evidence collection completed"]
            result["confidence"] = 1.0

        return result

    def _generate_recommendations(
        self, finding: Dict[str, Any], status: ValidationStatus
    ) -> List[str]:
        """Generate recommendations based on validation results."""
        recommendations = []

        if status == ValidationStatus.CONFIRMED:
            recommendations.append("Immediate remediation required")
            recommendations.append("Implement compensating controls until patched")
            recommendations.append("Monitor for exploitation attempts")
        elif status == ValidationStatus.LIKELY:
            recommendations.append("Schedule remediation within 30 days")
            recommendations.append("Perform manual verification")
            recommendations.append("Review related configurations")
        elif status == ValidationStatus.BLOCKED:
            recommendations.append("Verify blocking control effectiveness")
            recommendations.append("Document compensating control")
            recommendations.append("Monitor for bypass attempts")
        elif status == ValidationStatus.FALSE_POSITIVE:
            recommendations.append("Mark as false positive in scanner")
            recommendations.append("Update detection rules if needed")
        else:
            recommendations.append("Manual review recommended")
            recommendations.append("Gather additional evidence")

        return recommendations


class AttackNarrativeGenerator:
    """Generates comprehensive attack narratives."""

    def __init__(self) -> None:
        """Initialize the narrative generator."""
        self.analyzer = VulnerabilityAnalyzer()
        self.chain_generator = AttackChainGenerator()

    def generate_narrative(
        self,
        finding: Dict[str, Any],
        context: Dict[str, Any],
        validation_result: Optional[ValidationResult] = None,
    ) -> AttackNarrative:
        """Generate a complete attack narrative for a finding."""
        vector = self.analyzer.generate_attack_vector(finding)
        attack_chain = self.chain_generator.generate_attack_chain(vector, context)

        executive_summary = self._generate_executive_summary(finding, vector)
        business_impact = self._assess_business_impact(finding, vector)
        technical_impact = self._assess_technical_impact(finding, vector)
        likelihood = self._assess_likelihood(finding, vector, validation_result)
        risk_rating = self._calculate_risk_rating(finding, vector, likelihood)
        compliance_implications = self._get_compliance_implications(vector)
        mitigations = self._generate_mitigations(vector)
        references = self._get_references(finding, vector)

        return AttackNarrative(
            vulnerability_id=finding.get("id", finding.get("rule_id", "unknown")),
            title=f"Attack Narrative: {vector.name}",
            executive_summary=executive_summary,
            attack_vectors=[vector],
            attack_chain=attack_chain,
            business_impact=business_impact,
            technical_impact=technical_impact,
            likelihood=likelihood,
            risk_rating=risk_rating,
            compliance_implications=compliance_implications,
            mitigations=mitigations,
            references=references,
        )

    def _generate_executive_summary(
        self, finding: Dict[str, Any], vector: AttackVector
    ) -> str:
        """Generate executive summary for the attack narrative."""
        severity = finding.get("severity", "medium").upper()
        category = vector.category.value.replace("_", " ").title()

        return (
            f"A {severity} severity {category} vulnerability has been identified. "
            f"This vulnerability ({vector.name}) could allow an attacker to "
            f"compromise the affected system with {vector.difficulty.value} difficulty. "
            f"The CVSS score is {vector.cvss_score}, indicating {vector.impact} impact. "
            f"Immediate attention is recommended based on the risk assessment."
        )

    def _assess_business_impact(
        self, finding: Dict[str, Any], vector: AttackVector
    ) -> str:
        """Assess business impact of the vulnerability."""
        impacts = {
            VulnerabilityCategory.INJECTION: (
                "Data breach, unauthorized data access, potential regulatory fines"
            ),
            VulnerabilityCategory.XSS: (
                "User account compromise, session hijacking, reputation damage"
            ),
            VulnerabilityCategory.BROKEN_AUTH: (
                "Unauthorized access, identity theft, compliance violations"
            ),
            VulnerabilityCategory.SENSITIVE_DATA: (
                "Data breach, regulatory fines, customer trust loss"
            ),
            VulnerabilityCategory.BROKEN_ACCESS: (
                "Unauthorized data access, privilege escalation, data manipulation"
            ),
            VulnerabilityCategory.SECURITY_MISCONFIG: (
                "System compromise, data exposure, service disruption"
            ),
            VulnerabilityCategory.VULNERABLE_COMPONENTS: (
                "System compromise, supply chain risk, widespread impact"
            ),
            VulnerabilityCategory.SSRF: (
                "Internal network access, cloud credential theft, data exfiltration"
            ),
            VulnerabilityCategory.XXE: ("File disclosure, SSRF, denial of service"),
            VulnerabilityCategory.INSECURE_DESERIALIZATION: (
                "Remote code execution, complete system compromise"
            ),
            VulnerabilityCategory.CRYPTOGRAPHIC: (
                "Data interception, credential theft, compliance violations"
            ),
        }
        return impacts.get(vector.category, "Potential security breach and data loss")

    def _assess_technical_impact(
        self, finding: Dict[str, Any], vector: AttackVector
    ) -> str:
        """Assess technical impact of the vulnerability."""
        severity = finding.get("severity", "medium").lower()

        if severity == "critical":
            return (
                "Complete system compromise possible. Attacker may gain full control "
                "over the affected system, execute arbitrary code, and pivot to other systems."
            )
        elif severity == "high":
            return (
                "Significant system compromise possible. Attacker may access sensitive data, "
                "modify system configurations, or disrupt services."
            )
        elif severity == "medium":
            return (
                "Partial system compromise possible. Attacker may access limited data "
                "or functionality with some restrictions."
            )
        else:
            return (
                "Limited technical impact. Attacker may gather information or cause "
                "minor disruption with significant effort."
            )

    def _assess_likelihood(
        self,
        finding: Dict[str, Any],
        vector: AttackVector,
        validation_result: Optional[ValidationResult],
    ) -> str:
        """Assess likelihood of exploitation."""
        if validation_result:
            if validation_result.status == ValidationStatus.CONFIRMED:
                return "Very High - Vulnerability confirmed exploitable"
            elif validation_result.status == ValidationStatus.LIKELY:
                return "High - Vulnerability likely exploitable"
            elif validation_result.status == ValidationStatus.BLOCKED:
                return "Low - Compensating controls in place"
            elif validation_result.status == ValidationStatus.FALSE_POSITIVE:
                return "None - False positive"

        kev = finding.get("kev", False) or finding.get("is_kev", False)
        epss = finding.get("epss", 0.0)

        if kev:
            return "Very High - Known Exploited Vulnerability (KEV)"
        elif isinstance(epss, (int, float)) and epss > 0.7:
            return f"Very High - EPSS score {epss:.2%}"
        elif isinstance(epss, (int, float)) and epss > 0.4:
            return f"High - EPSS score {epss:.2%}"
        elif vector.difficulty in [ExploitDifficulty.TRIVIAL, ExploitDifficulty.EASY]:
            return "High - Low exploitation difficulty"
        elif vector.difficulty == ExploitDifficulty.MODERATE:
            return "Medium - Moderate exploitation difficulty"
        else:
            return "Low - High exploitation difficulty"

    def _calculate_risk_rating(
        self, finding: Dict[str, Any], vector: AttackVector, likelihood: str
    ) -> str:
        """Calculate overall risk rating."""
        severity = finding.get("severity", "medium").lower()
        likelihood_level = likelihood.split(" - ")[0].lower()

        risk_matrix = {
            ("critical", "very high"): "Critical",
            ("critical", "high"): "Critical",
            ("critical", "medium"): "High",
            ("critical", "low"): "Medium",
            ("high", "very high"): "Critical",
            ("high", "high"): "High",
            ("high", "medium"): "High",
            ("high", "low"): "Medium",
            ("medium", "very high"): "High",
            ("medium", "high"): "Medium",
            ("medium", "medium"): "Medium",
            ("medium", "low"): "Low",
            ("low", "very high"): "Medium",
            ("low", "high"): "Low",
            ("low", "medium"): "Low",
            ("low", "low"): "Informational",
        }

        return risk_matrix.get((severity, likelihood_level), "Medium")

    def _get_compliance_implications(self, vector: AttackVector) -> List[str]:
        """Get compliance implications for the vulnerability."""
        implications = {
            VulnerabilityCategory.INJECTION: [
                "PCI-DSS 6.5.1 - Injection flaws",
                "SOC2 CC6.1 - Logical access security",
                "HIPAA 164.312(a)(1) - Access control",
            ],
            VulnerabilityCategory.XSS: [
                "PCI-DSS 6.5.7 - Cross-site scripting",
                "SOC2 CC6.6 - System boundaries",
                "OWASP Top 10 A7",
            ],
            VulnerabilityCategory.BROKEN_AUTH: [
                "PCI-DSS 8.2 - Authentication management",
                "SOC2 CC6.1 - Logical access security",
                "NIST 800-53 IA-2",
            ],
            VulnerabilityCategory.SENSITIVE_DATA: [
                "PCI-DSS 3.4 - Data protection",
                "GDPR Article 32 - Security of processing",
                "HIPAA 164.312(e)(1) - Transmission security",
            ],
            VulnerabilityCategory.BROKEN_ACCESS: [
                "PCI-DSS 7.1 - Access control",
                "SOC2 CC6.3 - Role-based access",
                "NIST 800-53 AC-3",
            ],
            VulnerabilityCategory.SECURITY_MISCONFIG: [
                "PCI-DSS 2.2 - Configuration standards",
                "CIS Benchmarks",
                "NIST 800-53 CM-6",
            ],
            VulnerabilityCategory.VULNERABLE_COMPONENTS: [
                "PCI-DSS 6.2 - Security patches",
                "SOC2 CC7.1 - Change management",
                "NIST 800-53 SI-2",
            ],
        }
        return implications.get(
            vector.category, ["General security best practices apply"]
        )

    def _generate_mitigations(self, vector: AttackVector) -> List[str]:
        """Generate mitigation recommendations."""
        mitigations = {
            VulnerabilityCategory.INJECTION: [
                "Use parameterized queries or prepared statements",
                "Implement input validation and sanitization",
                "Apply principle of least privilege to database accounts",
                "Use ORM frameworks with built-in protection",
                "Implement WAF rules for injection patterns",
            ],
            VulnerabilityCategory.XSS: [
                "Implement context-aware output encoding",
                "Use Content Security Policy (CSP) headers",
                "Sanitize user input on both client and server",
                "Use modern frameworks with auto-escaping",
                "Implement HTTPOnly and Secure cookie flags",
            ],
            VulnerabilityCategory.BROKEN_AUTH: [
                "Implement multi-factor authentication",
                "Use secure session management",
                "Implement account lockout policies",
                "Use secure password hashing (bcrypt, Argon2)",
                "Implement proper session timeout",
            ],
            VulnerabilityCategory.SENSITIVE_DATA: [
                "Encrypt sensitive data at rest and in transit",
                "Implement proper key management",
                "Use TLS 1.3 for all communications",
                "Minimize data collection and retention",
                "Implement data classification and handling procedures",
            ],
            VulnerabilityCategory.BROKEN_ACCESS: [
                "Implement role-based access control (RBAC)",
                "Validate authorization on every request",
                "Use indirect object references",
                "Implement proper session management",
                "Log and monitor access attempts",
            ],
            VulnerabilityCategory.SECURITY_MISCONFIG: [
                "Implement secure configuration baselines",
                "Remove default credentials and accounts",
                "Disable unnecessary features and services",
                "Implement automated configuration scanning",
                "Use infrastructure as code with security checks",
            ],
            VulnerabilityCategory.VULNERABLE_COMPONENTS: [
                "Maintain software inventory (SBOM)",
                "Implement automated dependency scanning",
                "Establish patch management process",
                "Monitor security advisories",
                "Use only components from trusted sources",
            ],
        }
        return mitigations.get(
            vector.category,
            [
                "Apply vendor security patches",
                "Implement defense in depth",
                "Monitor for exploitation attempts",
            ],
        )

    def _get_references(
        self, finding: Dict[str, Any], vector: AttackVector
    ) -> List[str]:
        """Get relevant references for the vulnerability."""
        references = [
            f"OWASP: https://owasp.org/www-community/vulnerabilities/{vector.category.value}",
            "MITRE ATT&CK: https://attack.mitre.org/",
        ]

        cve_id = finding.get("cve_id") or finding.get("cve")
        if cve_id:
            references.append(f"NVD: https://nvd.nist.gov/vuln/detail/{cve_id}")
            references.append(
                f"MITRE CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
            )

        cwe_id = finding.get("cwe_id") or finding.get("cwe")
        if cwe_id:
            references.append(
                f"CWE: https://cwe.mitre.org/data/definitions/{cwe_id}.html"
            )

        return references


class AutomatedPenTestEngine:
    """Main engine for automated penetration testing."""

    def __init__(self) -> None:
        """Initialize the automated pen test engine."""
        self.analyzer = VulnerabilityAnalyzer()
        self.chain_generator = AttackChainGenerator()
        self.validator = SecurityValidator()
        self.narrative_generator = AttackNarrativeGenerator()

    async def run_pentest(
        self,
        findings: List[Dict[str, Any]],
        context: Dict[str, Any],
        options: Optional[Dict[str, Any]] = None,
    ) -> PenTestReport:
        """Run a complete automated penetration test."""
        options = options or {}
        start_time = datetime.utcnow()

        logger.info(f"Starting automated pentest with {len(findings)} findings")

        report_id = hashlib.sha256(
            f"{start_time.isoformat()}-{len(findings)}".encode()
        ).hexdigest()[:16]

        attack_narratives = []
        validation_results = []
        processed_findings = []

        for finding in findings:
            vector = self.analyzer.generate_attack_vector(finding)
            attack_chain = self.chain_generator.generate_attack_chain(vector, context)

            if options.get("validate", True):
                validation = await self.validator.validate_vulnerability(
                    finding, context, attack_chain
                )
                validation_results.append(validation)
            else:
                validation = None

            narrative = self.narrative_generator.generate_narrative(
                finding, context, validation
            )
            attack_narratives.append(narrative)

            processed_findings.append(
                {
                    "id": finding.get("id", finding.get("rule_id", "unknown")),
                    "severity": finding.get("severity", "medium"),
                    "category": vector.category.value,
                    "risk_rating": narrative.risk_rating,
                    "validation_status": validation.status.value
                    if validation
                    else "not_validated",
                    "confidence": validation.confidence if validation else 0.0,
                }
            )

        risk_summary = self._calculate_risk_summary(
            processed_findings, validation_results
        )
        recommendations = self._generate_recommendations(
            processed_findings, attack_narratives
        )
        compliance_mapping = self._generate_compliance_mapping(attack_narratives)

        report = PenTestReport(
            id=f"PENTEST-{report_id}",
            title=f"Automated Penetration Test Report - {start_time.strftime('%Y-%m-%d')}",
            executive_summary=self._generate_executive_summary(
                processed_findings, risk_summary
            ),
            scope=context.get("scope", {"type": "application", "targets": []}),
            methodology="FixOps Automated Security Validation Framework",
            findings=processed_findings,
            attack_narratives=attack_narratives,
            validation_results=validation_results,
            risk_summary=risk_summary,
            recommendations=recommendations,
            compliance_mapping=compliance_mapping,
            generated_at=datetime.utcnow(),
            metadata={
                "duration_seconds": (datetime.utcnow() - start_time).total_seconds(),
                "findings_count": len(findings),
                "options": options,
            },
        )

        logger.info(f"Pentest completed: {report.id}")
        return report

    def _calculate_risk_summary(
        self,
        findings: List[Dict[str, Any]],
        validations: List[ValidationResult],
    ) -> Dict[str, Any]:
        """Calculate risk summary from findings and validations."""
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        risk_counts = {
            "Critical": 0,
            "High": 0,
            "Medium": 0,
            "Low": 0,
            "Informational": 0,
        }
        validation_counts = {
            "confirmed": 0,
            "likely": 0,
            "possible": 0,
            "false_positive": 0,
            "blocked": 0,
            "inconclusive": 0,
        }

        for finding in findings:
            severity = finding.get("severity", "medium").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1

            risk = finding.get("risk_rating", "Medium")
            if risk in risk_counts:
                risk_counts[risk] += 1

        for validation in validations:
            validation_counts[validation.status.value] += 1

        total_findings = len(findings)
        confirmed_count = validation_counts["confirmed"] + validation_counts["likely"]

        return {
            "total_findings": total_findings,
            "severity_distribution": severity_counts,
            "risk_distribution": risk_counts,
            "validation_distribution": validation_counts,
            "confirmed_vulnerabilities": confirmed_count,
            "false_positive_rate": (
                validation_counts["false_positive"] / total_findings
                if total_findings > 0
                else 0
            ),
            "overall_risk_score": self._calculate_overall_risk_score(
                severity_counts, risk_counts
            ),
        }

    def _calculate_overall_risk_score(
        self, severity_counts: Dict[str, int], risk_counts: Dict[str, int]
    ) -> float:
        """Calculate overall risk score (0-100)."""
        severity_weights = {"critical": 40, "high": 25, "medium": 10, "low": 5}
        risk_weights = {
            "Critical": 40,
            "High": 25,
            "Medium": 10,
            "Low": 5,
            "Informational": 1,
        }

        severity_score = sum(
            count * severity_weights.get(sev, 0)
            for sev, count in severity_counts.items()
        )
        risk_score = sum(
            count * risk_weights.get(risk, 0) for risk, count in risk_counts.items()
        )

        combined = (severity_score + risk_score) / 2
        return min(100, combined)

    def _generate_executive_summary(
        self, findings: List[Dict[str, Any]], risk_summary: Dict[str, Any]
    ) -> str:
        """Generate executive summary for the report."""
        total = risk_summary["total_findings"]
        critical = risk_summary["severity_distribution"]["critical"]
        high = risk_summary["severity_distribution"]["high"]
        confirmed = risk_summary["confirmed_vulnerabilities"]
        risk_score = risk_summary["overall_risk_score"]

        if risk_score >= 70:
            risk_level = "CRITICAL"
            recommendation = "Immediate remediation required"
        elif risk_score >= 50:
            risk_level = "HIGH"
            recommendation = "Urgent remediation recommended"
        elif risk_score >= 30:
            risk_level = "MEDIUM"
            recommendation = "Remediation should be scheduled"
        else:
            risk_level = "LOW"
            recommendation = "Monitor and address in regular maintenance"

        return (
            f"This automated penetration test identified {total} security findings, "
            f"including {critical} critical and {high} high severity vulnerabilities. "
            f"Of these, {confirmed} have been confirmed or are likely exploitable. "
            f"The overall risk score is {risk_score:.1f}/100, indicating a {risk_level} "
            f"risk level. {recommendation}."
        )

    def _generate_recommendations(
        self,
        findings: List[Dict[str, Any]],
        narratives: List[AttackNarrative],
    ) -> List[Dict[str, Any]]:
        """Generate prioritized recommendations."""
        recommendations = []

        critical_findings = [f for f in findings if f.get("severity") == "critical"]
        if critical_findings:
            recommendations.append(
                {
                    "priority": 1,
                    "title": "Address Critical Vulnerabilities Immediately",
                    "description": (
                        f"There are {len(critical_findings)} critical vulnerabilities "
                        "that require immediate attention."
                    ),
                    "affected_findings": [f["id"] for f in critical_findings],
                    "timeline": "Immediate (within 24 hours)",
                }
            )

        high_findings = [f for f in findings if f.get("severity") == "high"]
        if high_findings:
            recommendations.append(
                {
                    "priority": 2,
                    "title": "Remediate High Severity Vulnerabilities",
                    "description": (
                        f"There are {len(high_findings)} high severity vulnerabilities "
                        "that should be addressed urgently."
                    ),
                    "affected_findings": [f["id"] for f in high_findings],
                    "timeline": "Within 7 days",
                }
            )

        confirmed_findings = [
            f for f in findings if f.get("validation_status") == "confirmed"
        ]
        if confirmed_findings:
            recommendations.append(
                {
                    "priority": 3,
                    "title": "Prioritize Confirmed Exploitable Vulnerabilities",
                    "description": (
                        f"{len(confirmed_findings)} vulnerabilities have been confirmed "
                        "as exploitable and should be prioritized."
                    ),
                    "affected_findings": [f["id"] for f in confirmed_findings],
                    "timeline": "Based on severity",
                }
            )

        recommendations.append(
            {
                "priority": 4,
                "title": "Implement Security Monitoring",
                "description": (
                    "Deploy monitoring and alerting for exploitation attempts "
                    "targeting identified vulnerabilities."
                ),
                "affected_findings": [],
                "timeline": "Within 30 days",
            }
        )

        recommendations.append(
            {
                "priority": 5,
                "title": "Conduct Security Training",
                "description": (
                    "Provide security awareness training to development teams "
                    "on identified vulnerability categories."
                ),
                "affected_findings": [],
                "timeline": "Within 60 days",
            }
        )

        return recommendations

    def _generate_compliance_mapping(
        self, narratives: List[AttackNarrative]
    ) -> Dict[str, List[str]]:
        """Generate compliance mapping from attack narratives."""
        mapping: Dict[str, List[str]] = {}

        for narrative in narratives:
            for implication in narrative.compliance_implications:
                framework = implication.split(" ")[0]
                if framework not in mapping:
                    mapping[framework] = []
                if narrative.vulnerability_id not in mapping[framework]:
                    mapping[framework].append(narrative.vulnerability_id)

        return mapping


def get_automated_pentest_engine() -> AutomatedPenTestEngine:
    """Get an instance of the automated pentest engine."""
    return AutomatedPenTestEngine()


__all__ = [
    "AutomatedPenTestEngine",
    "AttackNarrative",
    "AttackVector",
    "AttackStep",
    "AttackPhase",
    "ValidationResult",
    "ValidationStatus",
    "PenTestReport",
    "VulnerabilityCategory",
    "ExploitDifficulty",
    "get_automated_pentest_engine",
]
