"""Enterprise Micro Penetration Testing Engine.

This service provides automated, targeted micro penetration testing capabilities
for enterprise environments with advanced threat modeling, attack surface analysis,
and compliance tracking.
"""

import asyncio
import json
import logging
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class ThreatCategory(Enum):
    """MITRE ATT&CK-aligned threat categories."""

    INITIAL_ACCESS = "initial_access"
    EXECUTION = "execution"
    PERSISTENCE = "persistence"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DEFENSE_EVASION = "defense_evasion"
    CREDENTIAL_ACCESS = "credential_access"
    DISCOVERY = "discovery"
    LATERAL_MOVEMENT = "lateral_movement"
    COLLECTION = "collection"
    EXFILTRATION = "exfiltration"
    COMMAND_AND_CONTROL = "command_and_control"
    IMPACT = "impact"


class AttackVector(Enum):
    """Attack vectors for micro pen testing."""

    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    SSRF = "ssrf"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_BYPASS = "authorization_bypass"
    SESSION_HIJACKING = "session_hijacking"
    API_ABUSE = "api_abuse"
    CRYPTOGRAPHIC_WEAKNESS = "cryptographic_weakness"
    CONFIGURATION_ERROR = "configuration_error"
    DEPENDENCY_VULNERABILITY = "dependency_vulnerability"
    SECRETS_EXPOSURE = "secrets_exposure"
    CONTAINER_ESCAPE = "container_escape"
    CLOUD_MISCONFIGURATION = "cloud_misconfiguration"


class ScanMode(Enum):
    """Scan modes for different testing scenarios."""

    PASSIVE = "passive"  # Non-intrusive reconnaissance
    ACTIVE = "active"  # Active probing and testing
    AGGRESSIVE = "aggressive"  # Full exploitation attempts
    STEALTH = "stealth"  # Evasive testing


class ComplianceFramework(Enum):
    """Compliance frameworks for validation."""

    SOC2 = "soc2"
    ISO27001 = "iso27001"
    PCI_DSS = "pci_dss"
    HIPAA = "hipaa"
    GDPR = "gdpr"
    NIST_800_53 = "nist_800_53"
    CIS = "cis"
    OWASP_TOP_10 = "owasp_top_10"


class MicroScanStatus(Enum):
    """Status of micro penetration test."""

    QUEUED = "queued"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class RiskLevel(Enum):
    """Risk level assessment."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class AttackSurface:
    """Attack surface definition for micro pen testing."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    target_url: str = ""
    target_type: str = ""  # api, web_app, mobile_app, infrastructure, cloud
    endpoints: List[str] = field(default_factory=list)
    authentication_required: bool = False
    authentication_type: Optional[str] = None
    headers: Dict[str, str] = field(default_factory=dict)
    cookies: Dict[str, str] = field(default_factory=dict)
    parameters: Dict[str, Any] = field(default_factory=dict)
    technologies: List[str] = field(default_factory=list)
    environment: str = "development"  # development, staging, production
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "target_url": self.target_url,
            "target_type": self.target_type,
            "endpoints": self.endpoints,
            "authentication_required": self.authentication_required,
            "authentication_type": self.authentication_type,
            "headers": self.headers,
            "cookies": self.cookies,
            "parameters": self.parameters,
            "technologies": self.technologies,
            "environment": self.environment,
            "metadata": self.metadata,
        }


@dataclass
class ThreatModel:
    """Threat model for micro pen testing."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    description: str = ""
    categories: List[ThreatCategory] = field(default_factory=list)
    attack_vectors: List[AttackVector] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    owasp_categories: List[str] = field(default_factory=list)
    priority: int = 5  # 1-10, 10 being highest
    compliance_frameworks: List[ComplianceFramework] = field(default_factory=list)
    test_cases: List[str] = field(default_factory=list)
    expected_findings: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "categories": [c.value for c in self.categories],
            "attack_vectors": [v.value for v in self.attack_vectors],
            "mitre_techniques": self.mitre_techniques,
            "owasp_categories": self.owasp_categories,
            "priority": self.priority,
            "compliance_frameworks": [f.value for f in self.compliance_frameworks],
            "test_cases": self.test_cases,
            "expected_findings": self.expected_findings,
            "metadata": self.metadata,
        }


@dataclass
class MicroScanConfig:
    """Configuration for micro penetration test scan."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    attack_surface: AttackSurface = field(default_factory=AttackSurface)
    threat_model: ThreatModel = field(default_factory=ThreatModel)
    scan_mode: ScanMode = ScanMode.ACTIVE
    timeout_seconds: int = 300
    max_threads: int = 5
    rate_limit_rps: int = 10
    stop_on_critical: bool = True
    include_proof_of_concept: bool = True
    tenant_id: str = ""
    organization_id: str = ""
    created_by: str = ""
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "attack_surface": self.attack_surface.to_dict(),
            "threat_model": self.threat_model.to_dict(),
            "scan_mode": self.scan_mode.value,
            "timeout_seconds": self.timeout_seconds,
            "max_threads": self.max_threads,
            "rate_limit_rps": self.rate_limit_rps,
            "stop_on_critical": self.stop_on_critical,
            "include_proof_of_concept": self.include_proof_of_concept,
            "tenant_id": self.tenant_id,
            "organization_id": self.organization_id,
            "created_by": self.created_by,
            "tags": self.tags,
            "metadata": self.metadata,
        }


@dataclass
class ScanFinding:
    """Individual finding from micro pen test."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    scan_id: str = ""
    title: str = ""
    description: str = ""
    risk_level: RiskLevel = RiskLevel.INFO
    cvss_score: float = 0.0
    attack_vector: AttackVector = AttackVector.API_ABUSE
    threat_category: ThreatCategory = ThreatCategory.INITIAL_ACCESS
    affected_endpoint: str = ""
    exploit_successful: bool = False
    evidence: Dict[str, Any] = field(default_factory=dict)
    proof_of_concept: Optional[str] = None
    remediation: str = ""
    cwe_ids: List[str] = field(default_factory=list)
    owasp_references: List[str] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    compliance_violations: List[ComplianceFramework] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "scan_id": self.scan_id,
            "title": self.title,
            "description": self.description,
            "risk_level": self.risk_level.value,
            "cvss_score": self.cvss_score,
            "attack_vector": self.attack_vector.value,
            "threat_category": self.threat_category.value,
            "affected_endpoint": self.affected_endpoint,
            "exploit_successful": self.exploit_successful,
            "evidence": self.evidence,
            "proof_of_concept": self.proof_of_concept,
            "remediation": self.remediation,
            "cwe_ids": self.cwe_ids,
            "owasp_references": self.owasp_references,
            "mitre_techniques": self.mitre_techniques,
            "compliance_violations": [f.value for f in self.compliance_violations],
            "discovered_at": self.discovered_at.isoformat(),
            "metadata": self.metadata,
        }


@dataclass
class MicroScanResult:
    """Result of micro penetration test."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    scan_id: str = ""
    config: Optional[MicroScanConfig] = None
    status: MicroScanStatus = MicroScanStatus.QUEUED
    findings: List[ScanFinding] = field(default_factory=list)
    summary: Dict[str, Any] = field(default_factory=dict)
    attack_paths: List[Dict[str, Any]] = field(default_factory=list)
    compliance_status: Dict[str, bool] = field(default_factory=dict)
    execution_time_seconds: float = 0.0
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "scan_id": self.scan_id,
            "config": self.config.to_dict() if self.config else None,
            "status": self.status.value,
            "findings": [f.to_dict() for f in self.findings],
            "summary": self.summary,
            "attack_paths": self.attack_paths,
            "compliance_status": self.compliance_status,
            "execution_time_seconds": self.execution_time_seconds,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat()
            if self.completed_at
            else None,
            "error_message": self.error_message,
            "metadata": self.metadata,
        }


@dataclass
class AuditLog:
    """Audit log entry for compliance tracking."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.utcnow)
    tenant_id: str = ""
    organization_id: str = ""
    user_id: str = ""
    action: str = ""
    resource_type: str = ""
    resource_id: str = ""
    details: Dict[str, Any] = field(default_factory=dict)
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    result: str = "success"  # success, failure, error
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "tenant_id": self.tenant_id,
            "organization_id": self.organization_id,
            "user_id": self.user_id,
            "action": self.action,
            "resource_type": self.resource_type,
            "resource_id": self.resource_id,
            "details": self.details,
            "ip_address": self.ip_address,
            "user_agent": self.user_agent,
            "result": self.result,
            "metadata": self.metadata,
        }


class MicroPentestEngine:
    """Enterprise Micro Penetration Testing Engine.

    Provides automated, targeted security testing with:
    - Advanced threat modeling
    - Attack surface analysis
    - Compliance tracking
    - Audit logging
    - Multi-tenant support
    """

    def __init__(
        self,
        enable_audit_logging: bool = True,
    ):
        """Initialize the micro pentest engine."""
        self.enable_audit_logging = enable_audit_logging
        self.active_scans: Dict[str, MicroScanResult] = {}
        self.audit_logs: List[AuditLog] = []

        # Attack vector test definitions
        self.attack_tests = self._initialize_attack_tests()

        # Compliance requirements mapping
        self.compliance_requirements = self._initialize_compliance_requirements()

    def _initialize_attack_tests(self) -> Dict[AttackVector, List[Dict[str, Any]]]:
        """Initialize attack test definitions."""
        return {
            AttackVector.SQL_INJECTION: [
                {
                    "name": "Basic SQL Injection",
                    "payloads": [
                        "' OR '1'='1",
                        "'; DROP TABLE users--",
                        "' UNION SELECT NULL--",
                    ],
                    "detection": ["sql", "database", "syntax error"],
                },
                {
                    "name": "Blind SQL Injection",
                    "payloads": ["' AND SLEEP(5)--", "' AND 1=1--", "' AND 1=2--"],
                    "detection": ["time_delay", "boolean_based"],
                },
            ],
            AttackVector.XSS: [
                {
                    "name": "Reflected XSS",
                    "payloads": [
                        "<script>alert('XSS')</script>",
                        "<img src=x onerror=alert(1)>",
                    ],
                    "detection": ["<script>", "onerror", "javascript:"],
                },
                {
                    "name": "Stored XSS",
                    "payloads": ["<script>document.write('XSS')</script>"],
                    "detection": ["persistent_script", "stored_payload"],
                },
            ],
            AttackVector.AUTHENTICATION_BYPASS: [
                {
                    "name": "JWT Token Manipulation",
                    "payloads": [
                        "modified_signature",
                        "algorithm_none",
                        "expired_token",
                    ],
                    "detection": ["unauthorized_access", "token_validation_bypass"],
                },
                {
                    "name": "Session Fixation",
                    "payloads": ["fixed_session_id", "session_prediction"],
                    "detection": ["session_reuse", "predictable_session"],
                },
            ],
            AttackVector.API_ABUSE: [
                {
                    "name": "Rate Limiting Test",
                    "payloads": ["bulk_requests"],
                    "detection": ["no_rate_limit", "429_missing"],
                },
                {
                    "name": "BOLA/IDOR Test",
                    "payloads": ["id_enumeration", "uuid_prediction"],
                    "detection": ["unauthorized_data_access"],
                },
            ],
            AttackVector.SSRF: [
                {
                    "name": "Internal Network Access",
                    "payloads": [
                        "http://localhost",
                        "http://127.0.0.1",
                        "http://169.254.169.254",
                    ],
                    "detection": ["internal_response", "metadata_access"],
                },
            ],
            AttackVector.PATH_TRAVERSAL: [
                {
                    "name": "Directory Traversal",
                    "payloads": [
                        "../../../etc/passwd",
                        "..\\..\\..\\windows\\system32",
                    ],
                    "detection": ["file_content", "system_file"],
                },
            ],
        }

    def _initialize_compliance_requirements(
        self,
    ) -> Dict[ComplianceFramework, Dict[str, Any]]:
        """Initialize compliance framework requirements."""
        return {
            ComplianceFramework.SOC2: {
                "name": "SOC 2 Type II",
                "prohibited_vulnerabilities": [RiskLevel.CRITICAL, RiskLevel.HIGH],
                "required_controls": ["access_control", "encryption", "logging"],
            },
            ComplianceFramework.PCI_DSS: {
                "name": "PCI DSS v4.0",
                "prohibited_vulnerabilities": [RiskLevel.CRITICAL, RiskLevel.HIGH],
                "required_controls": [
                    "encryption",
                    "access_control",
                    "vulnerability_management",
                ],
            },
            ComplianceFramework.HIPAA: {
                "name": "HIPAA Security Rule",
                "prohibited_vulnerabilities": [RiskLevel.CRITICAL],
                "required_controls": ["encryption", "access_control", "audit_logging"],
            },
            ComplianceFramework.GDPR: {
                "name": "GDPR Article 32",
                "prohibited_vulnerabilities": [RiskLevel.CRITICAL, RiskLevel.HIGH],
                "required_controls": ["encryption", "data_protection", "consent"],
            },
            ComplianceFramework.ISO27001: {
                "name": "ISO 27001:2022",
                "prohibited_vulnerabilities": [RiskLevel.CRITICAL],
                "required_controls": [
                    "risk_assessment",
                    "access_control",
                    "monitoring",
                ],
            },
            ComplianceFramework.OWASP_TOP_10: {
                "name": "OWASP Top 10 2021",
                "prohibited_vulnerabilities": [RiskLevel.CRITICAL, RiskLevel.HIGH],
                "required_controls": ["injection_prevention", "auth", "crypto"],
            },
        }

    async def run_scan(self, config: MicroScanConfig) -> MicroScanResult:
        """Run a micro penetration test scan.

        Executes an 8-phase scanning process:
        1. Initialization
        2. Reconnaissance
        3. Threat Modeling
        4. Vulnerability Scanning
        5. Exploitation
        6. Compliance Validation
        7. Risk Scoring
        8. Attack Path Generation
        """
        scan_id = str(uuid.uuid4())
        result = MicroScanResult(
            id=scan_id,
            scan_id=scan_id,
            config=config,
            status=MicroScanStatus.RUNNING,
            started_at=datetime.utcnow(),
        )

        self.active_scans[scan_id] = result

        if self.enable_audit_logging:
            self._create_audit_log(
                tenant_id=config.tenant_id,
                organization_id=config.organization_id,
                user_id=config.created_by,
                action="start_micro_scan",
                resource_type="micro_scan",
                resource_id=scan_id,
                details={
                    "config_name": config.name,
                    "scan_mode": config.scan_mode.value,
                },
            )

        try:
            # Phase 1: Initialization
            logger.info(f"Phase 1: Initialization for scan {scan_id}")
            await asyncio.sleep(0.05)

            # Phase 2: Reconnaissance
            logger.info("Phase 2: Reconnaissance")
            await self._phase_reconnaissance(result, config)

            # Phase 3: Threat Modeling
            logger.info("Phase 3: Threat Modeling")
            await self._phase_threat_modeling(result, config)

            # Phase 4: Vulnerability Scanning
            logger.info("Phase 4: Vulnerability Scanning")
            await self._phase_vulnerability_scanning(result, config)

            # Phase 5: Exploitation
            logger.info("Phase 5: Exploitation")
            await self._phase_exploitation(result, config)

            # Phase 6: Compliance Validation
            logger.info("Phase 6: Compliance Validation")
            await self._phase_compliance_validation(result, config)

            # Phase 7: Risk Scoring
            logger.info("Phase 7: Risk Scoring")
            await self._phase_risk_scoring(result, config)

            # Phase 8: Attack Path Generation
            logger.info("Phase 8: Attack Path Generation")
            await self._phase_attack_path_generation(result, config)

            # Generate summary (only set COMPLETED if not cancelled)
            result.summary = self._generate_scan_summary(result)
            # Check if scan was cancelled during execution
            if result.status != MicroScanStatus.CANCELLED:
                result.status = MicroScanStatus.COMPLETED
            result.completed_at = datetime.utcnow()
            result.execution_time_seconds = (
                result.completed_at - result.started_at
            ).total_seconds()

            logger.info(
                f"Scan {scan_id} completed with {len(result.findings)} findings"
            )

        except Exception as e:
            result.status = MicroScanStatus.FAILED
            result.error_message = str(e)
            result.completed_at = datetime.utcnow()
            logger.error(f"Scan {scan_id} failed: {e}")

        if self.enable_audit_logging:
            self._create_audit_log(
                tenant_id=config.tenant_id,
                organization_id=config.organization_id,
                user_id=config.created_by,
                action="complete_micro_scan",
                resource_type="micro_scan",
                resource_id=scan_id,
                details={
                    "status": result.status.value,
                    "findings_count": len(result.findings),
                },
                result="success"
                if result.status == MicroScanStatus.COMPLETED
                else "failure",
            )

        return result

    async def _phase_reconnaissance(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 2: Reconnaissance and information gathering."""
        attack_surface = config.attack_surface

        # Gather information about the target
        recon_data = {
            "target_url": attack_surface.target_url,
            "target_type": attack_surface.target_type,
            "endpoints_count": len(attack_surface.endpoints),
            "technologies": attack_surface.technologies,
            "authentication_required": attack_surface.authentication_required,
        }

        result.metadata["reconnaissance"] = recon_data
        await asyncio.sleep(0.05)

    async def _phase_threat_modeling(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 3: Threat modeling based on attack surface."""
        threat_model = config.threat_model

        # Apply threat model to identify relevant attack vectors
        applicable_vectors = []
        for vector in threat_model.attack_vectors:
            if vector in self.attack_tests:
                applicable_vectors.append(vector)

        result.metadata["threat_model"] = {
            "name": threat_model.name,
            "categories": [c.value for c in threat_model.categories],
            "applicable_vectors": [v.value for v in applicable_vectors],
        }
        await asyncio.sleep(0.05)

    async def _phase_vulnerability_scanning(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 4: Vulnerability scanning using attack vectors."""
        attack_surface = config.attack_surface
        threat_model = config.threat_model

        for vector in threat_model.attack_vectors:
            if vector not in self.attack_tests:
                continue

            tests = self.attack_tests[vector]
            for test in tests:
                finding = await self._execute_attack_test(
                    result.scan_id, vector, test, attack_surface
                )
                if finding:
                    result.findings.append(finding)

                    # Stop on critical if configured
                    if (
                        config.stop_on_critical
                        and finding.risk_level == RiskLevel.CRITICAL
                    ):
                        logger.warning(
                            f"Critical finding detected, stopping scan: {finding.title}"
                        )
                        return

        await asyncio.sleep(0.05)

    async def _execute_attack_test(
        self,
        scan_id: str,
        vector: AttackVector,
        test: Dict[str, Any],
        attack_surface: AttackSurface,
    ) -> Optional[ScanFinding]:
        """Execute a single attack test and return finding if vulnerable."""
        # Simulate vulnerability detection based on attack vector
        if vector == AttackVector.SQL_INJECTION:
            return ScanFinding(
                scan_id=scan_id,
                title=f"SQL Injection Vulnerability - {test['name']}",
                description=f"Potential SQL injection in {attack_surface.target_url}",
                risk_level=RiskLevel.CRITICAL,
                cvss_score=9.8,
                attack_vector=vector,
                threat_category=ThreatCategory.INITIAL_ACCESS,
                affected_endpoint=f"{attack_surface.target_url}/api/search",
                exploit_successful=False,
                evidence={
                    "test_type": test["name"],
                    "payloads_tested": len(test["payloads"]),
                    "detection_methods": test["detection"],
                },
                remediation="Use parameterized queries or prepared statements. Implement input validation.",
                cwe_ids=["CWE-89"],
                owasp_references=["A03:2021-Injection"],
                mitre_techniques=["T1190"],
            )

        if vector == AttackVector.XSS:
            return ScanFinding(
                scan_id=scan_id,
                title=f"Cross-Site Scripting (XSS) - {test['name']}",
                description=f"XSS vulnerability detected in {attack_surface.target_url}",
                risk_level=RiskLevel.HIGH,
                cvss_score=7.1,
                attack_vector=vector,
                threat_category=ThreatCategory.EXECUTION,
                affected_endpoint=f"{attack_surface.target_url}/search",
                exploit_successful=False,
                evidence={
                    "test_type": test["name"],
                    "payloads_tested": len(test["payloads"]),
                },
                remediation="Implement output encoding and Content Security Policy (CSP).",
                cwe_ids=["CWE-79"],
                owasp_references=["A03:2021-Injection"],
                mitre_techniques=["T1059.007"],
            )

        if (
            vector == AttackVector.AUTHENTICATION_BYPASS
            and attack_surface.authentication_required
        ):
            return ScanFinding(
                scan_id=scan_id,
                title=f"Authentication Weakness - {test['name']}",
                description=f"Authentication bypass potential in {attack_surface.target_url}",
                risk_level=RiskLevel.CRITICAL,
                cvss_score=9.1,
                attack_vector=vector,
                threat_category=ThreatCategory.CREDENTIAL_ACCESS,
                affected_endpoint=f"{attack_surface.target_url}/auth/login",
                exploit_successful=False,
                evidence={
                    "test_type": test["name"],
                    "authentication_type": attack_surface.authentication_type,
                },
                remediation="Implement secure authentication mechanisms. Use strong session management.",
                cwe_ids=["CWE-287"],
                owasp_references=[
                    "A07:2021-Identification and Authentication Failures"
                ],
                mitre_techniques=["T1078"],
            )

        if vector == AttackVector.API_ABUSE:
            return ScanFinding(
                scan_id=scan_id,
                title=f"API Security Issue - {test['name']}",
                description=f"API abuse vulnerability in {attack_surface.target_url}",
                risk_level=RiskLevel.MEDIUM,
                cvss_score=5.3,
                attack_vector=vector,
                threat_category=ThreatCategory.INITIAL_ACCESS,
                affected_endpoint=f"{attack_surface.target_url}/api/v1",
                exploit_successful=False,
                evidence={"test_type": test["name"]},
                remediation="Implement rate limiting and proper authorization checks.",
                cwe_ids=["CWE-307"],
                owasp_references=["A04:2021-Insecure Design"],
                mitre_techniques=["T1190"],
            )

        return None

    async def _phase_exploitation(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 5: Exploitation attempts for confirmed vulnerabilities."""
        # Only attempt exploitation in active/aggressive modes
        if config.scan_mode not in [ScanMode.ACTIVE, ScanMode.AGGRESSIVE]:
            return

        high_risk_findings = [
            f
            for f in result.findings
            if f.risk_level in [RiskLevel.CRITICAL, RiskLevel.HIGH]
        ]

        for finding in high_risk_findings:
            if config.include_proof_of_concept:
                # Generate proof of concept
                poc = await self._generate_proof_of_concept(finding, config)
                finding.proof_of_concept = poc

                # Simulate exploitation attempt
                if finding.attack_vector == AttackVector.SQL_INJECTION:
                    finding.exploit_successful = False
                    finding.evidence["exploitation_attempted"] = True
                    finding.evidence["exploitation_result"] = "Blocked by WAF"

        await asyncio.sleep(0.05)

    async def _generate_proof_of_concept(
        self, finding: ScanFinding, config: MicroScanConfig
    ) -> str:
        """Generate proof of concept for a finding."""
        poc_template = f"""
# Proof of Concept: {finding.title}

## Vulnerability Details
- Risk Level: {finding.risk_level.value}
- CVSS Score: {finding.cvss_score}
- Attack Vector: {finding.attack_vector.value}
- Affected Endpoint: {finding.affected_endpoint}

## Reproduction Steps
1. Navigate to {finding.affected_endpoint}
2. Inject test payload
3. Observe vulnerability behavior

## Evidence
{json.dumps(finding.evidence, indent=2)}

## Remediation
{finding.remediation}

---
Generated by FixOps Enterprise Micro Pentest Engine
Scan ID: {finding.scan_id}
        """
        return poc_template.strip()

    async def _phase_compliance_validation(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 6: Compliance validation against frameworks."""
        threat_model = config.threat_model

        for framework in threat_model.compliance_frameworks:
            is_compliant = await self._validate_compliance(framework, result.findings)
            result.compliance_status[framework.value] = is_compliant

            if not is_compliant:
                # Add compliance violation finding
                result.findings.append(
                    ScanFinding(
                        scan_id=result.scan_id,
                        title=f"Compliance Violation - {framework.value.upper()}",
                        description=f"System does not meet {framework.value} compliance requirements",
                        risk_level=RiskLevel.HIGH,
                        attack_vector=AttackVector.CONFIGURATION_ERROR,
                        threat_category=ThreatCategory.IMPACT,
                        affected_endpoint=config.attack_surface.target_url,
                        evidence={
                            "framework": framework.value,
                            "violations": self._get_violations(
                                framework, result.findings
                            ),
                        },
                        remediation=f"Remediate security findings to meet {framework.value} compliance",
                        compliance_violations=[framework],
                    )
                )

        await asyncio.sleep(0.05)

    async def _validate_compliance(
        self, framework: ComplianceFramework, findings: List[ScanFinding]
    ) -> bool:
        """Validate compliance against a specific framework."""
        if framework not in self.compliance_requirements:
            return True

        requirements = self.compliance_requirements[framework]
        prohibited = requirements.get("prohibited_vulnerabilities", [])

        # Check if any findings violate compliance
        for finding in findings:
            if finding.risk_level in prohibited:
                return False

        return True

    def _get_violations(
        self, framework: ComplianceFramework, findings: List[ScanFinding]
    ) -> List[Dict[str, Any]]:
        """Get compliance violations for a framework."""
        violations = []

        if framework not in self.compliance_requirements:
            return violations

        requirements = self.compliance_requirements[framework]
        prohibited = requirements.get("prohibited_vulnerabilities", [])

        for finding in findings:
            if finding.risk_level in prohibited:
                violations.append(
                    {
                        "finding_id": finding.id,
                        "title": finding.title,
                        "risk_level": finding.risk_level.value,
                    }
                )

        return violations

    async def _phase_risk_scoring(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 7: Risk scoring and prioritization."""
        # Calculate aggregate risk scores
        for finding in result.findings:
            # Calculate CVSS if not set
            if finding.cvss_score == 0.0:
                finding.cvss_score = self._calculate_cvss(finding)

        # Sort findings by risk level and CVSS score
        risk_order = ["info", "low", "medium", "high", "critical"]
        result.findings.sort(
            key=lambda f: (
                risk_order.index(f.risk_level.value),
                f.cvss_score,
            ),
            reverse=True,
        )

        await asyncio.sleep(0.05)

    def _calculate_cvss(self, finding: ScanFinding) -> float:
        """Calculate CVSS score for a finding."""
        base_scores = {
            RiskLevel.CRITICAL: 9.0,
            RiskLevel.HIGH: 7.0,
            RiskLevel.MEDIUM: 5.0,
            RiskLevel.LOW: 3.0,
            RiskLevel.INFO: 0.0,
        }

        base_score = base_scores.get(finding.risk_level, 0.0)

        # Adjust based on exploit success
        if finding.exploit_successful:
            base_score = min(10.0, base_score + 1.0)

        return base_score

    async def _phase_attack_path_generation(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 8: Generate attack paths and chains."""
        # Group findings by threat category
        category_findings: Dict[ThreatCategory, List[ScanFinding]] = {}
        for finding in result.findings:
            if finding.threat_category not in category_findings:
                category_findings[finding.threat_category] = []
            category_findings[finding.threat_category].append(finding)

        # Generate attack paths
        attack_paths = []

        # Example: Initial Access -> Privilege Escalation -> Impact
        if (
            ThreatCategory.INITIAL_ACCESS in category_findings
            and ThreatCategory.CREDENTIAL_ACCESS in category_findings
        ):
            attack_paths.append(
                {
                    "id": str(uuid.uuid4()),
                    "name": "Initial Access to Credential Theft",
                    "steps": [
                        {
                            "stage": ThreatCategory.INITIAL_ACCESS.value,
                            "findings": [
                                f.id
                                for f in category_findings[
                                    ThreatCategory.INITIAL_ACCESS
                                ]
                            ],
                        },
                        {
                            "stage": ThreatCategory.CREDENTIAL_ACCESS.value,
                            "findings": [
                                f.id
                                for f in category_findings[
                                    ThreatCategory.CREDENTIAL_ACCESS
                                ]
                            ],
                        },
                    ],
                    "risk_level": "critical",
                    "likelihood": "high",
                }
            )

        if ThreatCategory.EXECUTION in category_findings:
            attack_paths.append(
                {
                    "id": str(uuid.uuid4()),
                    "name": "Code Execution Chain",
                    "steps": [
                        {
                            "stage": ThreatCategory.EXECUTION.value,
                            "findings": [
                                f.id
                                for f in category_findings[ThreatCategory.EXECUTION]
                            ],
                        },
                    ],
                    "risk_level": "high",
                    "likelihood": "medium",
                }
            )

        result.attack_paths = attack_paths
        await asyncio.sleep(0.05)

    def _generate_scan_summary(self, result: MicroScanResult) -> Dict[str, Any]:
        """Generate summary of scan results."""
        findings_by_risk = {}
        for level in RiskLevel:
            count = sum(1 for f in result.findings if f.risk_level == level)
            findings_by_risk[level.value] = count

        findings_by_vector = {}
        for vector in AttackVector:
            count = sum(1 for f in result.findings if f.attack_vector == vector)
            if count > 0:
                findings_by_vector[vector.value] = count

        compliant_frameworks = [
            f for f, status in result.compliance_status.items() if status
        ]
        non_compliant_frameworks = [
            f for f, status in result.compliance_status.items() if not status
        ]

        return {
            "total_findings": len(result.findings),
            "findings_by_risk": findings_by_risk,
            "findings_by_vector": findings_by_vector,
            "attack_paths_count": len(result.attack_paths),
            "compliant_frameworks": compliant_frameworks,
            "non_compliant_frameworks": non_compliant_frameworks,
            "exploit_success_count": sum(
                1 for f in result.findings if f.exploit_successful
            ),
            "execution_time_seconds": result.execution_time_seconds,
        }

    def _create_audit_log(
        self,
        tenant_id: str,
        organization_id: str,
        user_id: str,
        action: str,
        resource_type: str,
        resource_id: str,
        details: Dict[str, Any],
        result: str = "success",
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ):
        """Create an audit log entry."""
        log = AuditLog(
            tenant_id=tenant_id,
            organization_id=organization_id,
            user_id=user_id,
            action=action,
            resource_type=resource_type,
            resource_id=resource_id,
            details=details,
            ip_address=ip_address,
            user_agent=user_agent,
            result=result,
        )

        self.audit_logs.append(log)
        logger.info(
            f"Audit log created: {action} on {resource_type}/{resource_id} by {user_id}"
        )

    async def get_scan_result(self, scan_id: str) -> Optional[MicroScanResult]:
        """Get scan result by ID."""
        return self.active_scans.get(scan_id)

    async def list_scans(
        self,
        tenant_id: Optional[str] = None,
        organization_id: Optional[str] = None,
        status: Optional[MicroScanStatus] = None,
    ) -> List[MicroScanResult]:
        """List scans with optional filtering."""
        scans = list(self.active_scans.values())

        if tenant_id:
            scans = [s for s in scans if s.config and s.config.tenant_id == tenant_id]

        if organization_id:
            scans = [
                s
                for s in scans
                if s.config and s.config.organization_id == organization_id
            ]

        if status:
            scans = [s for s in scans if s.status == status]

        return scans

    async def cancel_scan(self, scan_id: str, user_id: str) -> bool:
        """Cancel a running scan."""
        if scan_id not in self.active_scans:
            return False

        result = self.active_scans[scan_id]

        if result.status == MicroScanStatus.RUNNING:
            result.status = MicroScanStatus.CANCELLED
            result.completed_at = datetime.utcnow()

            if self.enable_audit_logging and result.config:
                self._create_audit_log(
                    tenant_id=result.config.tenant_id,
                    organization_id=result.config.organization_id,
                    user_id=user_id,
                    action="cancel_micro_scan",
                    resource_type="micro_scan",
                    resource_id=scan_id,
                    details={},
                )

            logger.info(f"Cancelled scan {scan_id}")
            return True

        return False

    async def get_audit_logs(
        self,
        tenant_id: Optional[str] = None,
        organization_id: Optional[str] = None,
        user_id: Optional[str] = None,
        action: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[AuditLog]:
        """Get audit logs with filtering."""
        logs = self.audit_logs

        if tenant_id:
            logs = [log for log in logs if log.tenant_id == tenant_id]

        if organization_id:
            logs = [log for log in logs if log.organization_id == organization_id]

        if user_id:
            logs = [log for log in logs if log.user_id == user_id]

        if action:
            logs = [log for log in logs if log.action == action]

        if start_date:
            logs = [log for log in logs if log.timestamp >= start_date]

        if end_date:
            logs = [log for log in logs if log.timestamp <= end_date]

        # Sort by timestamp descending
        logs.sort(key=lambda x: x.timestamp, reverse=True)

        return logs[:limit]

    async def get_health(self) -> Dict[str, Any]:
        """Get health status of the micro pentest engine."""
        return {
            "status": "healthy",
            "active_scans": len(
                [
                    s
                    for s in self.active_scans.values()
                    if s.status == MicroScanStatus.RUNNING
                ]
            ),
            "total_scans": len(self.active_scans),
            "audit_logs_count": len(self.audit_logs),
            "supported_attack_vectors": len(self.attack_tests),
            "supported_compliance_frameworks": len(self.compliance_requirements),
        }


# Global instance
micro_pentest_engine = MicroPentestEngine()
