"""Enterprise Micro Penetration Testing Engine.

This service provides automated, targeted micro penetration testing capabilities
for enterprise environments with advanced threat modeling, attack surface analysis,
and compliance tracking.
"""

import asyncio
import json
import logging
import time
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class ThreatCategory(Enum):
    """MITRE ATT&CK-aligned threat categories."""

    INITIAL_ACCESS = "initial_access"
    EXECUTION = "execution"
    PERSISTENCE = "persistence"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DEFENSE_EVASION = "defense_evasion"
    CREDENTIAL_ACCESS = "credential_access"
    DISCOVERY = "discovery"
    LATERAL_MOVEMENT = "lateral_movement"
    COLLECTION = "collection"
    EXFILTRATION = "exfiltration"
    COMMAND_AND_CONTROL = "command_and_control"
    IMPACT = "impact"


class AttackVector(Enum):
    """Attack vectors for micro pen testing."""

    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    SSRF = "ssrf"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_BYPASS = "authorization_bypass"
    SESSION_HIJACKING = "session_hijacking"
    API_ABUSE = "api_abuse"
    CRYPTOGRAPHIC_WEAKNESS = "cryptographic_weakness"
    CONFIGURATION_ERROR = "configuration_error"
    DEPENDENCY_VULNERABILITY = "dependency_vulnerability"
    SECRETS_EXPOSURE = "secrets_exposure"
    CONTAINER_ESCAPE = "container_escape"
    CLOUD_MISCONFIGURATION = "cloud_misconfiguration"


class ScanMode(Enum):
    """Scan modes for different testing scenarios."""

    PASSIVE = "passive"  # Non-intrusive reconnaissance
    ACTIVE = "active"  # Active probing and testing
    AGGRESSIVE = "aggressive"  # Full exploitation attempts
    STEALTH = "stealth"  # Evasive testing


class ComplianceFramework(Enum):
    """Compliance frameworks for validation."""

    SOC2 = "soc2"
    ISO27001 = "iso27001"
    PCI_DSS = "pci_dss"
    HIPAA = "hipaa"
    GDPR = "gdpr"
    NIST_800_53 = "nist_800_53"
    CIS = "cis"
    OWASP_TOP_10 = "owasp_top_10"


class MicroScanStatus(Enum):
    """Status of micro penetration test."""

    QUEUED = "queued"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class RiskLevel(Enum):
    """Risk level assessment."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class AttackSurface:
    """Attack surface definition for micro pen testing."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    target_url: str = ""
    target_type: str = ""  # api, web_app, mobile_app, infrastructure, cloud
    endpoints: List[str] = field(default_factory=list)
    authentication_required: bool = False
    authentication_type: Optional[str] = None
    headers: Dict[str, str] = field(default_factory=dict)
    cookies: Dict[str, str] = field(default_factory=dict)
    parameters: Dict[str, Any] = field(default_factory=dict)
    technologies: List[str] = field(default_factory=list)
    environment: str = "development"  # development, staging, production
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ThreatModel:
    """Threat model for micro pen testing."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    description: str = ""
    categories: List[ThreatCategory] = field(default_factory=list)
    attack_vectors: List[AttackVector] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    owasp_categories: List[str] = field(default_factory=list)
    priority: int = 5  # 1-10, 10 being highest
    compliance_frameworks: List[ComplianceFramework] = field(default_factory=list)
    test_cases: List[str] = field(default_factory=list)
    expected_findings: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class MicroScanConfig:
    """Configuration for micro penetration test scan."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    attack_surface: AttackSurface = field(default_factory=AttackSurface)
    threat_model: ThreatModel = field(default_factory=ThreatModel)
    scan_mode: ScanMode = ScanMode.ACTIVE
    timeout_seconds: int = 300
    max_threads: int = 5
    rate_limit_rps: int = 10
    stop_on_critical: bool = True
    include_proof_of_concept: bool = True
    tenant_id: str = ""
    organization_id: str = ""
    created_by: str = ""
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ScanFinding:
    """Individual finding from micro pen test."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    scan_id: str = ""
    title: str = ""
    description: str = ""
    risk_level: RiskLevel = RiskLevel.INFO
    cvss_score: float = 0.0
    attack_vector: AttackVector = AttackVector.API_ABUSE
    threat_category: ThreatCategory = ThreatCategory.INITIAL_ACCESS
    affected_endpoint: str = ""
    exploit_successful: bool = False
    evidence: Dict[str, Any] = field(default_factory=dict)
    proof_of_concept: Optional[str] = None
    remediation: str = ""
    cwe_ids: List[str] = field(default_factory=list)
    owasp_references: List[str] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    compliance_violations: List[ComplianceFramework] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class MicroScanResult:
    """Result of micro penetration test."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    scan_id: str = ""
    config: Optional[MicroScanConfig] = None
    status: MicroScanStatus = MicroScanStatus.QUEUED
    findings: List[ScanFinding] = field(default_factory=list)
    summary: Dict[str, Any] = field(default_factory=dict)
    attack_paths: List[Dict[str, Any]] = field(default_factory=list)
    compliance_status: Dict[ComplianceFramework, bool] = field(default_factory=dict)
    execution_time_seconds: float = 0.0
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AuditLog:
    """Audit log entry for compliance tracking."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.utcnow)
    tenant_id: str = ""
    organization_id: str = ""
    user_id: str = ""
    action: str = ""
    resource_type: str = ""
    resource_id: str = ""
    details: Dict[str, Any] = field(default_factory=dict)
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    result: str = "success"  # success, failure, error
    metadata: Dict[str, Any] = field(default_factory=dict)


class MicroPentestEngine:
    """Enterprise Micro Penetration Testing Engine.

    Provides automated, targeted security testing with:
    - Advanced threat modeling
    - Attack surface analysis
    - Compliance tracking
    - Audit logging
    - Multi-tenant support
    """

    def __init__(
        self,
        db_path: str = "data/micro_pentest.db",
        enable_audit_logging: bool = True,
    ):
        """Initialize the micro pentest engine."""
        self.db_path = db_path
        self.enable_audit_logging = enable_audit_logging
        self.active_scans: Dict[str, MicroScanResult] = {}
        self.audit_logs: List[AuditLog] = []

        # Attack vector test definitions
        self.attack_tests = self._initialize_attack_tests()

        # Compliance requirements mapping
        self.compliance_requirements = self._initialize_compliance_requirements()

    def _initialize_attack_tests(self) -> Dict[AttackVector, List[Dict[str, Any]]]:
        """Initialize attack test definitions."""
        return {
            AttackVector.SQL_INJECTION: [
                {
                    "name": "Basic SQL Injection",
                    "payloads": [
                        "' OR '1'='1",
                        "'; DROP TABLE users--",
                        "' UNION SELECT NULL--",
                    ],
                    "detection": ["sql", "database", "syntax error"],
                },
                {
                    "name": "Blind SQL Injection",
                    "payloads": ["' AND SLEEP(5)--", "' AND 1=1--", "' AND 1=2--"],
                    "detection": ["time_delay", "boolean_based"],
                },
            ],
            AttackVector.XSS: [
                {
                    "name": "Reflected XSS",
                    "payloads": [
                        "<script>alert('XSS')</script>",
                        "<img src=x onerror=alert(1)>",
                    ],
                    "detection": ["<script>", "onerror", "javascript:"],
                },
                {
                    "name": "Stored XSS",
                    "payloads": ["<script>document.write('XSS')</script>"],
                    "detection": ["persistent_script", "stored_payload"],
                },
            ],
            AttackVector.AUTHENTICATION_BYPASS: [
                {
                    "name": "JWT Token Manipulation",
                    "payloads": [
                        "modified_signature",
                        "algorithm_none",
                        "expired_token",
                    ],
                    "detection": ["unauthorized_access", "token_validation_bypass"],
                },
                {
                    "name": "Session Fixation",
                    "payloads": ["fixed_session_id", "session_prediction"],
                    "detection": ["session_reuse", "predictable_session"],
                },
            ],
            AttackVector.API_ABUSE: [
                {
                    "name": "Rate Limiting Test",
                    "payloads": ["bulk_requests"],
                    "detection": ["no_rate_limit", "excessive_requests"],
                },
                {
                    "name": "Mass Assignment",
                    "payloads": ["additional_fields", "privilege_escalation_fields"],
                    "detection": ["unexpected_field_update", "role_change"],
                },
            ],
            AttackVector.SECRETS_EXPOSURE: [
                {
                    "name": "Environment Variable Leakage",
                    "payloads": ["debug_mode", "error_disclosure"],
                    "detection": ["api_key", "secret", "password", "token"],
                },
                {
                    "name": "Source Code Exposure",
                    "payloads": [".git/config", ".env", "config.json"],
                    "detection": ["source_files", "configuration_files"],
                },
            ],
        }

    def _initialize_compliance_requirements(
        self,
    ) -> Dict[ComplianceFramework, Dict[str, Any]]:
        """Initialize compliance requirements mapping."""
        return {
            ComplianceFramework.SOC2: {
                "required_controls": [
                    "authentication",
                    "authorization",
                    "encryption",
                    "audit_logging",
                    "incident_response",
                ],
                "prohibited_vulnerabilities": [
                    RiskLevel.CRITICAL,
                    RiskLevel.HIGH,
                ],
            },
            ComplianceFramework.PCI_DSS: {
                "required_controls": [
                    "encryption_at_rest",
                    "encryption_in_transit",
                    "access_control",
                    "monitoring",
                    "vulnerability_management",
                ],
                "prohibited_vulnerabilities": [
                    RiskLevel.CRITICAL,
                    RiskLevel.HIGH,
                ],
            },
            ComplianceFramework.OWASP_TOP_10: {
                "required_controls": [
                    "injection_prevention",
                    "authentication",
                    "data_exposure_prevention",
                    "xxe_prevention",
                    "access_control",
                ],
                "prohibited_vulnerabilities": [
                    RiskLevel.CRITICAL,
                    RiskLevel.HIGH,
                ],
            },
        }

    async def create_micro_scan(
        self, config: MicroScanConfig, user_id: str
    ) -> MicroScanResult:
        """Create and queue a new micro penetration test scan."""
        scan_id = str(uuid.uuid4())

        result = MicroScanResult(
            id=str(uuid.uuid4()),
            scan_id=scan_id,
            config=config,
            status=MicroScanStatus.QUEUED,
        )

        self.active_scans[scan_id] = result

        # Audit log
        if self.enable_audit_logging:
            self._create_audit_log(
                tenant_id=config.tenant_id,
                organization_id=config.organization_id,
                user_id=user_id,
                action="create_micro_scan",
                resource_type="micro_scan",
                resource_id=scan_id,
                details={
                    "config": config.name,
                    "target": config.attack_surface.target_url,
                },
            )

        logger.info(
            f"Created micro scan {scan_id} for target {config.attack_surface.target_url}"
        )
        return result

    async def execute_micro_scan(self, scan_id: str, user_id: str) -> MicroScanResult:
        """Execute a micro penetration test scan."""
        if scan_id not in self.active_scans:
            raise ValueError(f"Scan {scan_id} not found")

        result = self.active_scans[scan_id]
        config = result.config

        if not config:
            raise ValueError("Scan configuration not found")

        result.status = MicroScanStatus.RUNNING
        result.started_at = datetime.utcnow()

        logger.info(f"Starting micro scan {scan_id}")

        try:
            start_time = time.time()

            # Phase 1: Reconnaissance
            await self._phase_reconnaissance(result, config)

            # Phase 2: Threat modeling
            await self._phase_threat_modeling(result, config)

            # Phase 3: Attack surface mapping
            await self._phase_attack_surface_mapping(result, config)

            # Phase 4: Vulnerability testing
            await self._phase_vulnerability_testing(result, config)

            # Phase 5: Exploitation attempts
            if config.scan_mode in [ScanMode.ACTIVE, ScanMode.AGGRESSIVE]:
                await self._phase_exploitation(result, config)

            # Phase 6: Compliance validation
            await self._phase_compliance_validation(result, config)

            # Phase 7: Risk scoring and prioritization
            await self._phase_risk_scoring(result, config)

            # Phase 8: Generate attack paths
            await self._phase_attack_path_generation(result, config)

            result.execution_time_seconds = time.time() - start_time
            result.status = MicroScanStatus.COMPLETED
            result.completed_at = datetime.utcnow()

            # Generate summary
            result.summary = self._generate_scan_summary(result)

            # Audit log
            if self.enable_audit_logging:
                self._create_audit_log(
                    tenant_id=config.tenant_id,
                    organization_id=config.organization_id,
                    user_id=user_id,
                    action="execute_micro_scan",
                    resource_type="micro_scan",
                    resource_id=scan_id,
                    details={
                        "findings_count": len(result.findings),
                        "critical_count": sum(
                            1
                            for f in result.findings
                            if f.risk_level == RiskLevel.CRITICAL
                        ),
                        "execution_time": result.execution_time_seconds,
                    },
                )

            logger.info(
                f"Completed micro scan {scan_id}: {len(result.findings)} findings in "
                f"{result.execution_time_seconds:.2f}s"
            )

        except Exception as e:
            result.status = MicroScanStatus.FAILED
            result.error_message = str(e)
            result.completed_at = datetime.utcnow()

            logger.error(f"Micro scan {scan_id} failed: {e}")

            if self.enable_audit_logging:
                self._create_audit_log(
                    tenant_id=config.tenant_id,
                    organization_id=config.organization_id,
                    user_id=user_id,
                    action="execute_micro_scan",
                    resource_type="micro_scan",
                    resource_id=scan_id,
                    details={"error": str(e)},
                    result="error",
                )

        return result

    async def _phase_reconnaissance(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 1: Reconnaissance and information gathering."""
        logger.info("Phase 1: Reconnaissance")

        attack_surface = config.attack_surface

        # Simulate reconnaissance activities
        # In production, this would perform actual network scanning, service detection, etc.
        findings = []

        # Check for information disclosure
        if "X-Powered-By" in attack_surface.headers:
            findings.append(
                ScanFinding(
                    scan_id=result.scan_id,
                    title="Information Disclosure - Technology Stack",
                    description=f"Server reveals technology stack: {attack_surface.headers['X-Powered-By']}",
                    risk_level=RiskLevel.LOW,
                    attack_vector=AttackVector.CONFIGURATION_ERROR,
                    threat_category=ThreatCategory.DISCOVERY,
                    affected_endpoint=attack_surface.target_url,
                    evidence={
                        "header": "X-Powered-By",
                        "value": attack_surface.headers["X-Powered-By"],
                    },
                    remediation="Remove or obscure technology-revealing headers",
                    owasp_references=["A05:2021-Security Misconfiguration"],
                )
            )

        # Check for debug mode
        if (
            attack_surface.environment == "production"
            and "debug" in attack_surface.metadata
        ):
            findings.append(
                ScanFinding(
                    scan_id=result.scan_id,
                    title="Debug Mode Enabled in Production",
                    description="Debug mode is enabled in production environment",
                    risk_level=RiskLevel.HIGH,
                    attack_vector=AttackVector.CONFIGURATION_ERROR,
                    threat_category=ThreatCategory.DISCOVERY,
                    affected_endpoint=attack_surface.target_url,
                    evidence={"environment": "production", "debug_enabled": True},
                    remediation="Disable debug mode in production",
                    owasp_references=["A05:2021-Security Misconfiguration"],
                    cwe_ids=["CWE-489"],
                )
            )

        result.findings.extend(findings)
        await asyncio.sleep(0.1)  # Simulate work

    async def _phase_threat_modeling(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 2: Threat modeling based on attack surface."""
        logger.info("Phase 2: Threat Modeling")

        threat_model = config.threat_model

        # Map threat categories to test cases
        for category in threat_model.categories:
            logger.debug(f"Analyzing threat category: {category.value}")

        # Map attack vectors to specific tests
        for vector in threat_model.attack_vectors:
            logger.debug(f"Preparing tests for attack vector: {vector.value}")

        await asyncio.sleep(0.1)  # Simulate work

    async def _phase_attack_surface_mapping(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 3: Attack surface mapping and endpoint discovery."""
        logger.info("Phase 3: Attack Surface Mapping")

        attack_surface = config.attack_surface

        # Simulate endpoint discovery
        discovered_endpoints = []
        for endpoint in attack_surface.endpoints:
            discovered_endpoints.append(
                {
                    "url": f"{attack_surface.target_url}{endpoint}",
                    "methods": ["GET", "POST", "PUT", "DELETE"],
                    "requires_auth": attack_surface.authentication_required,
                }
            )

        result.metadata["discovered_endpoints"] = discovered_endpoints
        await asyncio.sleep(0.1)  # Simulate work

    async def _phase_vulnerability_testing(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 4: Vulnerability testing based on threat model."""
        logger.info("Phase 4: Vulnerability Testing")

        threat_model = config.threat_model
        attack_surface = config.attack_surface

        # Test each attack vector in the threat model
        for vector in threat_model.attack_vectors:
            if vector in self.attack_tests:
                tests = self.attack_tests[vector]

                for test in tests:
                    # Simulate vulnerability testing
                    # In production, this would execute actual security tests
                    finding = await self._execute_vulnerability_test(
                        result.scan_id,
                        vector,
                        test,
                        attack_surface,
                        config.scan_mode,
                    )

                    if finding:
                        result.findings.append(finding)

                    # Rate limiting
                    await asyncio.sleep(1.0 / config.rate_limit_rps)

                    # Stop on critical if configured
                    if (
                        config.stop_on_critical
                        and finding
                        and finding.risk_level == RiskLevel.CRITICAL
                    ):
                        logger.warning("Critical vulnerability found, stopping scan")
                        return

    async def _execute_vulnerability_test(
        self,
        scan_id: str,
        vector: AttackVector,
        test: Dict[str, Any],
        attack_surface: AttackSurface,
        scan_mode: ScanMode,
    ) -> Optional[ScanFinding]:
        """Execute a specific vulnerability test."""
        # Simulate vulnerability testing logic
        # In production, this would perform actual security testing

        # For demonstration, simulate finding vulnerabilities
        if vector == AttackVector.SQL_INJECTION and "api" in attack_surface.target_type:
            return ScanFinding(
                scan_id=scan_id,
                title=f"Potential SQL Injection - {test['name']}",
                description=f"SQL injection vulnerability detected in {attack_surface.target_url}",
                risk_level=RiskLevel.HIGH,
                cvss_score=8.5,
                attack_vector=vector,
                threat_category=ThreatCategory.INITIAL_ACCESS,
                affected_endpoint=f"{attack_surface.target_url}/api/users",
                exploit_successful=False,
                evidence={
                    "test_type": test["name"],
                    "payloads_tested": len(test["payloads"]),
                    "detection_methods": test["detection"],
                },
                remediation="Use parameterized queries or prepared statements. Implement input validation.",
                cwe_ids=["CWE-89"],
                owasp_references=["A03:2021-Injection"],
                mitre_techniques=["T1190"],
            )

        if (
            vector == AttackVector.AUTHENTICATION_BYPASS
            and attack_surface.authentication_required
        ):
            return ScanFinding(
                scan_id=scan_id,
                title=f"Authentication Weakness - {test['name']}",
                description=f"Authentication bypass potential in {attack_surface.target_url}",
                risk_level=RiskLevel.CRITICAL,
                cvss_score=9.1,
                attack_vector=vector,
                threat_category=ThreatCategory.CREDENTIAL_ACCESS,
                affected_endpoint=f"{attack_surface.target_url}/auth/login",
                exploit_successful=False,
                evidence={
                    "test_type": test["name"],
                    "authentication_type": attack_surface.authentication_type,
                },
                remediation="Implement secure authentication mechanisms. Use strong session management.",
                cwe_ids=["CWE-287"],
                owasp_references=[
                    "A07:2021-Identification and Authentication Failures"
                ],
                mitre_techniques=["T1078"],
            )

        return None

    async def _phase_exploitation(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 5: Exploitation attempts for confirmed vulnerabilities."""
        logger.info("Phase 5: Exploitation")

        # Only attempt exploitation in active/aggressive modes
        if config.scan_mode not in [ScanMode.ACTIVE, ScanMode.AGGRESSIVE]:
            return

        high_risk_findings = [
            f
            for f in result.findings
            if f.risk_level in [RiskLevel.CRITICAL, RiskLevel.HIGH]
        ]

        for finding in high_risk_findings:
            if config.include_proof_of_concept:
                # Generate proof of concept
                poc = await self._generate_proof_of_concept(finding, config)
                finding.proof_of_concept = poc

                # Simulate exploitation attempt
                # In production, this would perform controlled exploitation
                if finding.attack_vector == AttackVector.SQL_INJECTION:
                    finding.exploit_successful = False  # Simulated result
                    finding.evidence["exploitation_attempted"] = True
                    finding.evidence["exploitation_result"] = "Blocked by WAF"

        await asyncio.sleep(0.1)  # Simulate work

    async def _generate_proof_of_concept(
        self, finding: ScanFinding, config: MicroScanConfig
    ) -> str:
        """Generate proof of concept for a finding."""
        poc_template = f"""
# Proof of Concept: {finding.title}

## Vulnerability Details
- Risk Level: {finding.risk_level.value}
- CVSS Score: {finding.cvss_score}
- Attack Vector: {finding.attack_vector.value}
- Affected Endpoint: {finding.affected_endpoint}

## Reproduction Steps
1. Navigate to {finding.affected_endpoint}
2. Inject test payload
3. Observe vulnerability behavior

## Evidence
{json.dumps(finding.evidence, indent=2)}

## Remediation
{finding.remediation}

---
Generated by FixOps Enterprise Micro Pentest Engine
Scan ID: {finding.scan_id}
        """
        return poc_template.strip()

    async def _phase_compliance_validation(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 6: Compliance validation against frameworks."""
        logger.info("Phase 6: Compliance Validation")

        threat_model = config.threat_model

        for framework in threat_model.compliance_frameworks:
            is_compliant = await self._validate_compliance(framework, result.findings)
            result.compliance_status[framework] = is_compliant

            if not is_compliant:
                # Add compliance violation finding
                result.findings.append(
                    ScanFinding(
                        scan_id=result.scan_id,
                        title=f"Compliance Violation - {framework.value.upper()}",
                        description=f"System does not meet {framework.value} compliance requirements",
                        risk_level=RiskLevel.HIGH,
                        attack_vector=AttackVector.CONFIGURATION_ERROR,
                        threat_category=ThreatCategory.IMPACT,
                        affected_endpoint=config.attack_surface.target_url,
                        evidence={
                            "framework": framework.value,
                            "violations": self._get_violations(
                                framework, result.findings
                            ),
                        },
                        remediation=f"Remediate security findings to meet {framework.value} compliance",
                        compliance_violations=[framework],
                    )
                )

        await asyncio.sleep(0.1)  # Simulate work

    async def _validate_compliance(
        self, framework: ComplianceFramework, findings: List[ScanFinding]
    ) -> bool:
        """Validate compliance against a specific framework."""
        if framework not in self.compliance_requirements:
            return True

        requirements = self.compliance_requirements[framework]
        prohibited = requirements.get("prohibited_vulnerabilities", [])

        # Check if any findings violate compliance
        for finding in findings:
            if finding.risk_level in prohibited:
                return False

        return True

    def _get_violations(
        self, framework: ComplianceFramework, findings: List[ScanFinding]
    ) -> List[Dict[str, Any]]:
        """Get compliance violations for a framework."""
        violations = []

        if framework not in self.compliance_requirements:
            return violations

        requirements = self.compliance_requirements[framework]
        prohibited = requirements.get("prohibited_vulnerabilities", [])

        for finding in findings:
            if finding.risk_level in prohibited:
                violations.append(
                    {
                        "finding_id": finding.id,
                        "title": finding.title,
                        "risk_level": finding.risk_level.value,
                    }
                )

        return violations

    async def _phase_risk_scoring(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 7: Risk scoring and prioritization."""
        logger.info("Phase 7: Risk Scoring")

        # Calculate aggregate risk scores
        for finding in result.findings:
            # Calculate CVSS if not set
            if finding.cvss_score == 0.0:
                finding.cvss_score = self._calculate_cvss(finding)

        # Sort findings by risk level and CVSS score
        result.findings.sort(
            key=lambda f: (
                ["info", "low", "medium", "high", "critical"].index(f.risk_level.value),
                f.cvss_score,
            ),
            reverse=True,
        )

        await asyncio.sleep(0.1)  # Simulate work

    def _calculate_cvss(self, finding: ScanFinding) -> float:
        """Calculate CVSS score for a finding."""
        # Simplified CVSS calculation
        base_scores = {
            RiskLevel.CRITICAL: 9.0,
            RiskLevel.HIGH: 7.0,
            RiskLevel.MEDIUM: 5.0,
            RiskLevel.LOW: 3.0,
            RiskLevel.INFO: 0.0,
        }

        base_score = base_scores.get(finding.risk_level, 0.0)

        # Adjust based on exploit success
        if finding.exploit_successful:
            base_score = min(10.0, base_score + 1.0)

        return base_score

    async def _phase_attack_path_generation(
        self, result: MicroScanResult, config: MicroScanConfig
    ):
        """Phase 8: Generate attack paths and chains."""
        logger.info("Phase 8: Attack Path Generation")

        # Group findings by threat category
        category_findings: Dict[ThreatCategory, List[ScanFinding]] = {}
        for finding in result.findings:
            if finding.threat_category not in category_findings:
                category_findings[finding.threat_category] = []
            category_findings[finding.threat_category].append(finding)

        # Generate attack paths
        attack_paths = []

        # Example: Initial Access -> Privilege Escalation -> Impact
        if (
            ThreatCategory.INITIAL_ACCESS in category_findings
            and ThreatCategory.PRIVILEGE_ESCALATION in category_findings
        ):
            attack_paths.append(
                {
                    "id": str(uuid.uuid4()),
                    "name": "Initial Access to Privilege Escalation",
                    "steps": [
                        {
                            "stage": ThreatCategory.INITIAL_ACCESS.value,
                            "findings": [
                                f.id
                                for f in category_findings[
                                    ThreatCategory.INITIAL_ACCESS
                                ]
                            ],
                        },
                        {
                            "stage": ThreatCategory.PRIVILEGE_ESCALATION.value,
                            "findings": [
                                f.id
                                for f in category_findings[
                                    ThreatCategory.PRIVILEGE_ESCALATION
                                ]
                            ],
                        },
                    ],
                    "risk_level": "high",
                    "likelihood": "medium",
                }
            )

        result.attack_paths = attack_paths
        await asyncio.sleep(0.1)  # Simulate work

    def _generate_scan_summary(self, result: MicroScanResult) -> Dict[str, Any]:
        """Generate summary of scan results."""
        findings_by_risk = {}
        for level in RiskLevel:
            count = sum(1 for f in result.findings if f.risk_level == level)
            findings_by_risk[level.value] = count

        findings_by_vector = {}
        for vector in AttackVector:
            count = sum(1 for f in result.findings if f.attack_vector == vector)
            if count > 0:
                findings_by_vector[vector.value] = count

        compliant_frameworks = [
            f.value for f, status in result.compliance_status.items() if status
        ]
        non_compliant_frameworks = [
            f.value for f, status in result.compliance_status.items() if not status
        ]

        return {
            "total_findings": len(result.findings),
            "findings_by_risk": findings_by_risk,
            "findings_by_vector": findings_by_vector,
            "attack_paths_count": len(result.attack_paths),
            "compliant_frameworks": compliant_frameworks,
            "non_compliant_frameworks": non_compliant_frameworks,
            "exploit_success_count": sum(
                1 for f in result.findings if f.exploit_successful
            ),
            "execution_time_seconds": result.execution_time_seconds,
        }

    def _create_audit_log(
        self,
        tenant_id: str,
        organization_id: str,
        user_id: str,
        action: str,
        resource_type: str,
        resource_id: str,
        details: Dict[str, Any],
        result: str = "success",
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ):
        """Create an audit log entry."""
        log = AuditLog(
            tenant_id=tenant_id,
            organization_id=organization_id,
            user_id=user_id,
            action=action,
            resource_type=resource_type,
            resource_id=resource_id,
            details=details,
            ip_address=ip_address,
            user_agent=user_agent,
            result=result,
        )

        self.audit_logs.append(log)
        logger.info(
            f"Audit log created: {action} on {resource_type}/{resource_id} by {user_id}"
        )

    async def get_scan_result(self, scan_id: str) -> Optional[MicroScanResult]:
        """Get scan result by ID."""
        return self.active_scans.get(scan_id)

    async def list_scans(
        self,
        tenant_id: Optional[str] = None,
        organization_id: Optional[str] = None,
        status: Optional[MicroScanStatus] = None,
    ) -> List[MicroScanResult]:
        """List scans with optional filtering."""
        scans = list(self.active_scans.values())

        if tenant_id:
            scans = [s for s in scans if s.config and s.config.tenant_id == tenant_id]

        if organization_id:
            scans = [
                s
                for s in scans
                if s.config and s.config.organization_id == organization_id
            ]

        if status:
            scans = [s for s in scans if s.status == status]

        return scans

    async def cancel_scan(self, scan_id: str, user_id: str) -> bool:
        """Cancel a running scan."""
        if scan_id not in self.active_scans:
            return False

        result = self.active_scans[scan_id]

        if result.status == MicroScanStatus.RUNNING:
            result.status = MicroScanStatus.CANCELLED
            result.completed_at = datetime.utcnow()

            if self.enable_audit_logging and result.config:
                self._create_audit_log(
                    tenant_id=result.config.tenant_id,
                    organization_id=result.config.organization_id,
                    user_id=user_id,
                    action="cancel_micro_scan",
                    resource_type="micro_scan",
                    resource_id=scan_id,
                    details={},
                )

            logger.info(f"Cancelled scan {scan_id}")
            return True

        return False

    async def get_audit_logs(
        self,
        tenant_id: Optional[str] = None,
        organization_id: Optional[str] = None,
        user_id: Optional[str] = None,
        action: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[AuditLog]:
        """Get audit logs with filtering."""
        logs = self.audit_logs

        if tenant_id:
            logs = [log for log in logs if log.tenant_id == tenant_id]

        if organization_id:
            logs = [log for log in logs if log.organization_id == organization_id]

        if user_id:
            logs = [log for log in logs if log.user_id == user_id]

        if action:
            logs = [log for log in logs if log.action == action]

        if start_date:
            logs = [log for log in logs if log.timestamp >= start_date]

        if end_date:
            logs = [log for log in logs if log.timestamp <= end_date]

        # Sort by timestamp descending
        logs.sort(key=lambda x: x.timestamp, reverse=True)

        return logs[:limit]


# Global instance
micro_pentest_engine = MicroPentestEngine()
