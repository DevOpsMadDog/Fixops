"""Enterprise micro pen testing service for rapid, focused security testing of microservices."""

from __future__ import annotations

import asyncio
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional

import structlog

logger = structlog.get_logger()


class MicroPenTestStatus(Enum):
    """Status of a micro pen test."""

    QUEUED = "queued"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"


class MicroPenTestSeverity(Enum):
    """Severity of findings from micro pen test."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"
    NONE = "none"


class MicroServiceType(Enum):
    """Type of microservice being tested."""

    API = "api"
    WEB = "web"
    GRPC = "grpc"
    MESSAGE_QUEUE = "message_queue"
    DATABASE = "database"
    CACHE = "cache"
    UNKNOWN = "unknown"


@dataclass
class MicroPenTestRequest:
    """Micro pen test request model optimized for rapid execution."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    service_name: str = ""
    service_type: MicroServiceType = MicroServiceType.UNKNOWN
    target_url: str = ""
    endpoints: List[str] = field(default_factory=list)
    test_profile: str = "quick"  # quick, standard, deep
    priority: str = "medium"
    environment: str = "staging"
    metadata: Dict = field(default_factory=dict)
    status: MicroPenTestStatus = MicroPenTestStatus.QUEUED
    created_at: datetime = field(default_factory=datetime.utcnow)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    execution_time_ms: Optional[float] = None
    findings_count: int = 0
    max_severity: Optional[MicroPenTestSeverity] = None

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "service_name": self.service_name,
            "service_type": self.service_type.value,
            "target_url": self.target_url,
            "endpoints": self.endpoints,
            "test_profile": self.test_profile,
            "priority": self.priority,
            "environment": self.environment,
            "metadata": self.metadata,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat()
            if self.completed_at
            else None,
            "execution_time_ms": self.execution_time_ms,
            "findings_count": self.findings_count,
            "max_severity": self.max_severity.value if self.max_severity else None,
        }


@dataclass
class MicroPenTestResult:
    """Micro pen test result with focused findings."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    request_id: str = ""
    service_name: str = ""
    endpoint: str = ""
    vulnerability_type: str = ""
    severity: MicroPenTestSeverity = MicroPenTestSeverity.INFO
    exploitability: str = "unknown"
    evidence: str = ""
    recommendation: str = ""
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    created_at: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "request_id": self.request_id,
            "service_name": self.service_name,
            "endpoint": self.endpoint,
            "vulnerability_type": self.vulnerability_type,
            "severity": self.severity.value,
            "exploitability": self.exploitability,
            "evidence": self.evidence,
            "recommendation": self.recommendation,
            "cwe_id": self.cwe_id,
            "cvss_score": self.cvss_score,
            "created_at": self.created_at.isoformat(),
        }


@dataclass
class MicroPenTestBatch:
    """Batch of micro pen tests for parallel execution."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    requests: List[MicroPenTestRequest] = field(default_factory=list)
    status: MicroPenTestStatus = MicroPenTestStatus.QUEUED
    created_at: datetime = field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "requests": [r.to_dict() for r in self.requests],
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat()
            if self.completed_at
            else None,
        }


class MicroPenTestService:
    """Enterprise service for micro pen testing with rapid execution."""

    def __init__(self):
        """Initialize the micro pen testing service."""
        self._active_tests: Dict[str, MicroPenTestRequest] = {}
        self._results: Dict[str, List[MicroPenTestResult]] = {}
        self._max_concurrent: int = 10
        self._timeout_seconds: int = 30  # Fast timeout for micro tests

    async def create_request(self, request: MicroPenTestRequest) -> MicroPenTestRequest:
        """Create a new micro pen test request."""
        logger.info(
            "Creating micro pen test request",
            service_name=request.service_name,
            request_id=request.id,
            test_profile=request.test_profile,
        )
        self._active_tests[request.id] = request
        return request

    async def get_request(self, request_id: str) -> Optional[MicroPenTestRequest]:
        """Get a micro pen test request by ID."""
        return self._active_tests.get(request_id)

    async def list_requests(
        self,
        service_name: Optional[str] = None,
        status: Optional[MicroPenTestStatus] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[MicroPenTestRequest]:
        """List micro pen test requests."""
        requests = list(self._active_tests.values())

        if service_name:
            requests = [r for r in requests if r.service_name == service_name]
        if status:
            requests = [r for r in requests if r.status == status]

        requests.sort(key=lambda x: x.created_at, reverse=True)
        return requests[offset : offset + limit]

    async def execute_test(self, request_id: str) -> MicroPenTestRequest:
        """Execute a micro pen test (simulated for now)."""
        request = self._active_tests.get(request_id)
        if not request:
            raise ValueError(f"Request {request_id} not found")

        request.status = MicroPenTestStatus.RUNNING
        request.started_at = datetime.utcnow()

        logger.info(
            "Executing micro pen test",
            request_id=request_id,
            service_name=request.service_name,
        )

        # Simulate rapid micro pen test execution
        start_time = datetime.utcnow()
        await asyncio.sleep(0.1)  # Simulate fast execution

        # Generate sample findings based on test profile
        findings = self._generate_sample_findings(request)
        request.findings_count = len(findings)
        if findings:
            severities = [f.severity for f in findings]
            request.max_severity = max(
                severities, key=lambda s: self._severity_order(s)
            )

        end_time = datetime.utcnow()
        request.execution_time_ms = (end_time - start_time).total_seconds() * 1000
        request.status = MicroPenTestStatus.COMPLETED
        request.completed_at = end_time

        self._results[request_id] = findings

        logger.info(
            "Micro pen test completed",
            request_id=request_id,
            findings_count=len(findings),
            execution_time_ms=request.execution_time_ms,
        )

        return request

    async def execute_batch(self, batch: MicroPenTestBatch) -> MicroPenTestBatch:
        """Execute a batch of micro pen tests in parallel."""
        logger.info(
            "Executing micro pen test batch",
            batch_id=batch.id,
            request_count=len(batch.requests),
        )

        batch.status = MicroPenTestStatus.RUNNING

        # Execute tests in parallel with concurrency limit
        semaphore = asyncio.Semaphore(self._max_concurrent)
        tasks = [
            self._execute_with_semaphore(semaphore, req.id) for req in batch.requests
        ]
        await asyncio.gather(*tasks)

        batch.status = MicroPenTestStatus.COMPLETED
        batch.completed_at = datetime.utcnow()

        return batch

    async def _execute_with_semaphore(
        self, semaphore: asyncio.Semaphore, request_id: str
    ):
        """Execute a test with semaphore for concurrency control."""
        async with semaphore:
            await self.execute_test(request_id)

    def _generate_sample_findings(
        self, request: MicroPenTestRequest
    ) -> List[MicroPenTestResult]:
        """Generate sample findings for demonstration."""
        findings = []

        # Quick profile: minimal findings
        if request.test_profile == "quick":
            if request.service_type == MicroServiceType.API:
                findings.append(
                    MicroPenTestResult(
                        request_id=request.id,
                        service_name=request.service_name,
                        endpoint=request.endpoints[0] if request.endpoints else "/",
                        vulnerability_type="Missing Rate Limiting",
                        severity=MicroPenTestSeverity.MEDIUM,
                        exploitability="likely",
                        evidence="No rate limiting detected on API endpoints",
                        recommendation="Implement rate limiting per IP/API key",
                        cwe_id="CWE-307",
                        cvss_score=5.3,
                    )
                )

        # Standard profile: more comprehensive
        elif request.test_profile == "standard":
            findings.extend(
                [
                    MicroPenTestResult(
                        request_id=request.id,
                        service_name=request.service_name,
                        endpoint=ep,
                        vulnerability_type="Missing Authentication",
                        severity=MicroPenTestSeverity.HIGH,
                        exploitability="confirmed",
                        evidence=f"Endpoint {ep} accessible without authentication",
                        recommendation="Add authentication middleware",
                        cwe_id="CWE-306",
                        cvss_score=7.5,
                    )
                    for ep in request.endpoints[:2]
                ]
            )

        # Deep profile: comprehensive testing
        else:
            findings.extend(
                [
                    MicroPenTestResult(
                        request_id=request.id,
                        service_name=request.service_name,
                        endpoint=ep,
                        vulnerability_type="SQL Injection",
                        severity=MicroPenTestSeverity.CRITICAL,
                        exploitability="confirmed",
                        evidence=f"SQL injection detected in {ep}",
                        recommendation="Use parameterized queries",
                        cwe_id="CWE-89",
                        cvss_score=9.8,
                    )
                    for ep in request.endpoints[:1]
                ]
            )

        return findings

    async def get_results(self, request_id: str) -> List[MicroPenTestResult]:
        """Get results for a micro pen test request."""
        return self._results.get(request_id, [])

    async def list_results(
        self,
        service_name: Optional[str] = None,
        severity: Optional[MicroPenTestSeverity] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[MicroPenTestResult]:
        """List all micro pen test results."""
        all_results = []
        for results in self._results.values():
            all_results.extend(results)

        if service_name:
            all_results = [r for r in all_results if r.service_name == service_name]
        if severity:
            all_results = [r for r in all_results if r.severity == severity]

        all_results.sort(key=lambda x: x.created_at, reverse=True)
        return all_results[offset : offset + limit]

    def _severity_order(self, severity: MicroPenTestSeverity) -> int:
        """Get numeric order for severity comparison."""
        order = {
            MicroPenTestSeverity.CRITICAL: 5,
            MicroPenTestSeverity.HIGH: 4,
            MicroPenTestSeverity.MEDIUM: 3,
            MicroPenTestSeverity.LOW: 2,
            MicroPenTestSeverity.INFO: 1,
            MicroPenTestSeverity.NONE: 0,
        }
        return order.get(severity, 0)


# Global service instance
_service = MicroPenTestService()


def get_micro_pentest_service() -> MicroPenTestService:
    """Get the global micro pen testing service instance."""
    return _service
