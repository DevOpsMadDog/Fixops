"""Enterprise Micro Penetration Testing API endpoints."""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Header, Query, status
from pydantic import BaseModel, Field

from fixops_enterprise.src.services.micro_pentest_engine import (
    AttackSurface,
    AttackVector,
    ComplianceFramework,
    MicroPentestEngine,
    MicroScanConfig,
    MicroScanResult,
    MicroScanStatus,
    RiskLevel,
    ScanMode,
    ThreatCategory,
    ThreatModel,
    micro_pentest_engine,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/micro-pentest", tags=["micro-pentest"])


# Request/Response Models
class AttackSurfaceRequest(BaseModel):
    """Request model for attack surface definition."""

    name: str = Field(..., description="Name of the attack surface")
    target_url: str = Field(..., description="Target URL to test")
    target_type: str = Field(..., description="Type of target (api, web_app, mobile_app, infrastructure, cloud)")
    endpoints: List[str] = Field(default_factory=list, description="List of endpoints to test")
    authentication_required: bool = Field(default=False, description="Whether authentication is required")
    authentication_type: Optional[str] = Field(None, description="Type of authentication (jwt, basic, oauth2, etc.)")
    headers: Dict[str, str] = Field(default_factory=dict, description="Headers to include in requests")
    cookies: Dict[str, str] = Field(default_factory=dict, description="Cookies to include in requests")
    parameters: Dict[str, Any] = Field(default_factory=dict, description="Query/body parameters")
    technologies: List[str] = Field(default_factory=list, description="Technologies used in the target")
    environment: str = Field(default="development", description="Environment (development, staging, production)")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


class ThreatModelRequest(BaseModel):
    """Request model for threat model definition."""

    name: str = Field(..., description="Name of the threat model")
    description: str = Field(..., description="Description of the threat model")
    categories: List[str] = Field(..., description="Threat categories (MITRE ATT&CK aligned)")
    attack_vectors: List[str] = Field(..., description="Attack vectors to test")
    mitre_techniques: List[str] = Field(default_factory=list, description="MITRE ATT&CK technique IDs")
    owasp_categories: List[str] = Field(default_factory=list, description="OWASP categories")
    priority: int = Field(default=5, ge=1, le=10, description="Priority (1-10)")
    compliance_frameworks: List[str] = Field(default_factory=list, description="Compliance frameworks to validate")
    test_cases: List[str] = Field(default_factory=list, description="Specific test cases to execute")
    expected_findings: List[str] = Field(default_factory=list, description="Expected findings")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


class MicroScanRequest(BaseModel):
    """Request model for creating a micro penetration test scan."""

    name: str = Field(..., description="Name of the scan")
    attack_surface: AttackSurfaceRequest = Field(..., description="Attack surface definition")
    threat_model: ThreatModelRequest = Field(..., description="Threat model definition")
    scan_mode: str = Field(default="active", description="Scan mode (passive, active, aggressive, stealth)")
    timeout_seconds: int = Field(default=300, ge=10, le=3600, description="Timeout in seconds")
    max_threads: int = Field(default=5, ge=1, le=20, description="Maximum concurrent threads")
    rate_limit_rps: int = Field(default=10, ge=1, le=100, description="Rate limit in requests per second")
    stop_on_critical: bool = Field(default=True, description="Stop scan on critical finding")
    include_proof_of_concept: bool = Field(default=True, description="Include proof of concept in results")
    tags: List[str] = Field(default_factory=list, description="Tags for organization")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


class ScanFindingResponse(BaseModel):
    """Response model for scan finding."""

    id: str
    scan_id: str
    title: str
    description: str
    risk_level: str
    cvss_score: float
    attack_vector: str
    threat_category: str
    affected_endpoint: str
    exploit_successful: bool
    evidence: Dict[str, Any]
    proof_of_concept: Optional[str]
    remediation: str
    cwe_ids: List[str]
    owasp_references: List[str]
    mitre_techniques: List[str]
    compliance_violations: List[str]
    discovered_at: str
    metadata: Dict[str, Any]


class MicroScanResponse(BaseModel):
    """Response model for micro scan result."""

    id: str
    scan_id: str
    status: str
    findings: List[ScanFindingResponse]
    summary: Dict[str, Any]
    attack_paths: List[Dict[str, Any]]
    compliance_status: Dict[str, bool]
    execution_time_seconds: float
    started_at: Optional[str]
    completed_at: Optional[str]
    error_message: Optional[str]
    metadata: Dict[str, Any]


class AuditLogResponse(BaseModel):
    """Response model for audit log."""

    id: str
    timestamp: str
    tenant_id: str
    organization_id: str
    user_id: str
    action: str
    resource_type: str
    resource_id: str
    details: Dict[str, Any]
    ip_address: Optional[str]
    user_agent: Optional[str]
    result: str
    metadata: Dict[str, Any]


# Dependency: Authentication
async def get_current_user(
    authorization: Optional[str] = Header(None),
    x_tenant_id: Optional[str] = Header(None),
    x_organization_id: Optional[str] = Header(None),
) -> Dict[str, str]:
    """Get current authenticated user from headers.
    
    In production, this would validate JWT tokens and extract user information.
    """
    # Simplified authentication for demonstration
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing authorization header",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Mock user extraction
    # In production: decode JWT, validate signature, extract claims
    user_id = "user_123"  # Extract from token
    tenant_id = x_tenant_id or "default_tenant"
    organization_id = x_organization_id or "default_org"
    
    return {
        "user_id": user_id,
        "tenant_id": tenant_id,
        "organization_id": organization_id,
    }


# Dependency: Authorization
async def check_pentest_permission(
    action: str,
    current_user: Dict[str, str] = Depends(get_current_user),
) -> bool:
    """Check if user has permission to perform pen test action.
    
    In production, this would check against RBAC system.
    """
    # Simplified authorization for demonstration
    # In production: check user roles, permissions, resource ownership
    
    # For demo, allow all authenticated users
    return True


def _convert_scan_result_to_response(result: MicroScanResult) -> MicroScanResponse:
    """Convert internal scan result to API response."""
    findings_response = [
        ScanFindingResponse(
            id=f.id,
            scan_id=f.scan_id,
            title=f.title,
            description=f.description,
            risk_level=f.risk_level.value,
            cvss_score=f.cvss_score,
            attack_vector=f.attack_vector.value,
            threat_category=f.threat_category.value,
            affected_endpoint=f.affected_endpoint,
            exploit_successful=f.exploit_successful,
            evidence=f.evidence,
            proof_of_concept=f.proof_of_concept,
            remediation=f.remediation,
            cwe_ids=f.cwe_ids,
            owasp_references=f.owasp_references,
            mitre_techniques=f.mitre_techniques,
            compliance_violations=[c.value for c in f.compliance_violations],
            discovered_at=f.discovered_at.isoformat(),
            metadata=f.metadata,
        )
        for f in result.findings
    ]
    
    compliance_status_dict = {
        framework.value: status
        for framework, status in result.compliance_status.items()
    }
    
    return MicroScanResponse(
        id=result.id,
        scan_id=result.scan_id,
        status=result.status.value,
        findings=findings_response,
        summary=result.summary,
        attack_paths=result.attack_paths,
        compliance_status=compliance_status_dict,
        execution_time_seconds=result.execution_time_seconds,
        started_at=result.started_at.isoformat() if result.started_at else None,
        completed_at=result.completed_at.isoformat() if result.completed_at else None,
        error_message=result.error_message,
        metadata=result.metadata,
    )


# API Endpoints
@router.post("/scans", response_model=MicroScanResponse, status_code=status.HTTP_201_CREATED)
async def create_micro_scan(
    request: MicroScanRequest,
    current_user: Dict[str, str] = Depends(get_current_user),
) -> MicroScanResponse:
    """Create a new micro penetration test scan.
    
    This endpoint creates and queues a new micro pen test scan with the specified
    attack surface and threat model. The scan will be executed asynchronously.
    
    Args:
        request: Scan configuration
        current_user: Authenticated user information
    
    Returns:
        Created scan result with queued status
    
    Raises:
        HTTPException: If validation fails or scan creation fails
    """
    try:
        # Parse enums
        scan_mode = ScanMode(request.scan_mode.lower())
        
        threat_categories = [ThreatCategory(cat.lower()) for cat in request.threat_model.categories]
        attack_vectors = [AttackVector(vec.lower()) for vec in request.threat_model.attack_vectors]
        compliance_frameworks = [
            ComplianceFramework(fw.lower()) for fw in request.threat_model.compliance_frameworks
        ]
        
        # Build attack surface
        attack_surface = AttackSurface(
            name=request.attack_surface.name,
            target_url=request.attack_surface.target_url,
            target_type=request.attack_surface.target_type,
            endpoints=request.attack_surface.endpoints,
            authentication_required=request.attack_surface.authentication_required,
            authentication_type=request.attack_surface.authentication_type,
            headers=request.attack_surface.headers,
            cookies=request.attack_surface.cookies,
            parameters=request.attack_surface.parameters,
            technologies=request.attack_surface.technologies,
            environment=request.attack_surface.environment,
            metadata=request.attack_surface.metadata,
        )
        
        # Build threat model
        threat_model = ThreatModel(
            name=request.threat_model.name,
            description=request.threat_model.description,
            categories=threat_categories,
            attack_vectors=attack_vectors,
            mitre_techniques=request.threat_model.mitre_techniques,
            owasp_categories=request.threat_model.owasp_categories,
            priority=request.threat_model.priority,
            compliance_frameworks=compliance_frameworks,
            test_cases=request.threat_model.test_cases,
            expected_findings=request.threat_model.expected_findings,
            metadata=request.threat_model.metadata,
        )
        
        # Build scan config
        config = MicroScanConfig(
            name=request.name,
            attack_surface=attack_surface,
            threat_model=threat_model,
            scan_mode=scan_mode,
            timeout_seconds=request.timeout_seconds,
            max_threads=request.max_threads,
            rate_limit_rps=request.rate_limit_rps,
            stop_on_critical=request.stop_on_critical,
            include_proof_of_concept=request.include_proof_of_concept,
            tenant_id=current_user["tenant_id"],
            organization_id=current_user["organization_id"],
            created_by=current_user["user_id"],
            tags=request.tags,
            metadata=request.metadata,
        )
        
        # Create scan
        result = await micro_pentest_engine.create_micro_scan(
            config=config,
            user_id=current_user["user_id"],
        )
        
        logger.info(f"Created micro scan {result.scan_id} for user {current_user['user_id']}")
        
        return _convert_scan_result_to_response(result)
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid request: {str(e)}",
        )
    except Exception as e:
        logger.error(f"Failed to create micro scan: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create micro scan",
        )


@router.post("/scans/{scan_id}/execute", response_model=MicroScanResponse)
async def execute_micro_scan(
    scan_id: str,
    current_user: Dict[str, str] = Depends(get_current_user),
) -> MicroScanResponse:
    """Execute a queued micro penetration test scan.
    
    This endpoint starts the execution of a previously created scan.
    The scan will run asynchronously and can be monitored via the status endpoint.
    
    Args:
        scan_id: ID of the scan to execute
        current_user: Authenticated user information
    
    Returns:
        Scan result with running status
    
    Raises:
        HTTPException: If scan not found or execution fails
    """
    try:
        result = await micro_pentest_engine.execute_micro_scan(
            scan_id=scan_id,
            user_id=current_user["user_id"],
        )
        
        logger.info(f"Executed micro scan {scan_id} for user {current_user['user_id']}")
        
        return _convert_scan_result_to_response(result)
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except Exception as e:
        logger.error(f"Failed to execute micro scan {scan_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to execute micro scan",
        )


@router.get("/scans/{scan_id}", response_model=MicroScanResponse)
async def get_micro_scan(
    scan_id: str,
    current_user: Dict[str, str] = Depends(get_current_user),
) -> MicroScanResponse:
    """Get a micro penetration test scan by ID.
    
    Args:
        scan_id: ID of the scan to retrieve
        current_user: Authenticated user information
    
    Returns:
        Scan result
    
    Raises:
        HTTPException: If scan not found
    """
    result = await micro_pentest_engine.get_scan_result(scan_id)
    
    if not result:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Scan not found",
        )
    
    # Authorization check: verify tenant/org access
    if result.config and result.config.tenant_id != current_user["tenant_id"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied",
        )
    
    return _convert_scan_result_to_response(result)


@router.get("/scans", response_model=List[MicroScanResponse])
async def list_micro_scans(
    status_filter: Optional[str] = Query(None, alias="status", description="Filter by scan status"),
    current_user: Dict[str, str] = Depends(get_current_user),
) -> List[MicroScanResponse]:
    """List micro penetration test scans.
    
    Args:
        status_filter: Optional status filter
        current_user: Authenticated user information
    
    Returns:
        List of scan results
    """
    scan_status = None
    if status_filter:
        try:
            scan_status = MicroScanStatus(status_filter.lower())
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid status filter: {status_filter}",
            )
    
    results = await micro_pentest_engine.list_scans(
        tenant_id=current_user["tenant_id"],
        organization_id=current_user["organization_id"],
        status=scan_status,
    )
    
    return [_convert_scan_result_to_response(result) for result in results]


@router.post("/scans/{scan_id}/cancel", response_model=Dict[str, Any])
async def cancel_micro_scan(
    scan_id: str,
    current_user: Dict[str, str] = Depends(get_current_user),
) -> Dict[str, Any]:
    """Cancel a running micro penetration test scan.
    
    Args:
        scan_id: ID of the scan to cancel
        current_user: Authenticated user information
    
    Returns:
        Success message
    
    Raises:
        HTTPException: If scan not found or cannot be cancelled
    """
    success = await micro_pentest_engine.cancel_scan(
        scan_id=scan_id,
        user_id=current_user["user_id"],
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Scan not found or cannot be cancelled",
        )
    
    return {
        "message": "Scan cancelled successfully",
        "scan_id": scan_id,
    }


@router.get("/audit-logs", response_model=List[AuditLogResponse])
async def get_audit_logs(
    action: Optional[str] = Query(None, description="Filter by action"),
    resource_type: Optional[str] = Query(None, description="Filter by resource type"),
    start_date: Optional[str] = Query(None, description="Start date (ISO format)"),
    end_date: Optional[str] = Query(None, description="End date (ISO format)"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of logs to return"),
    current_user: Dict[str, str] = Depends(get_current_user),
) -> List[AuditLogResponse]:
    """Get audit logs for compliance tracking.
    
    Args:
        action: Optional action filter
        resource_type: Optional resource type filter
        start_date: Optional start date filter
        end_date: Optional end date filter
        limit: Maximum number of logs to return
        current_user: Authenticated user information
    
    Returns:
        List of audit logs
    """
    start_dt = None
    if start_date:
        try:
            start_dt = datetime.fromisoformat(start_date)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid start_date format",
            )
    
    end_dt = None
    if end_date:
        try:
            end_dt = datetime.fromisoformat(end_date)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid end_date format",
            )
    
    logs = await micro_pentest_engine.get_audit_logs(
        tenant_id=current_user["tenant_id"],
        organization_id=current_user["organization_id"],
        action=action,
        start_date=start_dt,
        end_date=end_dt,
        limit=limit,
    )
    
    return [
        AuditLogResponse(
            id=log.id,
            timestamp=log.timestamp.isoformat(),
            tenant_id=log.tenant_id,
            organization_id=log.organization_id,
            user_id=log.user_id,
            action=log.action,
            resource_type=log.resource_type,
            resource_id=log.resource_id,
            details=log.details,
            ip_address=log.ip_address,
            user_agent=log.user_agent,
            result=log.result,
            metadata=log.metadata,
        )
        for log in logs
    ]


@router.get("/health", response_model=Dict[str, Any])
async def health_check() -> Dict[str, Any]:
    """Health check endpoint for micro pentest service.
    
    Returns:
        Health status information
    """
    return {
        "status": "healthy",
        "service": "micro-pentest",
        "version": "1.0.0",
        "timestamp": datetime.utcnow().isoformat(),
    }


__all__ = ["router"]
