"""Enterprise micro pen testing API router with authentication and audit logging."""

from __future__ import annotations

from typing import List, Optional

import structlog
from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field
from src.api.dependencies import authenticate
from src.services.micro_pentest import (
    MicroPenTestBatch,
    MicroPenTestRequest,
    MicroPenTestSeverity,
    MicroPenTestStatus,
    MicroServiceType,
    get_micro_pentest_service,
)

logger = structlog.get_logger()

router = APIRouter(prefix="/micro-pentest", tags=["micro-pentest"])


class CreateMicroPenTestRequestModel(BaseModel):
    """Model for creating a micro pen test request."""

    service_name: str = Field(..., description="Name of the microservice to test")
    service_type: str = Field(
        default="api", description="Type of microservice (api, web, grpc, etc.)"
    )
    target_url: str = Field(..., description="Base URL of the microservice")
    endpoints: List[str] = Field(
        default_factory=list, description="Specific endpoints to test"
    )
    test_profile: str = Field(
        default="quick",
        description="Test profile: quick (fast, minimal), standard, deep",
    )
    priority: str = Field(default="medium", description="Test priority")
    environment: str = Field(default="staging", description="Target environment")
    metadata: dict = Field(default_factory=dict, description="Additional metadata")


class CreateMicroPenTestBatchModel(BaseModel):
    """Model for creating a batch of micro pen tests."""

    requests: List[CreateMicroPenTestRequestModel] = Field(
        ..., description="List of micro pen test requests"
    )


@router.get("/requests", dependencies=[Depends(authenticate)])
async def list_micro_pen_test_requests(
    service_name: Optional[str] = Query(None, description="Filter by service name"),
    status: Optional[str] = Query(None, description="Filter by status"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
) -> dict:
    """List micro pen test requests with authentication."""
    logger.info(
        "Listing micro pen test requests",
        service_name=service_name,
        status=status,
        limit=limit,
        offset=offset,
    )

    service = get_micro_pentest_service()
    status_enum = MicroPenTestStatus(status) if status else None

    requests = await service.list_requests(
        service_name=service_name, status=status_enum, limit=limit, offset=offset
    )

    return {
        "items": [r.to_dict() for r in requests],
        "total": len(requests),
        "limit": limit,
        "offset": offset,
    }


@router.post(
    "/requests",
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(authenticate)],
)
async def create_micro_pen_test_request(
    data: CreateMicroPenTestRequestModel,
) -> dict:
    """Create a new micro pen test request with authentication."""
    logger.info(
        "Creating micro pen test request",
        service_name=data.service_name,
        service_type=data.service_type,
    )

    service = get_micro_pentest_service()

    try:
        service_type = MicroServiceType(data.service_type.lower())
    except ValueError:
        service_type = MicroServiceType.UNKNOWN

    request = MicroPenTestRequest(
        service_name=data.service_name,
        service_type=service_type,
        target_url=data.target_url,
        endpoints=data.endpoints,
        test_profile=data.test_profile,
        priority=data.priority,
        environment=data.environment,
        metadata=data.metadata,
    )

    created = await service.create_request(request)
    return created.to_dict()


@router.get("/requests/{request_id}", dependencies=[Depends(authenticate)])
async def get_micro_pen_test_request(request_id: str) -> dict:
    """Get a specific micro pen test request by ID."""
    logger.info("Getting micro pen test request", request_id=request_id)

    service = get_micro_pentest_service()
    request = await service.get_request(request_id)

    if not request:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Micro pen test request {request_id} not found",
        )

    return request.to_dict()


@router.post("/requests/{request_id}/execute", dependencies=[Depends(authenticate)])
async def execute_micro_pen_test(request_id: str) -> dict:
    """Execute a micro pen test request."""
    logger.info("Executing micro pen test", request_id=request_id)

    service = get_micro_pentest_service()
    request = await service.get_request(request_id)

    if not request:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Micro pen test request {request_id} not found",
        )

    if request.status == MicroPenTestStatus.RUNNING:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Micro pen test {request_id} is already running",
        )

    try:
        executed = await service.execute_test(request_id)
        return {
            "status": "executed",
            "request": executed.to_dict(),
        }
    except Exception as e:
        logger.error(
            "Error executing micro pen test", request_id=request_id, error=str(e)
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute micro pen test: {str(e)}",
        )


@router.post(
    "/batches",
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(authenticate)],
)
async def create_micro_pen_test_batch(
    data: CreateMicroPenTestBatchModel,
) -> dict:
    """Create and execute a batch of micro pen tests."""
    logger.info(
        "Creating micro pen test batch",
        request_count=len(data.requests),
    )

    service = get_micro_pentest_service()

    # Create requests
    requests = []
    for req_data in data.requests:
        try:
            service_type = MicroServiceType(req_data.service_type.lower())
        except ValueError:
            service_type = MicroServiceType.UNKNOWN

        request = MicroPenTestRequest(
            service_name=req_data.service_name,
            service_type=service_type,
            target_url=req_data.target_url,
            endpoints=req_data.endpoints,
            test_profile=req_data.test_profile,
            priority=req_data.priority,
            environment=req_data.environment,
            metadata=req_data.metadata,
        )
        created = await service.create_request(request)
        requests.append(created)

    # Create batch
    batch = MicroPenTestBatch(requests=requests)

    # Execute batch
    try:
        executed_batch = await service.execute_batch(batch)
        return {
            "status": "completed",
            "batch": executed_batch.to_dict(),
        }
    except Exception as e:
        logger.error("Error executing micro pen test batch", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute batch: {str(e)}",
        )


@router.get("/results", dependencies=[Depends(authenticate)])
async def list_micro_pen_test_results(
    service_name: Optional[str] = Query(None, description="Filter by service name"),
    severity: Optional[str] = Query(None, description="Filter by severity"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
) -> dict:
    """List micro pen test results."""
    logger.info(
        "Listing micro pen test results",
        service_name=service_name,
        severity=severity,
        limit=limit,
        offset=offset,
    )

    service = get_micro_pentest_service()
    severity_enum = MicroPenTestSeverity(severity) if severity else None

    results = await service.list_results(
        service_name=service_name, severity=severity_enum, limit=limit, offset=offset
    )

    return {
        "items": [r.to_dict() for r in results],
        "total": len(results),
        "limit": limit,
        "offset": offset,
    }


@router.get("/results/{request_id}", dependencies=[Depends(authenticate)])
async def get_micro_pen_test_results(request_id: str) -> dict:
    """Get results for a specific micro pen test request."""
    logger.info("Getting micro pen test results", request_id=request_id)

    service = get_micro_pentest_service()
    results = await service.get_results(request_id)

    return {
        "request_id": request_id,
        "items": [r.to_dict() for r in results],
        "total": len(results),
    }


@router.get("/summary", dependencies=[Depends(authenticate)])
async def get_micro_pen_test_summary(
    service_name: Optional[str] = Query(None, description="Filter by service name"),
) -> dict:
    """Get summary statistics for micro pen tests."""
    logger.info("Getting micro pen test summary", service_name=service_name)

    service = get_micro_pentest_service()
    requests = await service.list_requests(service_name=service_name, limit=10000)
    results = await service.list_results(service_name=service_name, limit=10000)

    # Calculate statistics
    status_counts = {}
    severity_counts = {}
    total_execution_time = 0.0
    completed_count = 0

    for req in requests:
        status_counts[req.status.value] = status_counts.get(req.status.value, 0) + 1
        if req.execution_time_ms:
            total_execution_time += req.execution_time_ms
            completed_count += 1

    for result in results:
        severity_counts[result.severity.value] = (
            severity_counts.get(result.severity.value, 0) + 1
        )

    avg_execution_time = (
        total_execution_time / completed_count if completed_count > 0 else 0.0
    )

    return {
        "total_requests": len(requests),
        "total_results": len(results),
        "status_breakdown": status_counts,
        "severity_breakdown": severity_counts,
        "average_execution_time_ms": round(avg_execution_time, 2),
        "completed_tests": completed_count,
    }


__all__ = ["router"]
