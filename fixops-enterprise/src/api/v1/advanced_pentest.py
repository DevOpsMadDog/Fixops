"""
FixOps Advanced Penetration Testing API - World-Class Edition

This module provides API endpoints for the most advanced automated
penetration testing capabilities available.
"""

import logging
from typing import Any, Dict, List, MutableMapping, Optional

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field

from ...services.advanced_pentest_engine import (
    ContinuousPenTestConfig,
    DataClassification,
    get_world_class_pentest_engine,
)
from ..auth import authenticate

logger = logging.getLogger(__name__)

router = APIRouter(tags=["Advanced Penetration Testing"])


# =============================================================================
# REQUEST/RESPONSE MODELS
# =============================================================================


class FindingInput(BaseModel):
    """Input model for a security finding."""

    id: Optional[str] = None
    rule_id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    message: Optional[str] = None
    severity: str = "medium"
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    location: Optional[Dict[str, Any]] = None
    category: Optional[str] = None
    compliance: Optional[List[str]] = None


class PenTestContext(BaseModel):
    """Context for penetration testing."""

    target_name: str = "target_application"
    environment: str = "production"
    scope: Dict[str, Any] = Field(default_factory=dict)
    asset_criticality: str = "business_operational"
    data_classification: str = "internal"
    affected_users: int = 1000
    affected_systems: int = 10
    affected_records: int = 10000
    annual_revenue_usd: float = 10_000_000
    compliance_frameworks: List[str] = Field(
        default_factory=lambda: ["SOC2", "PCI_DSS"]
    )
    primary_language: str = "python"
    framework: Optional[str] = None
    industry: str = "technology"


class PenTestOptions(BaseModel):
    """Options for penetration testing."""

    run_validation: bool = True
    generate_narratives: bool = True
    include_compliance_mapping: bool = True
    include_threat_intel: bool = True
    include_attack_simulation: bool = True
    include_business_impact: bool = True
    generate_remediation_code: bool = True
    max_findings: int = 100
    timeout_seconds: int = 3600


class RunWorldClassPenTestRequest(BaseModel):
    """Request model for running a world-class penetration test."""

    findings: List[FindingInput]
    context: PenTestContext = Field(default_factory=PenTestContext)
    options: PenTestOptions = Field(default_factory=PenTestOptions)


class ThreatIntelRequest(BaseModel):
    """Request model for threat intelligence enrichment."""

    finding: FindingInput


class BusinessImpactRequest(BaseModel):
    """Request model for business impact assessment."""

    finding: FindingInput
    context: PenTestContext = Field(default_factory=PenTestContext)


class AttackSimulationRequest(BaseModel):
    """Request model for attack simulation."""

    findings: List[FindingInput]
    context: PenTestContext = Field(default_factory=PenTestContext)


class RemediationCodeRequest(BaseModel):
    """Request model for remediation code generation."""

    finding: FindingInput
    language: str = "python"
    framework: Optional[str] = None


class ContinuousPenTestRequest(BaseModel):
    """Request model for continuous pen test configuration."""

    name: str
    schedule_cron: str = "0 2 * * *"
    target_scope: List[str] = Field(default_factory=list)
    excluded_paths: List[str] = Field(default_factory=list)
    notification_channels: List[str] = Field(default_factory=list)
    auto_create_tickets: bool = False
    ticket_system: Optional[str] = None
    severity_threshold: str = "medium"
    max_concurrent_tests: int = 5
    timeout_minutes: int = 60


class BaselineComparisonRequest(BaseModel):
    """Request model for baseline comparison."""

    schedule_id: str
    current_findings: List[FindingInput]


# =============================================================================
# API ENDPOINTS
# =============================================================================


@router.post("/run")
async def run_world_class_pentest(
    request: RunWorldClassPenTestRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Run the most advanced automated penetration test available.

    This endpoint provides world-class penetration testing capabilities including:
    - Multi-AI orchestration for consensus-based analysis
    - Advanced attack simulation (chained exploits, privilege escalation)
    - Threat intelligence integration (CVE/NVD, KEV, EPSS)
    - Business impact quantification with dollar estimates
    - AI-powered remediation code generation
    - Executive-level reporting dashboards

    All tests are defensive in nature - validating known vulnerabilities
    rather than discovering new attack vectors. No arbitrary code execution.
    """
    logger.info(
        "advanced_pentest.run.start",
        findings_count=len(request.findings),
    )

    if len(request.findings) > request.options.max_findings:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Too many findings. Maximum allowed: {request.options.max_findings}",
        )

    if not request.findings:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="At least one finding is required",
        )

    try:
        engine = get_world_class_pentest_engine()

        findings_dicts = [f.model_dump() for f in request.findings]
        context_dict = request.context.model_dump()
        options_dict = request.options.model_dump()

        report = await engine.run_world_class_pentest(
            findings=findings_dicts,
            context=context_dict,
            options=options_dict,
        )

        logger.info(
            "advanced_pentest.run.completed",
            report_id=report.id,
            findings_processed=len(report.findings),
        )

        return {
            "status": "completed",
            "report": {
                "id": report.id,
                "title": report.title,
                "executive_summary": report.executive_summary,
                "executive_dashboard": {
                    "overall_risk_score": report.executive_dashboard.overall_risk_score,
                    "risk_trend": report.executive_dashboard.risk_trend,
                    "critical_findings": report.executive_dashboard.critical_findings,
                    "high_findings": report.executive_dashboard.high_findings,
                    "medium_findings": report.executive_dashboard.medium_findings,
                    "low_findings": report.executive_dashboard.low_findings,
                    "total_findings": report.executive_dashboard.total_findings,
                    "total_financial_risk_usd": report.executive_dashboard.total_financial_risk_usd,
                    "compliance_scores": report.executive_dashboard.compliance_scores,
                    "attack_surface_score": report.executive_dashboard.attack_surface_score,
                    "exposure_score": report.executive_dashboard.exposure_score,
                    "top_risks": report.executive_dashboard.top_risks,
                    "recommended_actions": report.executive_dashboard.recommended_actions,
                },
                "methodology": report.methodology,
                "findings_count": len(report.findings),
                "threat_intelligence_count": len(report.threat_intelligence),
                "chained_exploits_count": len(report.chained_exploits),
                "privilege_escalation_paths_count": len(
                    report.privilege_escalation_paths
                ),
                "lateral_movement_paths_count": len(report.lateral_movement_paths),
                "remediation_codes_count": len(report.remediation_codes),
                "compliance_mapping": report.compliance_mapping,
                "risk_quantification": report.risk_quantification,
                "recommendations": report.recommendations[:10],
                "metadata": report.metadata,
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.run.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Penetration test failed: {str(e)}",
        )


@router.post("/threat-intel")
async def enrich_with_threat_intel(
    request: ThreatIntelRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Enrich a vulnerability with threat intelligence.

    Integrates data from:
    - NVD (National Vulnerability Database)
    - CISA KEV (Known Exploited Vulnerabilities)
    - EPSS (Exploit Prediction Scoring System)
    - Exploit-DB
    - MITRE ATT&CK
    """
    try:
        engine = get_world_class_pentest_engine()
        finding_dict = request.finding.model_dump()

        intel = await engine.threat_intel.enrich_vulnerability(finding_dict)

        return {
            "status": "completed",
            "threat_intelligence": {
                "cve_id": intel.cve_id,
                "cwe_ids": intel.cwe_ids,
                "nvd_score": intel.nvd_score,
                "nvd_vector": intel.nvd_vector,
                "epss_score": intel.epss_score,
                "epss_percentile": intel.epss_percentile,
                "is_kev": intel.is_kev,
                "kev_date_added": intel.kev_date_added.isoformat()
                if intel.kev_date_added
                else None,
                "kev_due_date": intel.kev_due_date.isoformat()
                if intel.kev_due_date
                else None,
                "exploit_db_ids": intel.exploit_db_ids,
                "metasploit_modules": intel.metasploit_modules,
                "nuclei_templates": intel.nuclei_templates,
                "poc_available": intel.poc_available,
                "active_exploitation": intel.active_exploitation,
                "ransomware_associated": intel.ransomware_associated,
                "threat_actors": [t.value for t in intel.threat_actors],
                "campaigns": intel.campaigns,
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.threat_intel.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Threat intelligence enrichment failed: {str(e)}",
        )


@router.post("/business-impact")
async def assess_business_impact(
    request: BusinessImpactRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Assess business impact of a vulnerability with financial quantification.

    Uses industry benchmarks (IBM Cost of Data Breach 2024) and regulatory
    frameworks to estimate potential financial impact.
    """
    try:
        engine = get_world_class_pentest_engine()
        finding_dict = request.finding.model_dump()
        context_dict = request.context.model_dump()

        assessment = await engine.impact_quantifier.assess_business_impact(
            finding_dict, context_dict
        )

        return {
            "status": "completed",
            "business_impact": {
                "asset_criticality": assessment.asset_criticality.value,
                "data_classification": assessment.data_classification.value,
                "affected_users": assessment.affected_users,
                "affected_systems": assessment.affected_systems,
                "affected_data_records": assessment.affected_data_records,
                "financial_impact": {
                    "revenue_at_risk_usd": assessment.revenue_at_risk_usd,
                    "downtime_cost_per_hour_usd": assessment.downtime_cost_per_hour_usd,
                    "estimated_downtime_hours": assessment.estimated_downtime_hours,
                    "regulatory_fine_risk_usd": assessment.regulatory_fine_risk_usd,
                    "legal_liability_usd": assessment.legal_liability_usd,
                    "incident_response_cost_usd": assessment.incident_response_cost_usd,
                    "forensics_cost_usd": assessment.forensics_cost_usd,
                    "notification_cost_usd": assessment.notification_cost_usd,
                    "credit_monitoring_cost_usd": assessment.credit_monitoring_cost_usd,
                    "total_estimated_impact_usd": assessment.total_estimated_impact_usd,
                },
                "reputation_damage_score": assessment.reputation_damage_score,
                "customer_churn_risk_percent": assessment.customer_churn_risk_percent,
                "confidence_level": assessment.confidence_level,
                "assumptions": assessment.assumptions,
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.business_impact.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Business impact assessment failed: {str(e)}",
        )


@router.post("/attack-simulation")
async def run_attack_simulation(
    request: AttackSimulationRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Run advanced attack simulation.

    Generates:
    - Chained exploits combining multiple vulnerabilities
    - Privilege escalation paths
    - Lateral movement paths
    """
    try:
        engine = get_world_class_pentest_engine()
        findings_dicts = [f.model_dump() for f in request.findings]
        context_dict = request.context.model_dump()

        chained_exploits = await engine.attack_simulator.generate_chained_exploits(
            findings_dicts, context_dict
        )
        privesc_paths = (
            await engine.attack_simulator.analyze_privilege_escalation_paths(
                findings_dicts, context_dict
            )
        )
        lateral_paths = await engine.attack_simulator.analyze_lateral_movement_paths(
            findings_dicts, context_dict
        )

        return {
            "status": "completed",
            "attack_simulation": {
                "chained_exploits": [
                    {
                        "id": ce.id,
                        "name": ce.name,
                        "description": ce.description,
                        "vulnerabilities": ce.vulnerabilities,
                        "attack_sequence": ce.attack_sequence,
                        "combined_cvss": ce.combined_cvss,
                        "success_probability": ce.success_probability,
                        "time_to_exploit_hours": ce.time_to_exploit_hours,
                        "impact_multiplier": ce.impact_multiplier,
                        "mitre_techniques": ce.mitre_techniques,
                    }
                    for ce in chained_exploits
                ],
                "privilege_escalation_paths": [
                    {
                        "id": p.id,
                        "name": p.name,
                        "description": p.description,
                        "initial_access_level": p.initial_access_level,
                        "target_access_level": p.target_access_level,
                        "steps": p.steps,
                        "success_probability": p.success_probability,
                        "time_to_exploit_hours": p.time_to_exploit_hours,
                        "detection_likelihood": p.detection_likelihood,
                        "mitre_techniques": p.mitre_techniques,
                    }
                    for p in privesc_paths
                ],
                "lateral_movement_paths": [
                    {
                        "id": p.id,
                        "source_system": p.source_system,
                        "target_system": p.target_system,
                        "method": p.method,
                        "description": p.description,
                        "credentials_required": p.credentials_required,
                        "success_probability": p.success_probability,
                        "detection_likelihood": p.detection_likelihood,
                        "mitre_techniques": p.mitre_techniques,
                    }
                    for p in lateral_paths
                ],
                "summary": {
                    "chained_exploits_count": len(chained_exploits),
                    "privilege_escalation_paths_count": len(privesc_paths),
                    "lateral_movement_paths_count": len(lateral_paths),
                },
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.attack_simulation.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Attack simulation failed: {str(e)}",
        )


@router.post("/remediation-code")
async def generate_remediation_code(
    request: RemediationCodeRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Generate AI-powered remediation code for a vulnerability.

    Generates framework-specific fixes with test cases and
    breaking change analysis.
    """
    try:
        engine = get_world_class_pentest_engine()
        finding_dict = request.finding.model_dump()

        code = await engine.ai_orchestrator.generate_remediation_code(
            finding_dict, request.language, request.framework
        )

        return {
            "status": "completed",
            "remediation_code": {
                "vulnerability_id": code.vulnerability_id,
                "language": code.language,
                "framework": code.framework,
                "code": code.code,
                "description": code.description,
                "test_cases": code.test_cases,
                "dependencies": code.dependencies,
                "breaking_changes": code.breaking_changes,
                "confidence": code.confidence,
                "generated_by": code.generated_by.value,
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.remediation_code.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Remediation code generation failed: {str(e)}",
        )


@router.post("/ai-consensus")
async def run_ai_consensus_analysis(
    request: ThreatIntelRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Run multi-AI consensus analysis on a vulnerability.

    Uses multiple AI models to analyze the finding and reach
    consensus on risk assessment and recommendations.
    """
    try:
        engine = get_world_class_pentest_engine()
        finding_dict = request.finding.model_dump()

        result = await engine.ai_orchestrator.analyze_with_consensus(finding_dict, {})

        return {
            "status": "completed",
            "consensus_result": {
                "strategy": result.strategy.value,
                "consensus_reached": result.consensus_reached,
                "confidence": result.confidence,
                "final_risk_score": result.final_risk_score,
                "final_recommendations": result.final_recommendations,
                "reasoning": result.reasoning,
                "individual_results": [
                    {
                        "model": r.model.value,
                        "confidence": r.confidence,
                        "risk_score": r.risk_score,
                        "recommendations": r.recommendations,
                        "processing_time_ms": r.processing_time_ms,
                    }
                    for r in result.individual_results
                ],
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.ai_consensus.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"AI consensus analysis failed: {str(e)}",
        )


@router.post("/continuous/schedule")
async def create_continuous_pentest_schedule(
    request: ContinuousPenTestRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Create a continuous penetration testing schedule.

    Enables automated, scheduled penetration testing with:
    - Baseline comparison
    - Drift detection
    - Regression testing
    """
    try:
        engine = get_world_class_pentest_engine()

        import uuid

        config = ContinuousPenTestConfig(
            id=f"CPT-{uuid.uuid4().hex[:8]}",
            name=request.name,
            schedule_cron=request.schedule_cron,
            target_scope=request.target_scope,
            excluded_paths=request.excluded_paths,
            notification_channels=request.notification_channels,
            auto_create_tickets=request.auto_create_tickets,
            ticket_system=request.ticket_system,
            severity_threshold=request.severity_threshold,
            max_concurrent_tests=request.max_concurrent_tests,
            timeout_minutes=request.timeout_minutes,
        )

        created = engine.scheduler.create_schedule(config)

        return {
            "status": "created",
            "schedule": {
                "id": created.id,
                "name": created.name,
                "enabled": created.enabled,
                "schedule_cron": created.schedule_cron,
                "target_scope": created.target_scope,
                "severity_threshold": created.severity_threshold,
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.continuous.create.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create continuous pentest schedule: {str(e)}",
        )


@router.get("/continuous/schedules")
async def list_continuous_pentest_schedules(
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """List all continuous penetration testing schedules."""
    try:
        engine = get_world_class_pentest_engine()
        schedules = engine.scheduler.list_schedules()

        return {
            "status": "success",
            "schedules": [
                {
                    "id": s.id,
                    "name": s.name,
                    "enabled": s.enabled,
                    "schedule_cron": s.schedule_cron,
                    "target_scope": s.target_scope,
                    "severity_threshold": s.severity_threshold,
                }
                for s in schedules
            ],
        }

    except Exception as e:
        logger.error("advanced_pentest.continuous.list.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list schedules: {str(e)}",
        )


@router.post("/continuous/baseline-compare")
async def compare_to_baseline(
    request: BaselineComparisonRequest,
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Compare current findings to baseline for drift detection.

    Identifies:
    - New findings since baseline
    - Resolved findings
    - Persistent findings
    """
    try:
        engine = get_world_class_pentest_engine()
        current_dicts = [f.model_dump() for f in request.current_findings]

        comparison = engine.scheduler.compare_to_baseline(
            request.schedule_id, current_dicts
        )

        return {
            "status": "completed",
            "comparison": {
                "new_count": comparison["new_count"],
                "resolved_count": comparison["resolved_count"],
                "persistent_count": comparison["persistent_count"],
                "drift_detected": comparison["drift_detected"],
                "improvement": comparison["improvement"],
                "new_findings": comparison["new_findings"][:10],
                "resolved_findings": comparison["resolved_findings"][:10],
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.baseline_compare.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Baseline comparison failed: {str(e)}",
        )


@router.get("/capabilities")
async def list_capabilities(
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    List all world-class penetration testing capabilities.

    Returns comprehensive information about available features.
    """
    return {
        "status": "success",
        "capabilities": {
            "multi_ai_orchestration": {
                "description": "Consensus-based analysis using multiple AI models",
                "models": ["local", "gemini", "claude", "gpt"],
                "strategies": [
                    "unanimous",
                    "majority",
                    "weighted",
                    "highest_confidence",
                ],
            },
            "threat_intelligence": {
                "description": "Real-time threat intelligence integration",
                "sources": ["NVD", "CISA KEV", "EPSS", "Exploit-DB", "MITRE ATT&CK"],
                "features": [
                    "CVE correlation",
                    "EPSS scoring",
                    "KEV prioritization",
                    "Exploit availability",
                    "Threat actor mapping",
                ],
            },
            "attack_simulation": {
                "description": "Advanced attack simulation and modeling",
                "features": [
                    "Chained exploit generation",
                    "Privilege escalation path analysis",
                    "Lateral movement simulation",
                    "Kill chain modeling",
                ],
            },
            "business_impact": {
                "description": "Financial risk quantification",
                "features": [
                    "Breach cost estimation",
                    "Regulatory fine calculation",
                    "Downtime cost analysis",
                    "Reputation damage scoring",
                ],
                "benchmarks": ["IBM Cost of Data Breach 2024"],
            },
            "remediation": {
                "description": "AI-powered remediation code generation",
                "languages": ["python", "javascript", "java", "go", "rust"],
                "features": [
                    "Framework-specific fixes",
                    "Test case generation",
                    "Breaking change analysis",
                ],
            },
            "continuous_testing": {
                "description": "Automated continuous penetration testing",
                "features": [
                    "Scheduled scans",
                    "Baseline comparison",
                    "Drift detection",
                    "Regression testing",
                ],
            },
            "reporting": {
                "description": "Executive-level reporting dashboards",
                "features": [
                    "Risk scoring",
                    "Compliance mapping",
                    "Financial impact summary",
                    "Prioritized recommendations",
                ],
            },
        },
        "compliance_frameworks": [
            "PCI_DSS",
            "SOC2",
            "HIPAA",
            "GDPR",
            "NIST_800_53",
            "CIS_BENCHMARKS",
            "ISO_27001",
            "MITRE_ATTACK",
        ],
        "version": "1.0.0-world-class",
    }


@router.get("/breach-cost-calculator")
async def calculate_breach_cost(
    industry: str = "technology",
    records_affected: int = 10000,
    data_classification: str = "confidential",
    _: None = Depends(authenticate),
) -> MutableMapping[str, Any]:
    """
    Calculate estimated breach cost using industry benchmarks.

    Uses IBM Cost of Data Breach 2024 methodology.
    """
    try:
        engine = get_world_class_pentest_engine()

        try:
            classification = DataClassification(data_classification)
        except ValueError:
            classification = DataClassification.INTERNAL

        cost = engine.threat_intel.calculate_breach_cost(
            industry, records_affected, classification
        )

        return {
            "status": "success",
            "breach_cost_estimate": {
                "industry": industry,
                "records_affected": records_affected,
                "data_classification": classification.value,
                "cost_breakdown": cost,
            },
        }

    except Exception as e:
        logger.error("advanced_pentest.breach_cost.error", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Breach cost calculation failed: {str(e)}",
        )
