"""Tests for core micro penetration test functionality."""
from unittest.mock import AsyncMock, MagicMock, patch

import httpx
import pytest

from core.micro_pentest import (
    BatchTestConfig,
    MicroPentestConfig,
    MicroPentestResult,
    MicroPentestStatus,
    _get_pentagi_client,
    _sanitize_context,
    _validate_cve_id,
    _validate_target_url,
    get_micro_pentest_status,
    run_batch_micro_pentests,
    run_micro_pentest,
)


class TestMicroPentestConfig:
    """Tests for MicroPentestConfig dataclass."""

    def test_default_values(self):
        """Test default configuration values."""
        config = MicroPentestConfig()
        assert config.pentagi_url == "http://pentagi:8443"
        assert config.timeout_seconds == 300.0
        assert config.provider == "openai"

    def test_custom_values(self):
        """Test custom configuration values."""
        config = MicroPentestConfig(
            pentagi_url="http://custom:9000",
            timeout_seconds=600.0,
            provider="anthropic",
        )
        assert config.pentagi_url == "http://custom:9000"
        assert config.timeout_seconds == 600.0
        assert config.provider == "anthropic"

    def test_env_var_default(self, monkeypatch):
        """Test that PENTAGI_BASE_URL env var is used as default."""
        monkeypatch.setenv("PENTAGI_BASE_URL", "http://env-pentagi:8080")
        config = MicroPentestConfig()
        assert config.pentagi_url == "http://env-pentagi:8080"


class TestGetPentAGIClient:
    """Tests for _get_pentagi_client helper function."""

    def test_returns_async_client(self):
        """Test that _get_pentagi_client returns an httpx.AsyncClient."""
        config = MicroPentestConfig(
            pentagi_url="http://test-pentagi:8443",
            timeout_seconds=120.0,
        )
        client = _get_pentagi_client(config)
        assert isinstance(client, httpx.AsyncClient)
        # Verify the client is configured correctly
        assert "test-pentagi:8443" in str(client.base_url)
        assert client.timeout.connect == 120.0

    def test_uses_config_values(self):
        """Test that client uses config values."""
        config = MicroPentestConfig(
            pentagi_url="http://custom:9000",
            timeout_seconds=600.0,
        )
        client = _get_pentagi_client(config)
        assert "custom:9000" in str(client.base_url)
        assert client.timeout.connect == 600.0


class TestMicroPentestResult:
    """Tests for MicroPentestResult dataclass."""

    def test_to_dict_minimal(self):
        """Test to_dict with minimal fields."""
        result = MicroPentestResult(status="started")
        d = result.to_dict()
        assert d["status"] == "started"
        assert d["cve_ids"] == []
        assert d["target_urls"] == []
        assert d["message"] == ""
        assert "flow_id" not in d
        assert "error" not in d

    def test_to_dict_with_flow_id(self):
        """Test to_dict includes flow_id when set."""
        result = MicroPentestResult(status="started", flow_id=123)
        d = result.to_dict()
        assert d["flow_id"] == 123

    def test_to_dict_with_error(self):
        """Test to_dict includes error when set."""
        result = MicroPentestResult(status="error", error="Something went wrong")
        d = result.to_dict()
        assert d["error"] == "Something went wrong"

    def test_to_dict_full(self):
        """Test to_dict with all fields."""
        result = MicroPentestResult(
            status="started",
            flow_id=456,
            cve_ids=["CVE-2024-1234"],
            target_urls=["http://example.com"],
            message="Test started",
            error=None,
        )
        d = result.to_dict()
        assert d["status"] == "started"
        assert d["flow_id"] == 456
        assert d["cve_ids"] == ["CVE-2024-1234"]
        assert d["target_urls"] == ["http://example.com"]
        assert d["message"] == "Test started"
        assert "error" not in d


class TestMicroPentestStatus:
    """Tests for MicroPentestStatus dataclass."""

    def test_to_dict_minimal(self):
        """Test to_dict with minimal fields."""
        status = MicroPentestStatus(flow_id=123, status="running")
        d = status.to_dict()
        assert d["flow_id"] == 123
        assert d["status"] == "running"
        assert d["progress"] == 0
        assert d["tasks"] == []
        assert "error" not in d

    def test_to_dict_with_error(self):
        """Test to_dict includes error when set."""
        status = MicroPentestStatus(
            flow_id=123, status="error", error="Connection failed"
        )
        d = status.to_dict()
        assert d["error"] == "Connection failed"

    def test_to_dict_full(self):
        """Test to_dict with all fields."""
        status = MicroPentestStatus(
            flow_id=789,
            status="completed",
            progress=100,
            tasks=[{"id": 1, "name": "scan"}],
            error=None,
        )
        d = status.to_dict()
        assert d["flow_id"] == 789
        assert d["status"] == "completed"
        assert d["progress"] == 100
        assert d["tasks"] == [{"id": 1, "name": "scan"}]
        assert "error" not in d


class TestRunMicroPentest:
    """Tests for run_micro_pentest function."""

    @pytest.mark.asyncio
    async def test_empty_cve_ids(self):
        """Test error when no CVE IDs provided."""
        result = await run_micro_pentest(cve_ids=[], target_urls=["http://example.com"])
        assert result.status == "error"
        assert result.error == "At least one CVE ID is required"

    @pytest.mark.asyncio
    async def test_empty_target_urls(self):
        """Test error when no target URLs provided."""
        result = await run_micro_pentest(cve_ids=["CVE-2024-1234"], target_urls=[])
        assert result.status == "error"
        assert result.error == "At least one target URL is required"

    @pytest.mark.asyncio
    async def test_successful_flow_creation(self):
        """Test successful PentAGI flow creation."""
        mock_response = MagicMock()
        mock_response.status_code = 201
        mock_response.json.return_value = {"data": {"id": 12345}}

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_micro_pentest(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            )

        assert result.status == "started"
        assert result.flow_id == 12345
        assert result.cve_ids == ["CVE-2024-1234"]
        assert result.target_urls == ["http://example.com"]
        assert "1 CVEs" in result.message

    @pytest.mark.asyncio
    async def test_successful_flow_creation_with_context(self):
        """Test successful flow creation with context."""
        mock_response = MagicMock()
        mock_response.status_code = 201
        mock_response.json.return_value = {"id": 99999}

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        test_context = {"environment": "staging"}
        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_micro_pentest(
                cve_ids=["CVE-2024-1234", "CVE-2024-5678"],
                target_urls=["http://example.com"],
                context=test_context,
            )

        assert result.status == "started"
        assert result.flow_id == 99999

        # Verify context was included in the API request payload
        mock_client.post.assert_awaited_once()
        call_kwargs = mock_client.post.await_args.kwargs
        assert "json" in call_kwargs
        assert call_kwargs["json"]["context"] == test_context

    @pytest.mark.asyncio
    async def test_pentagi_error_response(self):
        """Test handling of PentAGI error response."""
        mock_response = MagicMock()
        mock_response.status_code = 500
        mock_response.text = "Internal Server Error"

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_micro_pentest(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            )

        assert result.status == "error"
        assert "PentAGI API error" in result.error
        assert result.cve_ids == ["CVE-2024-1234"]
        assert result.target_urls == ["http://example.com"]

    @pytest.mark.asyncio
    async def test_timeout_exception(self):
        """Test handling of timeout exception."""
        mock_client = AsyncMock()
        mock_client.post = AsyncMock(side_effect=httpx.TimeoutException("Timeout"))
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_micro_pentest(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            )

        assert result.status == "error"
        assert result.error == "PentAGI request timeout"

    @pytest.mark.asyncio
    @pytest.mark.filterwarnings("ignore::UserWarning")
    async def test_request_error(self):
        """Test handling of request error (connection failed)."""
        mock_client = AsyncMock()
        mock_client.post = AsyncMock(
            side_effect=httpx.ConnectError("Connection refused")
        )
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_micro_pentest(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            )

        assert result.status == "error"
        assert result.error == "Failed to connect to PentAGI"

    @pytest.mark.asyncio
    async def test_uses_default_config(self):
        """Test that default config is used when not provided."""
        mock_response = MagicMock()
        mock_response.status_code = 201
        mock_response.json.return_value = {"data": {"id": 1}}

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_micro_pentest(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
                config=None,
            )

        assert result.status == "started"


class TestGetMicroPentestStatus:
    """Tests for get_micro_pentest_status function."""

    @pytest.mark.asyncio
    async def test_successful_status_retrieval(self):
        """Test successful status retrieval."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "status": "running",
            "progress": 50,
            "tasks": [{"id": 1, "name": "scan"}],
        }

        mock_client = AsyncMock()
        mock_client.get = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await get_micro_pentest_status(flow_id=123)

        assert result.flow_id == 123
        assert result.status == "running"
        assert result.progress == 50
        assert result.tasks == [{"id": 1, "name": "scan"}]

    @pytest.mark.asyncio
    async def test_error_response(self):
        """Test handling of error response."""
        mock_response = MagicMock()
        mock_response.status_code = 404
        mock_response.text = "Flow not found"

        mock_client = AsyncMock()
        mock_client.get = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await get_micro_pentest_status(flow_id=999)

        assert result.flow_id == 999
        assert result.status == "error"
        assert "Failed to get flow status" in result.error

    @pytest.mark.asyncio
    @pytest.mark.filterwarnings("ignore::UserWarning")
    async def test_request_error(self):
        """Test handling of request error."""
        mock_client = AsyncMock()
        mock_client.get = AsyncMock(
            side_effect=httpx.ConnectError("Connection refused")
        )
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await get_micro_pentest_status(flow_id=123)

        assert result.flow_id == 123
        assert result.status == "error"
        assert result.error == "Failed to connect to PentAGI"

    @pytest.mark.asyncio
    async def test_uses_default_config(self):
        """Test that default config is used when not provided."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"status": "completed", "progress": 100}

        mock_client = AsyncMock()
        mock_client.get = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await get_micro_pentest_status(flow_id=123, config=None)

        assert result.status == "completed"


class TestBatchTestConfig:
    """Tests for BatchTestConfig dataclass."""

    def test_default_values(self):
        """Test default values."""
        config = BatchTestConfig()
        assert config.cve_ids == []
        assert config.target_urls == []
        assert config.context == {}

    def test_custom_values(self):
        """Test custom values."""
        config = BatchTestConfig(
            cve_ids=["CVE-2024-1234"],
            target_urls=["http://example.com"],
            context={"env": "test"},
        )
        assert config.cve_ids == ["CVE-2024-1234"]
        assert config.target_urls == ["http://example.com"]
        assert config.context == {"env": "test"}


class TestRunBatchMicroPentests:
    """Tests for run_batch_micro_pentests function."""

    @pytest.mark.asyncio
    async def test_empty_configs(self):
        """Test error when no configs provided."""
        result = await run_batch_micro_pentests(test_configs=[])
        assert result["status"] == "error"
        assert result["error"] == "At least one test configuration is required"
        assert result["total"] == 0
        assert result["successful"] == 0
        assert result["failed"] == 0

    @pytest.mark.asyncio
    async def test_successful_batch(self):
        """Test successful batch execution."""
        mock_response = MagicMock()
        mock_response.status_code = 201
        mock_response.json.return_value = {"data": {"id": 123}}

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        configs = [
            BatchTestConfig(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            ),
            BatchTestConfig(
                cve_ids=["CVE-2024-5678"],
                target_urls=["http://test.com"],
            ),
        ]

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_batch_micro_pentests(test_configs=configs)

        assert result["status"] == "completed"
        assert result["total"] == 2
        assert result["successful"] == 2
        assert result["failed"] == 0
        assert len(result["results"]) == 2

    @pytest.mark.asyncio
    async def test_partial_failure(self):
        """Test batch with some failures."""
        success_response = MagicMock()
        success_response.status_code = 201
        success_response.json.return_value = {"data": {"id": 123}}

        error_response = MagicMock()
        error_response.status_code = 500
        error_response.text = "Server Error"

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(side_effect=[success_response, error_response])
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        configs = [
            BatchTestConfig(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            ),
            BatchTestConfig(
                cve_ids=["CVE-2024-5678"],
                target_urls=["http://test.com"],
            ),
        ]

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_batch_micro_pentests(test_configs=configs)

        assert result["status"] == "completed"
        assert result["total"] == 2
        assert result["successful"] == 1
        assert result["failed"] == 1

    @pytest.mark.asyncio
    async def test_uses_default_config(self):
        """Test that default config is used when not provided."""
        mock_response = MagicMock()
        mock_response.status_code = 201
        mock_response.json.return_value = {"data": {"id": 1}}

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        configs = [
            BatchTestConfig(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            ),
        ]

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_batch_micro_pentests(test_configs=configs, config=None)

        assert result["status"] == "completed"

    @pytest.mark.asyncio
    async def test_exception_in_batch(self):
        """Test handling of exceptions in batch."""
        mock_client = AsyncMock()
        mock_client.post = AsyncMock(side_effect=Exception("Unexpected error"))
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        configs = [
            BatchTestConfig(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            ),
        ]

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_batch_micro_pentests(test_configs=configs)

        assert result["status"] == "completed"
        assert result["total"] == 1
        assert result["failed"] == 1
        assert "error" in result["results"][0]


class TestValidateCveId:
    """Tests for _validate_cve_id function."""

    def test_valid_cve_id(self):
        """Test valid CVE ID formats."""
        assert _validate_cve_id("CVE-2024-1234") is True
        assert _validate_cve_id("CVE-2024-12345") is True
        assert _validate_cve_id("CVE-2024-123456") is True
        assert _validate_cve_id("cve-2024-1234") is True  # Case insensitive

    def test_invalid_cve_id(self):
        """Test invalid CVE ID formats."""
        assert _validate_cve_id("CVE-2024-123") is False  # Too short
        assert _validate_cve_id("CVE-24-1234") is False  # Year too short
        assert _validate_cve_id("CVE2024-1234") is False  # Missing dash
        assert _validate_cve_id("2024-1234") is False  # Missing CVE prefix
        assert _validate_cve_id("CVE-2024-") is False  # Missing number
        assert _validate_cve_id("") is False  # Empty string
        assert _validate_cve_id("malicious; DROP TABLE") is False  # Injection attempt


class TestValidateTargetUrl:
    """Tests for _validate_target_url function."""

    def test_valid_urls(self):
        """Test valid target URLs."""
        assert _validate_target_url("http://example.com") is True
        assert _validate_target_url("https://example.com") is True
        assert _validate_target_url("https://example.com/path") is True
        assert _validate_target_url("https://example.com:8080/path") is True

    def test_invalid_schemes(self):
        """Test URLs with invalid schemes."""
        assert _validate_target_url("ftp://example.com") is False
        assert _validate_target_url("file:///etc/passwd") is False
        assert _validate_target_url("javascript:alert(1)") is False

    def test_localhost_blocked(self):
        """Test that localhost URLs are blocked."""
        assert _validate_target_url("http://localhost") is False
        assert _validate_target_url("http://localhost:8080") is False
        assert _validate_target_url("http://127.0.0.1") is False
        assert _validate_target_url("http://127.0.0.1:8080") is False
        assert _validate_target_url("http://0.0.0.0") is False

    def test_private_ips_blocked(self):
        """Test that private IP ranges are blocked."""
        assert _validate_target_url("http://10.0.0.1") is False
        assert _validate_target_url("http://192.168.1.1") is False
        assert _validate_target_url("http://172.16.0.1") is False
        assert _validate_target_url("http://172.31.255.255") is False

    def test_invalid_urls(self):
        """Test invalid URL formats."""
        assert _validate_target_url("") is False
        assert _validate_target_url("not-a-url") is False
        assert _validate_target_url("http://") is False

    def test_urlparse_exception(self):
        """Test that exceptions during URL parsing return False."""
        with patch("core.micro_pentest.urlparse", side_effect=Exception("parse error")):
            assert _validate_target_url("http://example.com") is False


class TestSanitizeContext:
    """Tests for _sanitize_context function."""

    def test_none_context(self):
        """Test that None context returns None."""
        assert _sanitize_context(None) is None

    def test_valid_context(self):
        """Test that valid context is returned unchanged."""
        context = {"environment": "staging", "app": "test"}
        result = _sanitize_context(context)
        assert result == context

    def test_oversized_context(self):
        """Test that oversized context returns an error dict."""
        large_context = {"data": "x" * 20000}  # Exceeds 10KB limit
        result = _sanitize_context(large_context)
        assert result is not None
        assert "error" in result
        assert "Context too large" in result["error"]

    def test_unserializable_context(self):
        """Test that unserializable context returns error."""

        # Create an object that can't be JSON serialized
        class UnserializableClass:
            pass

        context = {"obj": UnserializableClass()}
        result = _sanitize_context(context)
        assert result is not None
        assert "error" in result
        assert "could not be serialized" in result["error"]


class TestRunMicroPentestValidation:
    """Tests for validation in run_micro_pentest function."""

    @pytest.mark.asyncio
    async def test_invalid_cve_id_rejected(self):
        """Test that invalid CVE IDs are rejected."""
        result = await run_micro_pentest(
            cve_ids=["invalid-cve"],
            target_urls=["http://example.com"],
        )
        assert result.status == "error"
        assert "Invalid CVE ID format" in result.error

    @pytest.mark.asyncio
    async def test_invalid_url_rejected(self):
        """Test that invalid URLs are rejected."""
        result = await run_micro_pentest(
            cve_ids=["CVE-2024-1234"],
            target_urls=["http://localhost"],
        )
        assert result.status == "error"
        assert "Invalid or blocked target URL" in result.error

    @pytest.mark.asyncio
    async def test_private_ip_rejected(self):
        """Test that private IPs are rejected."""
        result = await run_micro_pentest(
            cve_ids=["CVE-2024-1234"],
            target_urls=["http://192.168.1.1"],
        )
        assert result.status == "error"
        assert "Invalid or blocked target URL" in result.error

    @pytest.mark.asyncio
    async def test_missing_flow_id_error(self):
        """Test error when PentAGI response missing flow_id."""
        mock_response = MagicMock()
        mock_response.status_code = 201
        mock_response.json.return_value = {"data": {}}  # No id or flow_id

        mock_client = AsyncMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=None)

        with patch("core.micro_pentest._get_pentagi_client", return_value=mock_client):
            result = await run_micro_pentest(
                cve_ids=["CVE-2024-1234"],
                target_urls=["http://example.com"],
            )

        assert result.status == "error"
        assert "missing flow_id" in result.error
