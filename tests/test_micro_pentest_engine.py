"""Tests for the Enterprise Micro Penetration Testing Engine."""

import asyncio
import sys
from pathlib import Path

import pytest

# Add fixops-enterprise to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent / "fixops-enterprise"))

from src.services.micro_pentest_engine import (
    AttackSurface,
    AttackVector,
    ComplianceFramework,
    MicroPentestEngine,
    MicroScanConfig,
    MicroScanStatus,
    RiskLevel,
    ScanMode,
    ThreatCategory,
    ThreatModel,
)


def run_async(coro):
    """Helper to run async functions in sync tests."""
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        return loop.run_until_complete(coro)
    finally:
        loop.close()
        # Clear the event loop to avoid leaving a closed loop as the default
        asyncio.set_event_loop(None)


@pytest.fixture
def engine():
    """Create a micro pentest engine instance."""
    return MicroPentestEngine(enable_audit_logging=True)


@pytest.fixture
def basic_attack_surface():
    """Create a basic attack surface for testing."""
    return AttackSurface(
        name="Test API",
        target_url="https://api.example.com",
        target_type="api",
        endpoints=["/api/v1/users", "/api/v1/auth"],
        authentication_required=True,
        authentication_type="jwt",
        technologies=["python", "fastapi", "postgresql"],
        environment="staging",
    )


@pytest.fixture
def basic_threat_model():
    """Create a basic threat model for testing."""
    return ThreatModel(
        name="API Security Test",
        description="Test for common API vulnerabilities",
        categories=[ThreatCategory.INITIAL_ACCESS, ThreatCategory.CREDENTIAL_ACCESS],
        attack_vectors=[
            AttackVector.SQL_INJECTION,
            AttackVector.XSS,
            AttackVector.AUTHENTICATION_BYPASS,
            AttackVector.API_ABUSE,
        ],
        compliance_frameworks=[
            ComplianceFramework.SOC2,
            ComplianceFramework.OWASP_TOP_10,
        ],
        priority=8,
    )


@pytest.fixture
def scan_config(basic_attack_surface, basic_threat_model):
    """Create a scan configuration for testing."""
    return MicroScanConfig(
        name="Test Scan",
        attack_surface=basic_attack_surface,
        threat_model=basic_threat_model,
        scan_mode=ScanMode.ACTIVE,
        timeout_seconds=60,
        stop_on_critical=False,
        include_proof_of_concept=True,
        tenant_id="test-tenant",
        organization_id="test-org",
        created_by="test-user",
        tags=["test", "ci"],
    )


class TestMicroPentestEngine:
    """Tests for MicroPentestEngine class."""

    def test_run_scan_completes(self, engine, scan_config):
        """Test that a scan completes successfully."""
        result = run_async(engine.run_scan(scan_config))

        assert result.status == MicroScanStatus.COMPLETED
        assert result.scan_id is not None
        assert result.started_at is not None
        assert result.completed_at is not None
        assert result.execution_time_seconds > 0

    def test_run_scan_generates_findings(self, engine, scan_config):
        """Test that a scan generates findings."""
        result = run_async(engine.run_scan(scan_config))

        assert len(result.findings) > 0
        for finding in result.findings:
            assert finding.scan_id == result.scan_id
            assert finding.title
            assert finding.risk_level in RiskLevel

    def test_run_scan_validates_compliance(self, engine, scan_config):
        """Test that a scan validates compliance frameworks."""
        result = run_async(engine.run_scan(scan_config))

        assert len(result.compliance_status) > 0
        for framework, is_compliant in result.compliance_status.items():
            assert isinstance(is_compliant, bool)

    def test_run_scan_generates_attack_paths(self, engine, scan_config):
        """Test that a scan generates attack paths."""
        result = run_async(engine.run_scan(scan_config))

        assert isinstance(result.attack_paths, list)

    def test_run_scan_generates_summary(self, engine, scan_config):
        """Test that a scan generates a summary."""
        result = run_async(engine.run_scan(scan_config))

        assert result.summary is not None
        assert "total_findings" in result.summary
        assert "findings_by_risk" in result.summary
        assert "execution_time_seconds" in result.summary

    def test_get_scan_result(self, engine, scan_config):
        """Test retrieving a scan result by ID."""
        result = run_async(engine.run_scan(scan_config))
        retrieved = run_async(engine.get_scan_result(result.scan_id))

        assert retrieved is not None
        assert retrieved.scan_id == result.scan_id

    def test_get_scan_result_not_found(self, engine):
        """Test retrieving a non-existent scan result."""
        result = run_async(engine.get_scan_result("non-existent-id"))
        assert result is None

    def test_list_scans(self, engine, scan_config):
        """Test listing scans."""
        run_async(engine.run_scan(scan_config))
        scans = run_async(engine.list_scans())

        assert len(scans) > 0

    def test_list_scans_filter_by_tenant(self, engine, scan_config):
        """Test listing scans filtered by tenant."""
        run_async(engine.run_scan(scan_config))
        scans = run_async(engine.list_scans(tenant_id="test-tenant"))

        assert len(scans) > 0
        for scan in scans:
            assert scan.config.tenant_id == "test-tenant"

    def test_list_scans_filter_by_status(self, engine, scan_config):
        """Test listing scans filtered by status."""
        run_async(engine.run_scan(scan_config))
        scans = run_async(engine.list_scans(status=MicroScanStatus.COMPLETED))

        assert len(scans) > 0
        for scan in scans:
            assert scan.status == MicroScanStatus.COMPLETED

    def test_audit_logging(self, engine, scan_config):
        """Test that audit logs are created."""
        run_async(engine.run_scan(scan_config))
        logs = run_async(engine.get_audit_logs())

        assert len(logs) > 0
        assert any(log.action == "start_micro_scan" for log in logs)
        assert any(log.action == "complete_micro_scan" for log in logs)

    def test_audit_logs_filter_by_tenant(self, engine, scan_config):
        """Test filtering audit logs by tenant."""
        run_async(engine.run_scan(scan_config))
        logs = run_async(engine.get_audit_logs(tenant_id="test-tenant"))

        assert len(logs) > 0
        for log in logs:
            assert log.tenant_id == "test-tenant"

    def test_audit_logs_filter_by_action(self, engine, scan_config):
        """Test filtering audit logs by action."""
        run_async(engine.run_scan(scan_config))
        logs = run_async(engine.get_audit_logs(action="start_micro_scan"))

        assert len(logs) > 0
        for log in logs:
            assert log.action == "start_micro_scan"

    def test_get_health(self, engine):
        """Test getting engine health status."""
        health = run_async(engine.get_health())

        assert health["status"] == "healthy"
        assert "active_scans" in health
        assert "total_scans" in health
        assert "supported_attack_vectors" in health
        assert "supported_compliance_frameworks" in health


class TestAttackSurface:
    """Tests for AttackSurface dataclass."""

    def test_to_dict(self, basic_attack_surface):
        """Test converting attack surface to dictionary."""
        data = basic_attack_surface.to_dict()

        assert data["name"] == "Test API"
        assert data["target_url"] == "https://api.example.com"
        assert data["target_type"] == "api"
        assert len(data["endpoints"]) == 2
        assert data["authentication_required"] is True


class TestThreatModel:
    """Tests for ThreatModel dataclass."""

    def test_to_dict(self, basic_threat_model):
        """Test converting threat model to dictionary."""
        data = basic_threat_model.to_dict()

        assert data["name"] == "API Security Test"
        assert len(data["categories"]) == 2
        assert len(data["attack_vectors"]) == 4
        assert len(data["compliance_frameworks"]) == 2
        assert data["priority"] == 8


class TestScanConfig:
    """Tests for MicroScanConfig dataclass."""

    def test_to_dict(self, scan_config):
        """Test converting scan config to dictionary."""
        data = scan_config.to_dict()

        assert data["name"] == "Test Scan"
        assert data["scan_mode"] == "active"
        assert data["timeout_seconds"] == 60
        assert data["tenant_id"] == "test-tenant"
        assert data["organization_id"] == "test-org"


class TestEnums:
    """Tests for enum classes."""

    def test_threat_category_values(self):
        """Test ThreatCategory enum values."""
        assert ThreatCategory.INITIAL_ACCESS.value == "initial_access"
        assert ThreatCategory.CREDENTIAL_ACCESS.value == "credential_access"
        assert ThreatCategory.LATERAL_MOVEMENT.value == "lateral_movement"

    def test_attack_vector_values(self):
        """Test AttackVector enum values."""
        assert AttackVector.SQL_INJECTION.value == "sql_injection"
        assert AttackVector.XSS.value == "xss"
        assert AttackVector.AUTHENTICATION_BYPASS.value == "authentication_bypass"

    def test_compliance_framework_values(self):
        """Test ComplianceFramework enum values."""
        assert ComplianceFramework.SOC2.value == "soc2"
        assert ComplianceFramework.PCI_DSS.value == "pci_dss"
        assert ComplianceFramework.HIPAA.value == "hipaa"

    def test_scan_mode_values(self):
        """Test ScanMode enum values."""
        assert ScanMode.PASSIVE.value == "passive"
        assert ScanMode.ACTIVE.value == "active"
        assert ScanMode.AGGRESSIVE.value == "aggressive"
        assert ScanMode.STEALTH.value == "stealth"

    def test_risk_level_values(self):
        """Test RiskLevel enum values."""
        assert RiskLevel.CRITICAL.value == "critical"
        assert RiskLevel.HIGH.value == "high"
        assert RiskLevel.MEDIUM.value == "medium"
        assert RiskLevel.LOW.value == "low"
        assert RiskLevel.INFO.value == "info"
