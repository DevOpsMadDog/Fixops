"""Tests for Enterprise Micro Penetration Testing Engine."""

import asyncio
import pytest
from datetime import datetime

from fixops_enterprise.src.services.micro_pentest_engine import (
    AttackSurface,
    AttackVector,
    ComplianceFramework,
    MicroPentestEngine,
    MicroScanConfig,
    MicroScanStatus,
    RiskLevel,
    ScanMode,
    ThreatCategory,
    ThreatModel,
)


@pytest.fixture
def micro_pentest_engine():
    """Create a micro pentest engine for testing."""
    return MicroPentestEngine(
        db_path=":memory:",
        enable_audit_logging=True,
    )


@pytest.fixture
def sample_attack_surface():
    """Create a sample attack surface for testing."""
    return AttackSurface(
        name="Test API",
        target_url="https://api.example.com",
        target_type="api",
        endpoints=["/api/users", "/api/auth", "/api/data"],
        authentication_required=True,
        authentication_type="jwt",
        headers={"X-API-Key": "test-key"},
        environment="staging",
    )


@pytest.fixture
def sample_threat_model():
    """Create a sample threat model for testing."""
    return ThreatModel(
        name="OWASP API Security Top 10",
        description="Test for OWASP API Security vulnerabilities",
        categories=[
            ThreatCategory.INITIAL_ACCESS,
            ThreatCategory.CREDENTIAL_ACCESS,
        ],
        attack_vectors=[
            AttackVector.SQL_INJECTION,
            AttackVector.AUTHENTICATION_BYPASS,
            AttackVector.API_ABUSE,
        ],
        mitre_techniques=["T1190", "T1078"],
        owasp_categories=["A01:2021-Broken Access Control", "A03:2021-Injection"],
        priority=8,
        compliance_frameworks=[
            ComplianceFramework.OWASP_TOP_10,
            ComplianceFramework.SOC2,
        ],
    )


@pytest.mark.asyncio
async def test_create_micro_scan(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test creating a micro pen test scan."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(
        config=config,
        user_id="test_user",
    )
    
    assert result.status == MicroScanStatus.QUEUED
    assert result.scan_id is not None
    assert result.config.name == "Test Scan"
    
    # Verify audit log was created
    audit_logs = await micro_pentest_engine.get_audit_logs(
        tenant_id="test_tenant",
        action="create_micro_scan",
    )
    assert len(audit_logs) == 1
    assert audit_logs[0].action == "create_micro_scan"


@pytest.mark.asyncio
async def test_execute_micro_scan(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test executing a micro pen test scan."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        timeout_seconds=10,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    # Create scan
    result = await micro_pentest_engine.create_micro_scan(
        config=config,
        user_id="test_user",
    )
    
    # Execute scan
    result = await micro_pentest_engine.execute_micro_scan(
        scan_id=result.scan_id,
        user_id="test_user",
    )
    
    assert result.status == MicroScanStatus.COMPLETED
    assert len(result.findings) > 0
    assert result.summary is not None
    assert result.execution_time_seconds > 0
    
    # Verify findings
    has_critical_or_high = any(
        f.risk_level in [RiskLevel.CRITICAL, RiskLevel.HIGH]
        for f in result.findings
    )
    assert has_critical_or_high


@pytest.mark.asyncio
async def test_scan_findings_structure(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test that scan findings have the correct structure."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    for finding in result.findings:
        assert finding.id is not None
        assert finding.title != ""
        assert finding.description != ""
        assert isinstance(finding.risk_level, RiskLevel)
        assert isinstance(finding.attack_vector, AttackVector)
        assert isinstance(finding.threat_category, ThreatCategory)
        assert finding.remediation != ""
        assert isinstance(finding.evidence, dict)


@pytest.mark.asyncio
async def test_compliance_validation(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test compliance validation during scan."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    # Verify compliance status is checked
    assert len(result.compliance_status) > 0
    
    # Verify compliance status includes requested frameworks
    for framework in sample_threat_model.compliance_frameworks:
        assert framework in result.compliance_status


@pytest.mark.asyncio
async def test_stop_on_critical(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test that scan stops on critical finding when configured."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        stop_on_critical=True,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    # Scan should complete (critical findings stop further testing)
    assert result.status == MicroScanStatus.COMPLETED


@pytest.mark.asyncio
async def test_proof_of_concept_generation(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test proof of concept generation for findings."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        include_proof_of_concept=True,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    # Check that high/critical findings have POC
    high_risk_findings = [
        f for f in result.findings
        if f.risk_level in [RiskLevel.CRITICAL, RiskLevel.HIGH]
    ]
    
    has_poc = any(f.proof_of_concept is not None for f in high_risk_findings)
    assert has_poc


@pytest.mark.asyncio
async def test_scan_summary(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test scan summary generation."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    assert "total_findings" in result.summary
    assert "findings_by_risk" in result.summary
    assert "findings_by_vector" in result.summary
    assert "attack_paths_count" in result.summary
    assert "execution_time_seconds" in result.summary
    
    assert result.summary["total_findings"] == len(result.findings)


@pytest.mark.asyncio
async def test_list_scans(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test listing scans with filters."""
    # Create multiple scans
    for i in range(3):
        config = MicroScanConfig(
            name=f"Test Scan {i}",
            attack_surface=sample_attack_surface,
            threat_model=sample_threat_model,
            scan_mode=ScanMode.ACTIVE,
            tenant_id="test_tenant",
            organization_id="test_org",
            created_by="test_user",
        )
        await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    
    # List all scans
    scans = await micro_pentest_engine.list_scans(tenant_id="test_tenant")
    assert len(scans) == 3
    
    # List with status filter
    queued_scans = await micro_pentest_engine.list_scans(
        tenant_id="test_tenant",
        status=MicroScanStatus.QUEUED,
    )
    assert len(queued_scans) == 3


@pytest.mark.asyncio
async def test_cancel_scan(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test cancelling a running scan."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    
    # Start scan in background
    scan_id = result.scan_id
    
    # Simulate starting the scan
    result = await micro_pentest_engine.get_scan_result(scan_id)
    result.status = MicroScanStatus.RUNNING
    
    # Cancel scan
    success = await micro_pentest_engine.cancel_scan(scan_id=scan_id, user_id="test_user")
    assert success
    
    # Verify status
    result = await micro_pentest_engine.get_scan_result(scan_id)
    assert result.status == MicroScanStatus.CANCELLED


@pytest.mark.asyncio
async def test_audit_logging(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test audit logging functionality."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    # Create and execute scan
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    # Get audit logs
    audit_logs = await micro_pentest_engine.get_audit_logs(
        tenant_id="test_tenant",
        organization_id="test_org",
    )
    
    assert len(audit_logs) >= 2  # At least create and execute
    
    # Verify log structure
    for log in audit_logs:
        assert log.id is not None
        assert log.tenant_id == "test_tenant"
        assert log.organization_id == "test_org"
        assert log.user_id == "test_user"
        assert log.action in ["create_micro_scan", "execute_micro_scan"]
        assert isinstance(log.timestamp, datetime)


@pytest.mark.asyncio
async def test_attack_path_generation(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test attack path generation."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    # Verify attack paths were generated
    assert isinstance(result.attack_paths, list)
    
    # If attack paths exist, verify structure
    if result.attack_paths:
        for path in result.attack_paths:
            assert "id" in path
            assert "name" in path
            assert "steps" in path
            assert "risk_level" in path


@pytest.mark.asyncio
async def test_passive_scan_mode(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test passive scan mode (no exploitation)."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.PASSIVE,
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    assert result.status == MicroScanStatus.COMPLETED
    
    # In passive mode, no exploitation should be attempted
    exploit_attempts = sum(
        1 for f in result.findings
        if f.evidence.get("exploitation_attempted", False)
    )
    assert exploit_attempts == 0


@pytest.mark.asyncio
async def test_rate_limiting(
    micro_pentest_engine,
    sample_attack_surface,
    sample_threat_model,
):
    """Test rate limiting during scan."""
    config = MicroScanConfig(
        name="Test Scan",
        attack_surface=sample_attack_surface,
        threat_model=sample_threat_model,
        scan_mode=ScanMode.ACTIVE,
        rate_limit_rps=100,  # High rate limit for testing
        tenant_id="test_tenant",
        organization_id="test_org",
        created_by="test_user",
    )
    
    result = await micro_pentest_engine.create_micro_scan(config=config, user_id="test_user")
    result = await micro_pentest_engine.execute_micro_scan(scan_id=result.scan_id, user_id="test_user")
    
    # Scan should complete successfully
    assert result.status == MicroScanStatus.COMPLETED


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
